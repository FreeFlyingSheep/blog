<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>构建 LFS 系统 | FreeFlyingSheep 的小站</title><meta name=keywords content="LFS"><meta name=description content="根据《Linux From Scratch 版本 20200901-systemd，中文翻译版》构建 LFS systemd 10.0 的归纳总结。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/linux/lfs/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="构建 LFS 系统"><meta property="og:description" content="根据《Linux From Scratch 版本 20200901-systemd，中文翻译版》构建 LFS systemd 10.0 的归纳总结。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/linux/lfs/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-21T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-21T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="构建 LFS 系统"><meta name=twitter:description content="根据《Linux From Scratch 版本 20200901-systemd，中文翻译版》构建 LFS systemd 10.0 的归纳总结。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"构建 LFS 系统","item":"https://freeflyingsheep.github.io/posts/linux/lfs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"构建 LFS 系统","name":"构建 LFS 系统","description":"根据《Linux From Scratch 版本 20200901-systemd，中文翻译版》构建 LFS systemd 10.0 的归纳总结。\n","keywords":["LFS"],"articleBody":"根据《Linux From Scratch 版本 20200901-systemd，中文翻译版》构建 LFS systemd 10.0 的归纳总结。\nLFS 简介 LFS 项目主要是从源码一步一步构建一个定制的 Linux 系统。具体内容可以访问项目主页。\nLFS 构建过程 阅读官方手册。 宿主机环境检查，安装相应软件包，完成相关配置。 新建分区。 下载需要的软件包和补丁。 配置工作环境，主要包括创建目录布局、添加 lfs 用户、完成 lfs 用户的环境配置。 编译交叉工具链。 用编译好的交叉工具链，交叉编译基本工具，用于构建其他软件包。 进入 Chroot 环境，构建一些额外工具，用于后续构建和测试。 构建完整的 LFS 系统。 完成系统的基本设置。 配置内核和引导加载器。 收尾工作。  常见问题及个人理解 构建 LFS 系统的意义 如果是为了构建自己使用 Linux 系统，我真的不推荐 LFS，除非你有不得不用 LFS 系统的理由，不然用现成的 Linux 发行版比较靠谱。\n那么对于大部分人来说，构建 LFS 的意义肯定不是自己使用了，而是体验一步一步从源码构建的过程。这个过程，能让我们熟悉如何从源码安装软件包，了解一个系统包括哪些必要的组件，以及在一定程度上知晓它们的依赖关系。这对今后使用其他 Linux 发行版是有好处的，至少在一定程度上具备了从源码自己构建相关软件包的能力。\n当前，这一切的前提，是理解了构建 LFS 的大部分指令的含义，而不是复制粘贴完成构建。\n多次构建工具链的意义 这也是 LFS 作者重点讨论的内容。来看手册上描述的三个阶段：\n   阶段 Build Host Target 操作描述     1 pc pc lfs 在 pc 上使用 cc-pc 构建交叉编译器 cc1   2 pc lfs lfs 在 pc 上使用 cc1 构建 cc-lfs   3 lfs lfs lfs 在 lfs 上使用 cc-lfs 重新构建并测试它本身    根据官方手册，抛开用于验证的第三阶段，我们构建了两遍工具链，不妨来反向思考这个问题。\n最终我们希望用工具链 cc-lfs 来构建完整的 LFS 系统，所以我们需要构建 cc-lfs。\n现在我们需要在宿主机上构建 cc-lfs，如果直接用宿主机自带的 cc-pc，那么构建的 cc-lfs 将依赖于我们的宿主系统，这显然不是我们想要的结果，所以必须使用交叉编译工具链 cc1 来避免这种依赖，这就是第二遍构建——用 cc1 构建 cc-lfs。\n现在要在宿主机上构建交叉编译工具链 cc1，自然是使用宿主机自带的工具链 cc-pc，这就是第一次构建——用 cc-pc 构建交叉编译器 cc1。\n多次切换环境的意义 在构建 LFS 的过程中，我们进行了多次环境的切换，下面列出所有可能的环境切换：\n 从普通用户切换到 root 用户。 从 root 用户切换到 lfs 用户。 从 lfs 用户返回到 root 用户。 从 root 用户切换到 Chroot 环境。 从 Chroot 环境返回到 root 用户。 从 root 用户返回到普通用户。  第一次切换和第六次对应，是为了用 root 权限执行一些指令。\n第二次切换和第三次切换对应，这个切换不是强制要求的，因为用 root 权限进行操作存在较大风险，所以通过切换到 lfs 用户来降低这种风险，同时创建一个新用户也能更容易地建立干净的工作环境。\n第四次切换和第五次切换对应，因为我们希望在一个与宿主机隔离的环境中构建 LFS，确保尽可能不受宿主系统影响，所以进入了 Chroot 这个临时环境。\n工具链编译顺序的问题 这部分内容 LFS 作者给出了完整的介绍，简单概括如下：\n 我们首先安装 Binutils。这是由于 GCC 和 Glibc 的 configure 脚本首先测试汇编器和链接器的一些特性，以决定启用或禁用一些软件特性。\n下一步安装 GCC。\n下一步安装“净化的” (sanitized) Linux API 头文件。这允许 C 标准库 (Glibc) 与 Linux 内核提供的各种特性交互。\n下一步安装 Glibc。在构建 Glibc 时需要着重考虑编译器，二进制工具，以及内核头文件。\n接下来构建 C++ 标准库，然后是第 6 章中那些需要自身才能构建的程序后。\n在第 6 章一节的末尾，构建 lfs 本地编译器。首先使用和其他程序相同的 DESTDIR 第二次构建 binutils，然后第二次 构建 GCC，构建时忽略 libstdc++ 和其他不重要的库。\n在第 7 章中，进入 chroot 环境后，首先安装 libstdc++。之后临时性地安装工具链的正常工作所必须的程序。还要构建测试其他程序时必须的程序。此后，核心工具链成为自包含的本地工具链。在第 8 章中，构建、测试并最后一次安装所有软件包，它们组成功能完整的系统。\n 自动构建 LFS 官方的 ALFS 项目，是利用 shell 或 Python 脚本解析 LFS 手册的 XML 代码，生成相应的构建脚本完成全自动构建。但这个项目似乎很久没人维护了，目前依然停留在较早版本。这是一个非常智能的构建脚本，但技术要求相对较高。\n本人基于官方手册，抱着写着玩的心态，写了一个自动构建 LFS 的项目，该项目使用 shell 脚本编写，可以自动构建 LFS systemd 10.0 到一个虚拟磁盘文件，项目地址如下：https://github.com/FreeFlyingSheep/lfs。\n原本准备用 Python 重构一个脚本，但感觉实际意义不大，又耗时，就鸽了……\n","wordCount":"239","inLanguage":"zh-cn","datePublished":"2020-09-21T00:00:00Z","dateModified":"2020-09-21T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/linux/lfs/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>构建 LFS 系统</h1><div class=post-meta>September 21, 2020&nbsp;·&nbsp;2 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#lfs-%e7%ae%80%e4%bb%8b aria-label="LFS 简介">LFS 简介</a></li><li><a href=#lfs-%e6%9e%84%e5%bb%ba%e8%bf%87%e7%a8%8b aria-label="LFS 构建过程">LFS 构建过程</a></li><li><a href=#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e4%b8%aa%e4%ba%ba%e7%90%86%e8%a7%a3 aria-label=常见问题及个人理解>常见问题及个人理解</a><ul><li><a href=#%e6%9e%84%e5%bb%ba-lfs-%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%84%8f%e4%b9%89 aria-label="构建 LFS 系统的意义">构建 LFS 系统的意义</a></li><li><a href=#%e5%a4%9a%e6%ac%a1%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7%e9%93%be%e7%9a%84%e6%84%8f%e4%b9%89 aria-label=多次构建工具链的意义>多次构建工具链的意义</a></li><li><a href=#%e5%a4%9a%e6%ac%a1%e5%88%87%e6%8d%a2%e7%8e%af%e5%a2%83%e7%9a%84%e6%84%8f%e4%b9%89 aria-label=多次切换环境的意义>多次切换环境的意义</a></li><li><a href=#%e5%b7%a5%e5%85%b7%e9%93%be%e7%bc%96%e8%af%91%e9%a1%ba%e5%ba%8f%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=工具链编译顺序的问题>工具链编译顺序的问题</a></li></ul></li><li><a href=#%e8%87%aa%e5%8a%a8%e6%9e%84%e5%bb%ba-lfs aria-label="自动构建 LFS">自动构建 LFS</a></li></ul></div></details></div><div class=post-content><p>根据《<a href=https://bf.mengyan1223.wang/lfs/zh_CN/10.0-systemd/>Linux From Scratch 版本 20200901-systemd，中文翻译版</a>》构建 <code>LFS systemd 10.0</code> 的归纳总结。</p><h2 id=lfs-简介>LFS 简介<a hidden class=anchor aria-hidden=true href=#lfs-简介>#</a></h2><p>LFS 项目主要是从源码一步一步构建一个定制的 Linux 系统。具体内容可以访问<a href=http://www.linuxfromscratch.org/index.html>项目主页</a>。</p><h2 id=lfs-构建过程>LFS 构建过程<a hidden class=anchor aria-hidden=true href=#lfs-构建过程>#</a></h2><ol start=0><li>阅读官方手册。</li><li>宿主机环境检查，安装相应软件包，完成相关配置。</li><li>新建分区。</li><li>下载需要的软件包和补丁。</li><li>配置工作环境，主要包括创建目录布局、添加 <code>lfs</code> 用户、完成 <code>lfs</code> 用户的环境配置。</li><li>编译交叉工具链。</li><li>用编译好的交叉工具链，交叉编译基本工具，用于构建其他软件包。</li><li>进入 Chroot 环境，构建一些额外工具，用于后续构建和测试。</li><li>构建完整的 LFS 系统。</li><li>完成系统的基本设置。</li><li>配置内核和引导加载器。</li><li>收尾工作。</li></ol><h2 id=常见问题及个人理解>常见问题及个人理解<a hidden class=anchor aria-hidden=true href=#常见问题及个人理解>#</a></h2><h3 id=构建-lfs-系统的意义>构建 LFS 系统的意义<a hidden class=anchor aria-hidden=true href=#构建-lfs-系统的意义>#</a></h3><p>如果是为了构建自己使用 Linux 系统，我真的不推荐 LFS，除非你有不得不用 LFS 系统的理由，不然用现成的 Linux 发行版比较靠谱。</p><p>那么对于大部分人来说，构建 LFS 的意义肯定不是自己使用了，而是体验一步一步从源码构建的过程。这个过程，能让我们熟悉如何从源码安装软件包，了解一个系统包括哪些必要的组件，以及在一定程度上知晓它们的依赖关系。这对今后使用其他 Linux 发行版是有好处的，至少在一定程度上具备了从源码自己构建相关软件包的能力。</p><p>当前，这一切的前提，是理解了构建 LFS 的大部分指令的含义，而不是复制粘贴完成构建。</p><h3 id=多次构建工具链的意义>多次构建工具链的意义<a hidden class=anchor aria-hidden=true href=#多次构建工具链的意义>#</a></h3><p>这也是 LFS 作者重点讨论的内容。来看手册上描述的三个阶段：</p><table><thead><tr><th>阶段</th><th>Build</th><th>Host</th><th>Target</th><th>操作描述</th></tr></thead><tbody><tr><td>1</td><td><code>pc</code></td><td><code>pc</code></td><td><code>lfs</code></td><td>在 <code>pc</code> 上使用 <code>cc-pc</code> 构建交叉编译器 <code>cc1</code></td></tr><tr><td>2</td><td><code>pc</code></td><td><code>lfs</code></td><td><code>lfs</code></td><td>在 <code>pc</code> 上使用 <code>cc1</code> 构建 <code>cc-lfs</code></td></tr><tr><td>3</td><td><code>lfs</code></td><td><code>lfs</code></td><td><code>lfs</code></td><td>在 <code>lfs</code> 上使用 <code>cc-lfs</code> 重新构建并测试它本身</td></tr></tbody></table><p>根据官方手册，抛开用于验证的第三阶段，我们构建了两遍工具链，不妨来反向思考这个问题。</p><p>最终我们希望用工具链 <code>cc-lfs</code> 来构建完整的 LFS 系统，所以我们需要构建 <code>cc-lfs</code>。</p><p>现在我们需要在宿主机上构建 <code>cc-lfs</code>，如果直接用宿主机自带的 <code>cc-pc</code>，那么构建的 <code>cc-lfs</code> 将依赖于我们的宿主系统，这显然不是我们想要的结果，所以必须使用交叉编译工具链 <code>cc1</code> 来避免这种依赖，这就是第二遍构建——用 <code>cc1</code> 构建 <code>cc-lfs</code>。</p><p>现在要在宿主机上构建交叉编译工具链 <code>cc1</code>，自然是使用宿主机自带的工具链 <code>cc-pc</code>，这就是第一次构建——用 <code>cc-pc</code> 构建交叉编译器 <code>cc1</code>。</p><h3 id=多次切换环境的意义>多次切换环境的意义<a hidden class=anchor aria-hidden=true href=#多次切换环境的意义>#</a></h3><p>在构建 LFS 的过程中，我们进行了多次环境的切换，下面列出所有可能的环境切换：</p><ol><li>从普通用户切换到 <code>root</code> 用户。</li><li>从 <code>root</code> 用户切换到 <code>lfs</code> 用户。</li><li>从 <code>lfs</code> 用户返回到 <code>root</code> 用户。</li><li>从 <code>root</code> 用户切换到 Chroot 环境。</li><li>从 Chroot 环境返回到 <code>root</code> 用户。</li><li>从 <code>root</code> 用户返回到普通用户。</li></ol><p>第一次切换和第六次对应，是为了用 <code>root</code> 权限执行一些指令。</p><p>第二次切换和第三次切换对应，这个切换不是强制要求的，因为用 <code>root</code> 权限进行操作存在较大风险，所以通过切换到 <code>lfs</code> 用户来降低这种风险，同时创建一个新用户也能更容易地建立干净的工作环境。</p><p>第四次切换和第五次切换对应，因为我们希望在一个与宿主机隔离的环境中构建 LFS，确保尽可能不受宿主系统影响，所以进入了 Chroot 这个临时环境。</p><h3 id=工具链编译顺序的问题>工具链编译顺序的问题<a hidden class=anchor aria-hidden=true href=#工具链编译顺序的问题>#</a></h3><p>这部分内容 LFS 作者给出了完整的介绍，简单概括如下：</p><blockquote><p>我们首先安装 Binutils。这是由于 GCC 和 Glibc 的 configure 脚本首先测试汇编器和链接器的一些特性，以决定启用或>禁用一些软件特性。</p><p>下一步安装 GCC。</p><p>下一步安装“净化的” (sanitized) Linux API 头文件。这允许 C 标准库 (Glibc) 与 Linux 内核提供的各种特性交互。</p><p>下一步安装 Glibc。在构建 Glibc 时需要着重考虑编译器，二进制工具，以及内核头文件。</p><p>接下来构建 C++ 标准库，然后是第 6 章中那些需要自身才能构建的程序后。</p><p>在第 6 章一节的末尾，构建 lfs 本地编译器。首先使用和其他程序相同的 DESTDIR 第二次构建 binutils，然后第二次> 构建 GCC，构建时忽略 libstdc++ 和其他不重要的库。</p><p>在第 7 章中，进入 chroot 环境后，首先安装 libstdc++。之后临时性地安装工具链的正常工作所必须的程序。还要构建测试其他程序时必须的程序。此后，核心工具链成为自包含的本地工具链。在第 8 章中，构建、测试并最后一次安装所有软件包，它们组成功能完整的系统。</p></blockquote><h2 id=自动构建-lfs>自动构建 LFS<a hidden class=anchor aria-hidden=true href=#自动构建-lfs>#</a></h2><p>官方的 ALFS 项目，是利用 shell 或 Python 脚本解析 LFS 手册的 XML 代码，生成相应的构建脚本完成全自动构建。但这个项目似乎很久没人维护了，目前依然停留在较早版本。这是一个非常智能的构建脚本，但技术要求相对较高。</p><p>本人基于官方手册，抱着写着玩的心态，写了一个自动构建 LFS 的项目，该项目使用 shell 脚本编写，可以自动构建 <code>LFS systemd 10.0</code> 到一个虚拟磁盘文件，项目地址如下：<a href=https://github.com/FreeFlyingSheep/lfs>https://github.com/FreeFlyingSheep/lfs</a>。</p><p>原本准备用 Python 重构一个脚本，但感觉实际意义不大，又耗时，就鸽了……</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/lfs/>LFS</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/linux/wsl/><span class=title>«</span><br><span>安装 WSL</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/tips/linux-version/><span class=title>»</span><br><span>查看 Linux 版本</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>