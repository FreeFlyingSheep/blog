<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>连续页框的管理 | FreeFlyingSheep 的小站</title><meta name=keywords content="Linux 内核,内存管理,连续页框的管理"><meta name=description content="Linux 内核学习笔记系列，内存管理部分，简单介绍连续页框的管理。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/kernel/memory/continuous/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="连续页框的管理"><meta property="og:description" content="Linux 内核学习笔记系列，内存管理部分，简单介绍连续页框的管理。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/kernel/memory/continuous/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-24T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-24T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="连续页框的管理"><meta name=twitter:description content="Linux 内核学习笔记系列，内存管理部分，简单介绍连续页框的管理。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"连续页框的管理","item":"https://freeflyingsheep.github.io/posts/kernel/memory/continuous/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"连续页框的管理","name":"连续页框的管理","description":"Linux 内核学习笔记系列，内存管理部分，简单介绍连续页框的管理。\n","keywords":["Linux 内核","内存管理","连续页框的管理"],"articleBody":"Linux 内核学习笔记系列，内存管理部分，简单介绍连续页框的管理。\n分区页框分配器 请求页框的标志 include/linux/gfp.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  /* * GFP bitmasks.. */ /* Zone modifiers in GFP_ZONEMASK (see linux/mmzone.h - low two bits) */ #define __GFP_DMA 0x01 #define __GFP_HIGHMEM 0x02  /* * Action modifiers - doesn't change the zoning * * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt * _might_ fail. This depends upon the particular VM implementation. * * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller * cannot handle allocation failures. * * __GFP_NORETRY: The VM implementation must not retry indefinitely. */ #define __GFP_WAIT 0x10 /* Can wait and reschedule? */#define __GFP_HIGH 0x20 /* Should access emergency pools? */#define __GFP_IO 0x40 /* Can start physical IO? */#define __GFP_FS 0x80 /* Can call down to low-level FS? */#define __GFP_COLD 0x100 /* Cache-cold page required */#define __GFP_NOWARN 0x200 /* Suppress page allocation failure warning */#define __GFP_REPEAT 0x400 /* Retry the allocation. Might fail */#define __GFP_NOFAIL 0x800 /* Retry for ever. Cannot fail */#define __GFP_NORETRY 0x1000 /* Do not retry. Might fail */#define __GFP_NO_GROW 0x2000 /* Slab internal usage */#define __GFP_COMP 0x4000 /* Add compound page metadata */#define __GFP_ZERO 0x8000 /* Return zeroed page on success */ #define __GFP_BITS_SHIFT 16 /* Room for 16 __GFP_FOO bits */#define __GFP_BITS_MASK ((1  /* if you forget to add the bitmask here kernel will crash, period */ #define GFP_LEVEL_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_FS| \\ __GFP_COLD|__GFP_NOWARN|__GFP_REPEAT| \\ __GFP_NOFAIL|__GFP_NORETRY|__GFP_NO_GROW|__GFP_COMP)  #define GFP_ATOMIC (__GFP_HIGH) #define GFP_NOIO (__GFP_WAIT) #define GFP_NOFS (__GFP_WAIT | __GFP_IO) #define GFP_KERNEL (__GFP_WAIT | __GFP_IO | __GFP_FS) #define GFP_USER (__GFP_WAIT | __GFP_IO | __GFP_FS) #define GFP_HIGHUSER (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HIGHMEM)  /* Flag - indicates that the buffer will be suitable for DMA. Ignored on some platforms, used as appropriate on others */ #define GFP_DMA __GFP_DMA   请求页框    函数 功能     alloc_pages(gfp_mask, order) 请求 $2^{order}$ 个连续的页框，成功则返回分配的第一个页框描述符的地址，失败则返回 NULL。   alloc_page(gfp_mask) 请求一个单独的页框，成功则返回分配的第一个页框描述符的地址，失败则返回 NULL。   __get_free_pages(gfp_mask, order) 请求 $2^{order}$ 个连续的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。   __get_free_page(gfp_mask) 请求一个单独的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。   get_zeroed_page(gfp_mask) 请求一个填满 0 的单独的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。   __get_dma_pages(gfp_mask, order) 请求 $2^{order}$ 个适用于 DMA 的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。    include/linux/gfp.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  static inline struct page *alloc_pages_node(int nid, unsigned int gfp_mask, unsigned int order) { if (unlikely(order = MAX_ORDER)) return NULL; return __alloc_pages(gfp_mask, order, NODE_DATA(nid)-node_zonelists + (gfp_mask \u0026 GFP_ZONEMASK)); } #ifdef CONFIG_NUMA extern struct page *alloc_pages_current(unsigned gfp_mask, unsigned order); static inline struct page * alloc_pages(unsigned int gfp_mask, unsigned int order) { if (unlikely(order = MAX_ORDER)) return NULL; return alloc_pages_current(gfp_mask, order); } #else #define alloc_pages(gfp_mask, order) \\ alloc_pages_node(numa_node_id(), gfp_mask, order) #endif #define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)  extern unsigned long FASTCALL(__get_free_pages(unsigned int gfp_mask, unsigned int order)); extern unsigned long FASTCALL(get_zeroed_page(unsigned int gfp_mask)); #define __get_free_page(gfp_mask) \\ __get_free_pages((gfp_mask),0)  #define __get_dma_pages(gfp_mask, order) \\ __get_free_pages((gfp_mask) | GFP_DMA,(order))   mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /* * Common helper functions. */ fastcall unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order) { struct page * page; page = alloc_pages(gfp_mask, order); if (!page) return 0; return (unsigned long) page_address(page); } EXPORT_SYMBOL(__get_free_pages); fastcall unsigned long get_zeroed_page(unsigned int gfp_mask) { struct page * page; /* * get_zeroed_page() returns a 32-bit address, which cannot represent * a highmem page */ BUG_ON(gfp_mask \u0026 __GFP_HIGHMEM); page = alloc_pages(gfp_mask | __GFP_ZERO, 0); if (page) return (unsigned long) page_address(page); return 0; } EXPORT_SYMBOL(get_zeroed_page);   mm/mempolicy.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * alloc_pages_current - Allocate pages. * * @gfp: * %GFP_USER user allocation, * %GFP_KERNEL kernel allocation, * %GFP_HIGHMEM highmem allocation, * %GFP_FS don't call back into a file system. * %GFP_ATOMIC don't sleep. * @order: Power of two of allocation size in pages. 0 is a single page. * * Allocate a page from the kernel page pool. When not in * interrupt context and apply the current process NUMA policy. * Returns NULL when no page can be allocated. */ struct page *alloc_pages_current(unsigned gfp, unsigned order) { struct mempolicy *pol = current-mempolicy; if (!pol || in_interrupt()) pol = \u0026default_policy; if (pol-policy == MPOL_INTERLEAVE) return alloc_page_interleave(gfp, order, interleave_nodes(pol)); return __alloc_pages(gfp, order, zonelist_policy(gfp, pol)); } EXPORT_SYMBOL(alloc_pages_current);   __alloc_pages() 函数见 __alloc_pages() 函数。\n释放页框    函数 功能     __free_pages(page, order) 检查 page 指向的页描述符，若该页框未被保留 (PG_reserved 标志为 0)，就把 count 减一。如果 count 为 0，就释放页框。   free_pages(addr, order) 接受页框的线性地址而不是页描述符，其余和 __free_pages(page, order) 相同   __free_page(page) __free_pages(page, 0)   free_page(addr) free_pages(addr, 0)    include/linux/gfp.h：\n1 2 3 4 5 6 7  extern void FASTCALL(__free_pages(struct page *page, unsigned int order)); extern void FASTCALL(free_pages(unsigned long addr, unsigned int order)); extern void FASTCALL(free_hot_page(struct page *page)); extern void FASTCALL(free_cold_page(struct page *page)); #define __free_page(page) __free_pages((page), 0) #define free_page(addr) free_pages((addr),0)   mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9  fastcall void free_pages(unsigned long addr, unsigned int order) { if (addr != 0) { BUG_ON(!virt_addr_valid((void *)addr)); __free_pages(virt_to_page((void *)addr), order); } } EXPORT_SYMBOL(free_pages);   __free_pages() 函数见释放内存。\n很多函数涉及伙伴系统和 per-CPU 页框高速缓存，这里就不展开了。\n管理区分配器简介 管理区分配器是内核页框分配器的前端。\n整个连续内存分配涉及的内容大致如下：\n管理区分配器必须分配一个包含足够多空闲页框的内存区，来满足内存请求，它得满足如下目标：\n 保护保留的页框池。 当内存不足且允许阻塞当前进程时，应当触发页框回收算法，一旦某些页框被释放，将再次尝试分配。 如果可能，应当保存小而珍贵的 ZONE_DMA 内存管理区。例如，如果是对 ZONE_NORMAL 或 ZONE_HIGHMEM 页框的请求，尽可能不分配 ZONE_DMA 内存管理区中的页框。  保留的页框池 在请求内存时，一些内核控制路径不能被阻塞，如处理中断或执行临界区内的代码时。在这些情况下，一条控制路径应当产生原子内存分配请求 (设置 GFP_ATOMIC 标志)。原子请求从不被阻塞，如果没有足够空闲页，仅返回失败。\n尽管无法保证原子内存分配请求不失败，但内核会设法尽量减少这种不幸事件发生的可能性。因此，内核为原子内存分配请求保留了一个页框池，只有在内存不足时才使用。\n保留内存的数量（以 KB 为单位）存放在 min_free_kbytes 变量中。管理区描述符的部分字段都会在 mim_free_kbytes 初始化时一起完成初始化（init_per_zone_pages_min() 函数调用 setup_per_zone_pages_min() 函数和 setup_per_zone_lowmem_reserve() 函数，这些函数都位于 mm/page_alloc.c）。\n pages_min：管理区中保留页的数目，被设置为 $\\lfloor \\sqrt{16 \\times 直接映射内存的大小} \\rfloor$。 pages_low：回收页框使用的下界，被设置为 pages_min 的 $\\frac{5}{4}$。 pages_high：回收页框使用的上界，被设置为 pages_min 的 $\\frac{3}{2}$。 lowmem_reserve：每个管理区必须保留的页框数目，例子代码注释中有，见下。  1 2 3 4 5 6 7 8  /* * results with 256, 32 in the lowmem_reserve sysctl: * 1G machine - (16M dma, 800M-16M normal, 1G-800M high) * 1G machine - (16M dma, 784M normal, 224M high) * NORMAL allocation will leave 784M/256 of ram reserved in the ZONE_DMA * HIGHMEM allocation will leave 224M/32 of ram reserved in ZONE_NORMAL * HIGHMEM allocation will (224M+784M)/256 of ram reserved in ZONE_DMA */   分配内存 zone_watermark_ok() 函数 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* * Return 1 if free pages are above 'mark'. This takes into account the order * of the allocation. */ int zone_watermark_ok(struct zone *z, int order, unsigned long mark, int classzone_idx, int can_try_harder, int gfp_high) { /* free_pages my go negative - that's OK */ long min = mark, free_pages = z-free_pages - (1  order) + 1; int o; if (gfp_high) min -= min / 2; if (can_try_harder) min -= min / 4; if (free_pages  min + z-lowmem_reserve[classzone_idx]) return 0; for (o = 0; o  order; o++) { /* At the next order, this order's pages become unavailable */ free_pages -= z-free_area[o].nr_free  o; /* Require fewer higher order pages to be free */ min = 1; if (free_pages  min) return 0; } return 1; }   zone_watermark_ok() 是一个辅助函数，在满足如下两个条件时返回 1：\n 除了被分配的页框外，内存管理区中至少还有 min 个空闲页框（不包括保留的页框）。 除了被分配的页框外，在 order 至少为 o 的块中，有大于等于 min / $2^{o}$ 个空闲页框。  阈值 min 的值由 mask. can_try_harder 和 gfp_high 确定：\n mask 可能是 pages_min. pages_low 和 pages_high 中的一个。 若 gfp_high 被置位，把么把 mask 除以 2。 这种情况通常发生在 __GFP_WAIT 标志被置位时，即能从高端内存分配页框。 若 can_try_harder被置位，那么把 mask 再除以 4。 这种情况通常发生在 __GFP_WAIT 标志被置位时，或者当前进程是一个位于进程上下文中（不在中断处理程序和可延迟函数中）且已经完成内存分配的实时进程。  __alloc_pages() 函数 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11  /* * This is the 'heart' of the zoned buddy allocator. */ struct page * fastcall __alloc_pages(unsigned int gfp_mask, unsigned int order, struct zonelist *zonelist) { ... // 详细流程见下 } EXPORT_SYMBOL(__alloc_pages);   该函数的详细流程是：\n  准备工作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const int wait = gfp_mask \u0026 __GFP_WAIT; struct zone **zones, *z; struct page *page; struct reclaim_state reclaim_state; struct task_struct *p = current; int i; int classzone_idx; int do_retry; int can_try_harder; int did_some_progress; might_sleep_if(wait); /* * The caller may dip into page reserves a bit more if the caller * cannot run direct reclaim, or is the caller has realtime scheduling * policy */ can_try_harder = (unlikely(rt_task(p)) \u0026\u0026 !in_interrupt()) || !wait; zones = zonelist-zones; /* the list of zones suitable for gfp_mask */ if (unlikely(zones[0] == NULL)) { /* Should this ever happen?? */ return NULL; } classzone_idx = zone_idx(zones[0]);     第一次遍历存放管理区的数组（zonelist），寻找有足够空闲内存的管理区。若能满足请求，跳转到第 15 步。\n1 2 3 4 5 6 7 8 9 10 11 12  restart: /* Go through the zonelist once, looking for a zone with enough free */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-pages_low, classzone_idx, 0, 0)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; }     来到这里，说明没足够的空闲内存。触发页框回收算法，这部分内容属于《深入理解 Linux 内核》中“回收页框”章节，这里不展开。\n1 2  for (i = 0; (z = zones[i]) != NULL; i++) wakeup_kswapd(z, order);     第二次遍历存放管理区的数组，但使用了较低的阈值（注意传递给 zone_watermark_ok() 的参数不同）。若能满足请求，跳转到第 15 步。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * Go through the zonelist again. Let __GFP_HIGH and allocations * coming from realtime tasks to go deeper into reserves */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-pages_min, classzone_idx, can_try_harder, gfp_mask \u0026 __GFP_HIGH)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; }     来到这里，说明系统没足够内存。如果内存分配请求的内核路径不是一个中断处理程序或一个可延迟函数，并且试图回收页框（PF_MEMALLOC 或 TIF_MEMDIE 标志被置位），那么进行第三次遍历，这次忽略阈值（不调用 zone_watermark_ok()）。这种情况下，允许内核控制路径耗用为内存不足预留的页（保留的页框池）。其实，PF_MEMALLOC 表示该进程当前正在执行“内存规整（memory compaction）”或“直接回收（direct reclaim）”，而 TIF_MEMDIE 则表示该进程已经触发了内存不足清理（out-of-memory killer）并且正在尝试退出，以上这些操作都可能导致更多的内存页框被释放，因此只要有可能，请求就被满足。若能满足请求，跳转到第 15 步；反之，跳转到第 14 步。\n1 2 3 4 5 6 7 8 9 10  /* This allocation should allow future memory freeing. */ if (((p-flags \u0026 PF_MEMALLOC) || unlikely(test_thread_flag(TIF_MEMDIE))) \u0026\u0026 !in_interrupt()) { /* go through the zonelist yet again, ignoring mins */ for (i = 0; (z = zones[i]) != NULL; i++) { page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; } goto nopage; }     来到这里，必须阻塞当前进程才能满足请求（__GFP_WAIT 需要被置位）。否则，跳转到第 14 步。\n1 2 3  /* Atomic allocations - we can't balance anything */ if (!wait) goto nopage;     来到这里，说明进程能够被阻塞，调用 cond_resched() 检查是否有其它进程需要 CPU。\n1 2  rebalance: cond_resched();     设置 PF_MEMALLOC 标志，表示进程已经准备好执行内存回收。\n1 2  /* We now go into synchronous reclaim */ p-flags |= PF_MEMALLOC;     将 reclaim_state 存入 current-reclaim_state。\n1 2  reclaim_state.reclaimed_slab = 0; p-reclaim_state = \u0026reclaim_state;     调用 try_to_free_pages() 来回收页框，这部分内容属于《深入理解 Linux 内核》中“回收页框”章节，这里不展开。该函数可能阻塞当前进程，一旦函数返回，重设 PF_MEMALLOC 标志并再次调用 cond_resched()。\n1 2 3 4 5 6  did_some_progress = try_to_free_pages(zones, gfp_mask, order); p-reclaim_state = NULL; p-flags \u0026= ~PF_MEMALLOC; cond_resched();     如果已经释放了一些页框，那么按第 4 步的方式再次遍历存放内存管理区的数组。若能满足请求，跳转到第 15 步。如果分配请求不能被满足，__GFP_NORETRY（分配失败时不重复分配）被清除且 __GFP_FS（可以启动文件系统 I/O）被置位，那么再次遍历存放内存管理区的数组（注意传递给 zone_watermark_ok() 的参数不同）。若能满足请求，跳转到第 15 步；反之，说明内存耗尽，通过调用 out_of_memory()（该函数位于 mm/oom_kill.c）杀死一个进程，来保证系统不崩溃，然后转到第 2 步。这次遍历的阈值比之前的要高，因此很容易失败，只有在另一个内核控制路径已经通过杀死了一个进程来回收了它的内存的时候，才会成功，但这种情况下，确实避免了两个无辜的进程（而不是一个）被杀死。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  if (likely(did_some_progress)) { /* * Go through the zonelist yet one more time, keep * very high watermark here, this is only to catch * a parallel oom killing, we must fail if we're still * under heavy pressure. */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-pages_min, classzone_idx, can_try_harder, gfp_mask \u0026 __GFP_HIGH)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; } } else if ((gfp_mask \u0026 __GFP_FS) \u0026\u0026 !(gfp_mask \u0026 __GFP_NORETRY)) { /* * Go through the zonelist yet one more time, keep * very high watermark here, this is only to catch * a parallel oom killing, we must fail if we're still * under heavy pressure. */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-pages_high, classzone_idx, 0, 0)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; } out_of_memory(gfp_mask); goto restart; }     如果 order （和具体实现有关）或者 __GFP_REPEAT 被置位，设置 do_retry。如果 __GFP_NOFAIL 被置位，设置 do_retry。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * Don't let big-order allocations loop unless the caller explicitly * requests that. Wait for some write requests to complete then retry. * * In this implementation, __GFP_REPEAT means __GFP_NOFAIL for order * */ do_retry = 0; if (!(gfp_mask \u0026 __GFP_NORETRY)) { if ((order  3) || (gfp_mask \u0026 __GFP_REPEAT)) do_retry = 1; if (gfp_mask \u0026 __GFP_NOFAIL) do_retry = 1; }     如果 do_retry 被设置，调用 blk_congestion_wait() 使进程休眠一会（见 TODO），并跳转到第 7 步。\n1 2 3 4  if (do_retry) { blk_congestion_wait(WRITE, HZ/50); goto rebalance; }     来到这里，说明请求不能被满足，返回 NULL。\n1 2 3 4 5 6 7 8  nopage: if (!(gfp_mask \u0026 __GFP_NOWARN) \u0026\u0026 printk_ratelimit()) { printk(KERN_WARNING \"%s: page allocation failure.\" \" order:%d, mode:0x%x\\n\", p-comm, order, gfp_mask); dump_stack(); } return NULL;     来到这里，说明请求能被满足，调用 zone_statistics() 完成一些数据统计工作 (主要针对 NUMA)，然后返回第一个被分配的页框的页描述符。\n1 2 3  got_pg: zone_statistics(zonelist, z); return page;     释放内存 __free_pages() 函数比较简单，直接贴代码。\nmm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  void __free_pages_ok(struct page *page, unsigned int order) { LIST_HEAD(list); int i; arch_free_page(page, order); mod_page_state(pgfree, 1  order); #ifndef CONFIG_MMU  if (order  0) for (i = 1 ; i  (1  order) ; ++i) __put_page(page + i); #endif  for (i = 0 ; i  (1  order) ; ++i) free_pages_check(__FUNCTION__, page + i); list_add(\u0026page-lru, \u0026list); kernel_map_pages(page, 1order, 0); free_pages_bulk(page_zone(page), 1, \u0026list, order); } fastcall void __free_pages(struct page *page, unsigned int order) { if (!PageReserved(page) \u0026\u0026 put_page_testzero(page)) { if (order == 0) free_hot_page(page); else __free_pages_ok(page, order); } } EXPORT_SYMBOL(__free_pages);   include/linux/mm.h：\n1 2 3 4 5 6 7 8 9  /* * Drop a ref, return true if the logical refcount fell to zero (the page has * no users) */ #define put_page_testzero(p) \\ ({ \\ BUG_ON(page_count(p) == 0); \\ atomic_add_negative(-1, \u0026(p)-_count); \\ })   很多函数涉及伙伴系统和 per-CPU 页框高速缓存，这里就不展开了。\n内存池 内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。\n注意内存池与保留的页框池（见保留的页框池）的区别。保留的页框池是用于满足中断处理程序或内部临界区发出的原子分配请求的；而内存池是动态内存的储备，只能被特定的内核成分（池的拥有者）使用。\n拥有者通常不使用内存池的储备（而是从普通内存中分配），如果动态内存变得极其稀有以至于所有普通内存分配请求都失败的话，那么内核成分就能调用特地的内存池函数提取储备得到所需的内存。当然，这已经是最后的解决手段了。\n","wordCount":"2226","inLanguage":"zh-cn","datePublished":"2020-07-24T00:00:00Z","dateModified":"2020-07-24T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/kernel/memory/continuous/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>连续页框的管理</h1><div class=post-meta>July 24, 2020&nbsp;·&nbsp;11 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%88%86%e5%8c%ba%e9%a1%b5%e6%a1%86%e5%88%86%e9%85%8d%e5%99%a8 aria-label=分区页框分配器>分区页框分配器</a><ul><li><a href=#%e8%af%b7%e6%b1%82%e9%a1%b5%e6%a1%86%e7%9a%84%e6%a0%87%e5%bf%97 aria-label=请求页框的标志>请求页框的标志</a></li><li><a href=#%e8%af%b7%e6%b1%82%e9%a1%b5%e6%a1%86 aria-label=请求页框>请求页框</a></li><li><a href=#%e9%87%8a%e6%94%be%e9%a1%b5%e6%a1%86 aria-label=释放页框>释放页框</a></li></ul></li><li><a href=#%e7%ae%a1%e7%90%86%e5%8c%ba%e5%88%86%e9%85%8d%e5%99%a8%e7%ae%80%e4%bb%8b aria-label=管理区分配器简介>管理区分配器简介</a></li><li><a href=#%e4%bf%9d%e7%95%99%e7%9a%84%e9%a1%b5%e6%a1%86%e6%b1%a0 aria-label=保留的页框池>保留的页框池</a></li><li><a href=#%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98 aria-label=分配内存>分配内存</a><ul><li><a href=#zone_watermark_ok-%e5%87%bd%e6%95%b0 aria-label="zone_watermark_ok() 函数"><code>zone_watermark_ok()</code> 函数</a></li><li><a href=#__alloc_pages-%e5%87%bd%e6%95%b0 aria-label="__alloc_pages() 函数"><code>__alloc_pages()</code> 函数</a></li></ul></li><li><a href=#%e9%87%8a%e6%94%be%e5%86%85%e5%ad%98 aria-label=释放内存>释放内存</a></li><li><a href=#%e5%86%85%e5%ad%98%e6%b1%a0 aria-label=内存池>内存池</a></li></ul></div></details></div><div class=post-content><p><a href=/posts/kernel/kernel>Linux 内核学习笔记系列</a>，内存管理部分，简单介绍连续页框的管理。</p><h2 id=分区页框分配器>分区页框分配器<a hidden class=anchor aria-hidden=true href=#分区页框分配器>#</a></h2><h3 id=请求页框的标志>请求页框的标志<a hidden class=anchor aria-hidden=true href=#请求页框的标志>#</a></h3><p><code>include/linux/gfp.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * GFP bitmasks..
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>/* Zone modifiers in GFP_ZONEMASK (see linux/mmzone.h - low two bits) */</span>
<span style=color:#75715e>#define __GFP_DMA 0x01
</span><span style=color:#75715e>#define __GFP_HIGHMEM 0x02
</span><span style=color:#75715e></span>
<span style=color:#75715e>/*
</span><span style=color:#75715e> * Action modifiers - doesn&#39;t change the zoning
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt
</span><span style=color:#75715e> * _might_ fail.  This depends upon the particular VM implementation.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller
</span><span style=color:#75715e> * cannot handle allocation failures.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * __GFP_NORETRY: The VM implementation must not retry indefinitely.
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>#define __GFP_WAIT 0x10 </span><span style=color:#75715e>/* Can wait and reschedule? */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_HIGH 0x20 </span><span style=color:#75715e>/* Should access emergency pools? */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_IO 0x40 </span><span style=color:#75715e>/* Can start physical IO? */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_FS 0x80 </span><span style=color:#75715e>/* Can call down to low-level FS? */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_COLD 0x100 </span><span style=color:#75715e>/* Cache-cold page required */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_NOWARN 0x200 </span><span style=color:#75715e>/* Suppress page allocation failure warning */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_REPEAT 0x400 </span><span style=color:#75715e>/* Retry the allocation.  Might fail */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_NOFAIL 0x800 </span><span style=color:#75715e>/* Retry for ever.  Cannot fail */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_NORETRY 0x1000 </span><span style=color:#75715e>/* Do not retry.  Might fail */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_NO_GROW 0x2000 </span><span style=color:#75715e>/* Slab internal usage */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_COMP 0x4000 </span><span style=color:#75715e>/* Add compound page metadata */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_ZERO 0x8000 </span><span style=color:#75715e>/* Return zeroed page on success */</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define __GFP_BITS_SHIFT 16 </span><span style=color:#75715e>/* Room for 16 __GFP_FOO bits */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define __GFP_BITS_MASK ((1 &lt;&lt; __GFP_BITS_SHIFT) - 1)
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* if you forget to add the bitmask here kernel will crash, period */</span>
<span style=color:#75715e>#define GFP_LEVEL_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_FS| \
</span><span style=color:#75715e>            __GFP_COLD|__GFP_NOWARN|__GFP_REPEAT| \
</span><span style=color:#75715e>            __GFP_NOFAIL|__GFP_NORETRY|__GFP_NO_GROW|__GFP_COMP)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define GFP_ATOMIC (__GFP_HIGH)
</span><span style=color:#75715e>#define GFP_NOIO (__GFP_WAIT)
</span><span style=color:#75715e>#define GFP_NOFS (__GFP_WAIT | __GFP_IO)
</span><span style=color:#75715e>#define GFP_KERNEL (__GFP_WAIT | __GFP_IO | __GFP_FS)
</span><span style=color:#75715e>#define GFP_USER (__GFP_WAIT | __GFP_IO | __GFP_FS)
</span><span style=color:#75715e>#define GFP_HIGHUSER (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HIGHMEM)
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* Flag - indicates that the buffer will be suitable for DMA.  Ignored on some
</span><span style=color:#75715e>   platforms, used as appropriate on others */</span>

<span style=color:#75715e>#define GFP_DMA __GFP_DMA
</span></code></pre></td></tr></table></div></div><h3 id=请求页框>请求页框<a hidden class=anchor aria-hidden=true href=#请求页框>#</a></h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>alloc_pages(gfp_mask, order)</code></td><td>请求 $2^{order}$ 个连续的页框，成功则返回分配的第一个页框描述符的地址，失败则返回 <code>NULL</code>。</td></tr><tr><td><code>alloc_page(gfp_mask)</code></td><td>请求一个单独的页框，成功则返回分配的第一个页框描述符的地址，失败则返回 <code>NULL</code>。</td></tr><tr><td><code>__get_free_pages(gfp_mask, order)</code></td><td>请求 $2^{order}$ 个连续的页框，成功则返回分配的第一个页框的线性地址，失败则返回 <code>0</code>。</td></tr><tr><td><code>__get_free_page(gfp_mask)</code></td><td>请求一个单独的页框，成功则返回分配的第一个页框的线性地址，失败则返回 <code>0</code>。</td></tr><tr><td><code>get_zeroed_page(gfp_mask)</code></td><td>请求一个填满 <code>0</code> 的单独的页框，成功则返回分配的第一个页框的线性地址，失败则返回 <code>0</code>。</td></tr><tr><td><code>__get_dma_pages(gfp_mask, order)</code></td><td>请求 $2^{order}$ 个适用于 DMA 的页框，成功则返回分配的第一个页框的线性地址，失败则返回 <code>0</code>。</td></tr></tbody></table><p><code>include/linux/gfp.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span><span style=color:#a6e22e>alloc_pages_node</span>(<span style=color:#66d9ef>int</span> nid, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask,
                        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>if</span> (unlikely(order <span style=color:#f92672>&gt;=</span> MAX_ORDER))
        <span style=color:#66d9ef>return</span> NULL;

    <span style=color:#66d9ef>return</span> __alloc_pages(gfp_mask, order,
        NODE_DATA(nid)<span style=color:#f92672>-&gt;</span>node_zonelists <span style=color:#f92672>+</span> (gfp_mask <span style=color:#f92672>&amp;</span> GFP_ZONEMASK));
}

<span style=color:#75715e>#ifdef CONFIG_NUMA
</span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span><span style=color:#a6e22e>alloc_pages_current</span>(<span style=color:#66d9ef>unsigned</span> gfp_mask, <span style=color:#66d9ef>unsigned</span> order);

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>
<span style=color:#a6e22e>alloc_pages</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>if</span> (unlikely(order <span style=color:#f92672>&gt;=</span> MAX_ORDER))
        <span style=color:#66d9ef>return</span> NULL;

    <span style=color:#66d9ef>return</span> alloc_pages_current(gfp_mask, order);
}
<span style=color:#75715e>#else
</span><span style=color:#75715e>#define alloc_pages(gfp_mask, order) \
</span><span style=color:#75715e>        alloc_pages_node(numa_node_id(), gfp_mask, order)
</span><span style=color:#75715e>#endif
</span><span style=color:#75715e>#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>FASTCALL</span>(__get_free_pages(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order));
<span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>FASTCALL</span>(get_zeroed_page(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask));

<span style=color:#75715e>#define __get_free_page(gfp_mask) \
</span><span style=color:#75715e>        __get_free_pages((gfp_mask),0)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define __get_dma_pages(gfp_mask, order) \
</span><span style=color:#75715e>        __get_free_pages((gfp_mask) | GFP_DMA,(order))
</span></code></pre></td></tr></table></div></div><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * Common helper functions.
</span><span style=color:#75715e> */</span>
fastcall <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>__get_free_pages</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span> page;
    page <span style=color:#f92672>=</span> alloc_pages(gfp_mask, order);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>page)
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) page_address(page);
}

EXPORT_SYMBOL(__get_free_pages);

fastcall <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>get_zeroed_page</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask)
{
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span> page;

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * get_zeroed_page() returns a 32-bit address, which cannot represent
</span><span style=color:#75715e>     * a highmem page
</span><span style=color:#75715e>     */</span>
    BUG_ON(gfp_mask <span style=color:#f92672>&amp;</span> __GFP_HIGHMEM);

    page <span style=color:#f92672>=</span> alloc_pages(gfp_mask <span style=color:#f92672>|</span> __GFP_ZERO, <span style=color:#ae81ff>0</span>);
    <span style=color:#66d9ef>if</span> (page)
        <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) page_address(page);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

EXPORT_SYMBOL(get_zeroed_page);
</code></pre></td></tr></table></div></div><p><code>mm/mempolicy.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/**
</span><span style=color:#75715e> *  alloc_pages_current - Allocate pages.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> *  @gfp:
</span><span style=color:#75715e> *      %GFP_USER   user allocation,
</span><span style=color:#75715e> *          %GFP_KERNEL kernel allocation,
</span><span style=color:#75715e> *          %GFP_HIGHMEM highmem allocation,
</span><span style=color:#75715e> *          %GFP_FS     don&#39;t call back into a file system.
</span><span style=color:#75715e> *          %GFP_ATOMIC don&#39;t sleep.
</span><span style=color:#75715e> *  @order: Power of two of allocation size in pages. 0 is a single page.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> *  Allocate a page from the kernel page pool.  When not in
</span><span style=color:#75715e> *  interrupt context and apply the current process NUMA policy.
</span><span style=color:#75715e> *  Returns NULL when no page can be allocated.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span><span style=color:#a6e22e>alloc_pages_current</span>(<span style=color:#66d9ef>unsigned</span> gfp, <span style=color:#66d9ef>unsigned</span> order)
{
    <span style=color:#66d9ef>struct</span> mempolicy <span style=color:#f92672>*</span>pol <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>mempolicy;

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>pol <span style=color:#f92672>||</span> in_interrupt())
        pol <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>default_policy;
    <span style=color:#66d9ef>if</span> (pol<span style=color:#f92672>-&gt;</span>policy <span style=color:#f92672>==</span> MPOL_INTERLEAVE)
        <span style=color:#66d9ef>return</span> alloc_page_interleave(gfp, order, interleave_nodes(pol));
    <span style=color:#66d9ef>return</span> __alloc_pages(gfp, order, zonelist_policy(gfp, pol));
}
EXPORT_SYMBOL(alloc_pages_current);
</code></pre></td></tr></table></div></div><p><code>__alloc_pages()</code> 函数见 <a href=#__alloc_pages-%E5%87%BD%E6%95%B0><code>__alloc_pages()</code> 函数</a>。</p><h3 id=释放页框>释放页框<a hidden class=anchor aria-hidden=true href=#释放页框>#</a></h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>__free_pages(page, order)</code></td><td>检查 <code>page</code> 指向的页描述符，若该页框未被保留 (<code>PG_reserved</code> 标志为 <code>0</code>)，就把 <code>count</code> 减一。如果 <code>count</code> 为 <code>0</code>，就释放页框。</td></tr><tr><td><code>free_pages(addr, order)</code></td><td>接受页框的线性地址而不是页描述符，其余和 <code>__free_pages(page, order)</code> 相同</td></tr><tr><td><code>__free_page(page)</code></td><td><code>__free_pages(page, 0)</code></td></tr><tr><td><code>free_page(addr)</code></td><td><code>free_pages(addr, 0)</code></td></tr></tbody></table><p><code>include/linux/gfp.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FASTCALL</span>(__free_pages(<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order));
<span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FASTCALL</span>(free_pages(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> addr, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order));
<span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FASTCALL</span>(free_hot_page(<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page));
<span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FASTCALL</span>(free_cold_page(<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page));

<span style=color:#75715e>#define __free_page(page) __free_pages((page), 0)
</span><span style=color:#75715e>#define free_page(addr) free_pages((addr),0)
</span></code></pre></td></tr></table></div></div><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>fastcall <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free_pages</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> addr, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>if</span> (addr <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
        BUG_ON(<span style=color:#f92672>!</span>virt_addr_valid((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)addr));
        __free_pages(virt_to_page((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)addr), order);
    }
}

EXPORT_SYMBOL(free_pages);
</code></pre></td></tr></table></div></div><p><code>__free_pages()</code> 函数见<a href=#%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98>释放内存</a>。</p><p>很多函数涉及<a href=/posts/kernel/memory/buddy_system>伙伴系统</a>和 <a href=/posts/kernel/memory/per_cpu>per-CPU 页框高速缓存</a>，这里就不展开了。</p><h2 id=管理区分配器简介>管理区分配器简介<a hidden class=anchor aria-hidden=true href=#管理区分配器简介>#</a></h2><p>管理区分配器是内核页框分配器的前端。</p><p>整个连续内存分配涉及的内容大致如下：</p><p><img loading=lazy src=/images/kernel/memory/contiguous_memory.png alt=连续内存分配></p><p>管理区分配器必须分配一个包含足够多空闲页框的内存区，来满足内存请求，它得满足如下目标：</p><ul><li>保护<a href=#%E4%BF%9D%E7%95%99%E7%9A%84%E9%A1%B5%E6%A1%86%E6%B1%A0>保留的页框池</a>。</li><li>当内存不足且允许阻塞当前进程时，应当触发页框回收算法，一旦某些页框被释放，将再次尝试分配。</li><li>如果可能，应当保存小而珍贵的 <code>ZONE_DMA</code> 内存管理区。例如，如果是对 <code>ZONE_NORMAL</code> 或 <code>ZONE_HIGHMEM</code> 页框的请求，尽可能不分配 <code>ZONE_DMA</code> 内存管理区中的页框。</li></ul><h2 id=保留的页框池>保留的页框池<a hidden class=anchor aria-hidden=true href=#保留的页框池>#</a></h2><p>在请求内存时，一些内核控制路径不能被阻塞，如处理中断或执行临界区内的代码时。在这些情况下，一条控制路径应当产生原子内存分配请求 (设置 <code>GFP_ATOMIC</code> 标志)。原子请求从不被阻塞，如果没有足够空闲页，仅返回失败。</p><p>尽管无法保证原子内存分配请求不失败，但内核会设法尽量减少这种不幸事件发生的可能性。因此，内核为原子内存分配请求保留了一个页框池，只有在内存不足时才使用。</p><p>保留内存的数量（以 <code>KB</code> 为单位）存放在 <code>min_free_kbytes</code> 变量中。管理区描述符的部分字段都会在 <code>mim_free_kbytes</code> 初始化时一起完成初始化（<code>init_per_zone_pages_min()</code> 函数调用 <code>setup_per_zone_pages_min()</code> 函数和 <code>setup_per_zone_lowmem_reserve()</code> 函数，这些函数都位于 <code>mm/page_alloc.c</code>）。</p><ul><li><code>pages_min</code>：管理区中保留页的数目，被设置为 $\lfloor \sqrt{16 \times 直接映射内存的大小} \rfloor$。</li><li><code>pages_low</code>：回收页框使用的下界，被设置为 <code>pages_min</code> 的 $\frac{5}{4}$。</li><li><code>pages_high</code>：回收页框使用的上界，被设置为 <code>pages_min</code> 的 $\frac{3}{2}$。</li><li><code>lowmem_reserve</code>：每个管理区必须保留的页框数目，例子代码注释中有，见下。</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * results with 256, 32 in the lowmem_reserve sysctl:
</span><span style=color:#75715e> *  1G machine -&gt; (16M dma, 800M-16M normal, 1G-800M high)
</span><span style=color:#75715e> *  1G machine -&gt; (16M dma, 784M normal, 224M high)
</span><span style=color:#75715e> *  NORMAL allocation will leave 784M/256 of ram reserved in the ZONE_DMA
</span><span style=color:#75715e> *  HIGHMEM allocation will leave 224M/32 of ram reserved in ZONE_NORMAL
</span><span style=color:#75715e> *  HIGHMEM allocation will (224M+784M)/256 of ram reserved in ZONE_DMA
</span><span style=color:#75715e> */</span>
</code></pre></td></tr></table></div></div><h2 id=分配内存>分配内存<a hidden class=anchor aria-hidden=true href=#分配内存>#</a></h2><h3 id=zone_watermark_ok-函数><code>zone_watermark_ok()</code> 函数<a hidden class=anchor aria-hidden=true href=#zone_watermark_ok-函数>#</a></h3><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * Return 1 if free pages are above &#39;mark&#39;. This takes into account the order
</span><span style=color:#75715e> * of the allocation.
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>zone_watermark_ok</span>(<span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>z, <span style=color:#66d9ef>int</span> order, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> mark,
              <span style=color:#66d9ef>int</span> classzone_idx, <span style=color:#66d9ef>int</span> can_try_harder, <span style=color:#66d9ef>int</span> gfp_high)
{
    <span style=color:#75715e>/* free_pages my go negative - that&#39;s OK */</span>
    <span style=color:#66d9ef>long</span> min <span style=color:#f92672>=</span> mark, free_pages <span style=color:#f92672>=</span> z<span style=color:#f92672>-&gt;</span>free_pages <span style=color:#f92672>-</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> order) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>int</span> o;

    <span style=color:#66d9ef>if</span> (gfp_high)
        min <span style=color:#f92672>-=</span> min <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>if</span> (can_try_harder)
        min <span style=color:#f92672>-=</span> min <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;

    <span style=color:#66d9ef>if</span> (free_pages <span style=color:#f92672>&lt;=</span> min <span style=color:#f92672>+</span> z<span style=color:#f92672>-&gt;</span>lowmem_reserve[classzone_idx])
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (o <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; o <span style=color:#f92672>&lt;</span> order; o<span style=color:#f92672>++</span>) {
        <span style=color:#75715e>/* At the next order, this order&#39;s pages become unavailable */</span>
        free_pages <span style=color:#f92672>-=</span> z<span style=color:#f92672>-&gt;</span>free_area[o].nr_free <span style=color:#f92672>&lt;&lt;</span> o;

        <span style=color:#75715e>/* Require fewer higher order pages to be free */</span>
        min <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;

        <span style=color:#66d9ef>if</span> (free_pages <span style=color:#f92672>&lt;=</span> min)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></td></tr></table></div></div><p><code>zone_watermark_ok()</code> 是一个辅助函数，在满足如下两个条件时返回 <code>1</code>：</p><ul><li>除了被分配的页框外，内存管理区中至少还有 <code>min</code> 个空闲页框（不包括保留的页框）。</li><li>除了被分配的页框外，在 <code>order</code> 至少为 <code>o</code> 的块中，有大于等于 <code>min</code> / $2^{o}$ 个空闲页框。</li></ul><p>阈值 <code>min</code> 的值由 <code>mask</code>. <code>can_try_harder</code> 和 <code>gfp_high</code> 确定：</p><ul><li><code>mask</code> 可能是 <code>pages_min</code>. <code>pages_low</code> 和 <code>pages_high</code> 中的一个。</li><li>若 <code>gfp_high</code> 被置位，把么把 <code>mask</code> 除以 <code>2</code>。 这种情况通常发生在 <code>__GFP_WAIT</code> 标志被置位时，即能从高端内存分配页框。</li><li>若 <code>can_try_harder</code>被置位，那么把 <code>mask</code> 再除以 <code>4</code>。 这种情况通常发生在 <code>__GFP_WAIT</code> 标志被置位时，或者当前进程是一个位于进程上下文中（不在中断处理程序和可延迟函数中）且已经完成内存分配的实时进程。</li></ul><h3 id=__alloc_pages-函数><code>__alloc_pages()</code> 函数<a hidden class=anchor aria-hidden=true href=#__alloc_pages-函数>#</a></h3><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * This is the &#39;heart&#39; of the zoned buddy allocator.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span> fastcall
<span style=color:#a6e22e>__alloc_pages</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> gfp_mask, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order,
        <span style=color:#66d9ef>struct</span> zonelist <span style=color:#f92672>*</span>zonelist)
{
    ... <span style=color:#75715e>// 详细流程见下
</span><span style=color:#75715e></span>}

EXPORT_SYMBOL(__alloc_pages);
</code></pre></td></tr></table></div></div><p>该函数的详细流程是：</p><ol><li><p>准备工作。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> wait <span style=color:#f92672>=</span> gfp_mask <span style=color:#f92672>&amp;</span> __GFP_WAIT;
    <span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>**</span>zones, <span style=color:#f92672>*</span>z;
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page;
    <span style=color:#66d9ef>struct</span> reclaim_state reclaim_state;
    <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> current;
    <span style=color:#66d9ef>int</span> i;
    <span style=color:#66d9ef>int</span> classzone_idx;
    <span style=color:#66d9ef>int</span> do_retry;
    <span style=color:#66d9ef>int</span> can_try_harder;
    <span style=color:#66d9ef>int</span> did_some_progress;

    might_sleep_if(wait);

    <span style=color:#75715e>/*
</span><span style=color:#75715e>    * The caller may dip into page reserves a bit more if the caller
</span><span style=color:#75715e>    * cannot run direct reclaim, or is the caller has realtime scheduling
</span><span style=color:#75715e>    * policy
</span><span style=color:#75715e>    */</span>
    can_try_harder <span style=color:#f92672>=</span> (unlikely(rt_task(p)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>in_interrupt()) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>wait;

    zones <span style=color:#f92672>=</span> zonelist<span style=color:#f92672>-&gt;</span>zones;  <span style=color:#75715e>/* the list of zones suitable for gfp_mask */</span>

    <span style=color:#66d9ef>if</span> (unlikely(zones[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> NULL)) {
        <span style=color:#75715e>/* Should this ever happen?? */</span>
        <span style=color:#66d9ef>return</span> NULL;
    }

    classzone_idx <span style=color:#f92672>=</span> zone_idx(zones[<span style=color:#ae81ff>0</span>]);
</code></pre></td></tr></table></div></div></li><li><p>第一次遍历存放管理区的数组（<code>zonelist</code>），寻找有足够空闲内存的管理区。若能满足请求，跳转到第 15 步。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>restart:
    <span style=color:#75715e>/* Go through the zonelist once, looking for a zone with enough free */</span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (z <span style=color:#f92672>=</span> zones[i]) <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>) {

        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>zone_watermark_ok(z, order, z<span style=color:#f92672>-&gt;</span>pages_low,
                        classzone_idx, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))
            <span style=color:#66d9ef>continue</span>;

        page <span style=color:#f92672>=</span> buffered_rmqueue(z, order, gfp_mask);
        <span style=color:#66d9ef>if</span> (page)
            <span style=color:#66d9ef>goto</span> got_pg;
    }
</code></pre></td></tr></table></div></div></li><li><p>来到这里，说明没足够的空闲内存。触发页框回收算法，这部分内容属于《深入理解 Linux 内核》中“回收页框”章节，这里不展开。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (z <span style=color:#f92672>=</span> zones[i]) <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>)
        wakeup_kswapd(z, order);
</code></pre></td></tr></table></div></div></li><li><p>第二次遍历存放管理区的数组，但使用了较低的阈值（注意传递给 <code>zone_watermark_ok()</code> 的参数不同）。若能满足请求，跳转到第 15 步。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#75715e>/*
</span><span style=color:#75715e>    * Go through the zonelist again. Let __GFP_HIGH and allocations
</span><span style=color:#75715e>    * coming from realtime tasks to go deeper into reserves
</span><span style=color:#75715e>    */</span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (z <span style=color:#f92672>=</span> zones[i]) <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>zone_watermark_ok(z, order, z<span style=color:#f92672>-&gt;</span>pages_min,
                        classzone_idx, can_try_harder,
                        gfp_mask <span style=color:#f92672>&amp;</span> __GFP_HIGH))
            <span style=color:#66d9ef>continue</span>;

        page <span style=color:#f92672>=</span> buffered_rmqueue(z, order, gfp_mask);
        <span style=color:#66d9ef>if</span> (page)
            <span style=color:#66d9ef>goto</span> got_pg;
    }
</code></pre></td></tr></table></div></div></li><li><p>来到这里，说明系统没足够内存。如果内存分配请求的内核路径不是一个中断处理程序或一个可延迟函数，并且试图回收页框（<code>PF_MEMALLOC</code> 或 <code>TIF_MEMDIE</code> 标志被置位），那么进行第三次遍历，这次忽略阈值（不调用 <code>zone_watermark_ok()</code>）。这种情况下，允许内核控制路径耗用为内存不足预留的页（保留的页框池）。其实，<code>PF_MEMALLOC</code> 表示该进程当前正在执行“内存规整（memory compaction）”或“直接回收（direct reclaim）”，而 <code>TIF_MEMDIE</code> 则表示该进程已经触发了内存不足清理（out-of-memory killer）并且正在尝试退出，以上这些操作都可能导致更多的内存页框被释放，因此只要有可能，请求就被满足。若能满足请求，跳转到第 15 步；反之，跳转到第 14 步。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#75715e>/* This allocation should allow future memory freeing. */</span>
    <span style=color:#66d9ef>if</span> (((p<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> PF_MEMALLOC) <span style=color:#f92672>||</span> unlikely(test_thread_flag(TIF_MEMDIE))) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>in_interrupt()) {
        <span style=color:#75715e>/* go through the zonelist yet again, ignoring mins */</span>
        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (z <span style=color:#f92672>=</span> zones[i]) <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>) {
            page <span style=color:#f92672>=</span> buffered_rmqueue(z, order, gfp_mask);
            <span style=color:#66d9ef>if</span> (page)
                <span style=color:#66d9ef>goto</span> got_pg;
        }
        <span style=color:#66d9ef>goto</span> nopage;
    }
</code></pre></td></tr></table></div></div></li><li><p>来到这里，必须阻塞当前进程才能满足请求（<code>__GFP_WAIT</code> 需要被置位）。否则，跳转到第 14 步。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#75715e>/* Atomic allocations - we can&#39;t balance anything */</span>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>wait)
        <span style=color:#66d9ef>goto</span> nopage;
</code></pre></td></tr></table></div></div></li><li><p>来到这里，说明进程能够被阻塞，调用 <code>cond_resched()</code> 检查是否有其它进程需要 CPU。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>rebalance:
    cond_resched();
</code></pre></td></tr></table></div></div></li><li><p>设置 <code>PF_MEMALLOC</code> 标志，表示进程已经准备好执行内存回收。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#75715e>/* We now go into synchronous reclaim */</span>
    p<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>|=</span> PF_MEMALLOC;
</code></pre></td></tr></table></div></div></li><li><p>将 <code>reclaim_state</code> 存入 <code>current->reclaim_state</code>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    reclaim_state.reclaimed_slab <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    p<span style=color:#f92672>-&gt;</span>reclaim_state <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>reclaim_state;
</code></pre></td></tr></table></div></div></li><li><p>调用 <code>try_to_free_pages()</code> 来回收页框，这部分内容属于《深入理解 Linux 内核》中“回收页框”章节，这里不展开。该函数可能阻塞当前进程，一旦函数返回，重设 <code>PF_MEMALLOC</code> 标志并再次调用 <code>cond_resched()</code>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    did_some_progress <span style=color:#f92672>=</span> try_to_free_pages(zones, gfp_mask, order);

    p<span style=color:#f92672>-&gt;</span>reclaim_state <span style=color:#f92672>=</span> NULL;
    p<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>PF_MEMALLOC;

    cond_resched();
</code></pre></td></tr></table></div></div></li><li><p>如果已经释放了一些页框，那么按第 4 步的方式再次遍历存放内存管理区的数组。若能满足请求，跳转到第 15 步。如果分配请求不能被满足，<code>__GFP_NORETRY</code>（分配失败时不重复分配）被清除且 <code>__GFP_FS</code>（可以启动文件系统 I/O）被置位，那么再次遍历存放内存管理区的数组（注意传递给 <code>zone_watermark_ok()</code> 的参数不同）。若能满足请求，跳转到第 15 步；反之，说明内存耗尽，通过调用 <code>out_of_memory()</code>（该函数位于 <code>mm/oom_kill.c</code>）杀死一个进程，来保证系统不崩溃，然后转到第 2 步。这次遍历的阈值比之前的要高，因此很容易失败，只有在另一个内核控制路径已经通过杀死了一个进程来回收了它的内存的时候，才会成功，但这种情况下，确实避免了两个无辜的进程（而不是一个）被杀死。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>if</span> (likely(did_some_progress)) {
        <span style=color:#75715e>/*
</span><span style=color:#75715e>        * Go through the zonelist yet one more time, keep
</span><span style=color:#75715e>        * very high watermark here, this is only to catch
</span><span style=color:#75715e>        * a parallel oom killing, we must fail if we&#39;re still
</span><span style=color:#75715e>        * under heavy pressure.
</span><span style=color:#75715e>        */</span>
        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (z <span style=color:#f92672>=</span> zones[i]) <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>zone_watermark_ok(z, order, z<span style=color:#f92672>-&gt;</span>pages_min,
                            classzone_idx, can_try_harder,
                            gfp_mask <span style=color:#f92672>&amp;</span> __GFP_HIGH))
                <span style=color:#66d9ef>continue</span>;

            page <span style=color:#f92672>=</span> buffered_rmqueue(z, order, gfp_mask);
            <span style=color:#66d9ef>if</span> (page)
                <span style=color:#66d9ef>goto</span> got_pg;
        }
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((gfp_mask <span style=color:#f92672>&amp;</span> __GFP_FS) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(gfp_mask <span style=color:#f92672>&amp;</span> __GFP_NORETRY)) {
        <span style=color:#75715e>/*
</span><span style=color:#75715e>        * Go through the zonelist yet one more time, keep
</span><span style=color:#75715e>        * very high watermark here, this is only to catch
</span><span style=color:#75715e>        * a parallel oom killing, we must fail if we&#39;re still
</span><span style=color:#75715e>        * under heavy pressure.
</span><span style=color:#75715e>        */</span>
        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (z <span style=color:#f92672>=</span> zones[i]) <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>zone_watermark_ok(z, order, z<span style=color:#f92672>-&gt;</span>pages_high,
                            classzone_idx, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))
                <span style=color:#66d9ef>continue</span>;

            page <span style=color:#f92672>=</span> buffered_rmqueue(z, order, gfp_mask);
            <span style=color:#66d9ef>if</span> (page)
                <span style=color:#66d9ef>goto</span> got_pg;
        }

        out_of_memory(gfp_mask);
        <span style=color:#66d9ef>goto</span> restart;
    }
</code></pre></td></tr></table></div></div></li><li><p>如果 <code>order &lt;= 3</code>（和具体实现有关）或者 <code>__GFP_REPEAT</code> 被置位，设置 <code>do_retry</code>。如果 <code>__GFP_NOFAIL</code> 被置位，设置 <code>do_retry</code>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#75715e>/*
</span><span style=color:#75715e>    * Don&#39;t let big-order allocations loop unless the caller explicitly
</span><span style=color:#75715e>    * requests that.  Wait for some write requests to complete then retry.
</span><span style=color:#75715e>    *
</span><span style=color:#75715e>    * In this implementation, __GFP_REPEAT means __GFP_NOFAIL for order
</span><span style=color:#75715e>    * &lt;= 3, but that may not be true in other implementations.
</span><span style=color:#75715e>    */</span>
    do_retry <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(gfp_mask <span style=color:#f92672>&amp;</span> __GFP_NORETRY)) {
        <span style=color:#66d9ef>if</span> ((order <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>||</span> (gfp_mask <span style=color:#f92672>&amp;</span> __GFP_REPEAT))
            do_retry <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>if</span> (gfp_mask <span style=color:#f92672>&amp;</span> __GFP_NOFAIL)
            do_retry <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    }
</code></pre></td></tr></table></div></div></li><li><p>如果 <code>do_retry</code> 被设置，调用 <code>blk_congestion_wait()</code> 使进程休眠一会（见 <a href=/posts/kernel/todo>TODO</a>），并跳转到第 7 步。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>if</span> (do_retry) {
        blk_congestion_wait(WRITE, HZ<span style=color:#f92672>/</span><span style=color:#ae81ff>50</span>);
        <span style=color:#66d9ef>goto</span> rebalance;
    }
</code></pre></td></tr></table></div></div></li><li><p>来到这里，说明请求不能被满足，返回 <code>NULL</code>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>nopage:
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(gfp_mask <span style=color:#f92672>&amp;</span> __GFP_NOWARN) <span style=color:#f92672>&amp;&amp;</span> printk_ratelimit()) {
        printk(KERN_WARNING <span style=color:#e6db74>&#34;%s: page allocation failure.&#34;</span>
            <span style=color:#e6db74>&#34; order:%d, mode:0x%x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            p<span style=color:#f92672>-&gt;</span>comm, order, gfp_mask);
        dump_stack();
    }
    <span style=color:#66d9ef>return</span> NULL;
</code></pre></td></tr></table></div></div></li><li><p>来到这里，说明请求能被满足，调用 <code>zone_statistics()</code> 完成一些数据统计工作 (主要针对 NUMA)，然后返回第一个被分配的页框的页描述符。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>got_pg:
    zone_statistics(zonelist, z);
    <span style=color:#66d9ef>return</span> page;
</code></pre></td></tr></table></div></div></li></ol><h2 id=释放内存>释放内存<a hidden class=anchor aria-hidden=true href=#释放内存>#</a></h2><p><code>__free_pages()</code> 函数比较简单，直接贴代码。</p><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__free_pages_ok</span>(<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    LIST_HEAD(list);
    <span style=color:#66d9ef>int</span> i;

    arch_free_page(page, order);

    mod_page_state(pgfree, <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> order);

<span style=color:#75715e>#ifndef CONFIG_MMU
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (order <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> order) ; <span style=color:#f92672>++</span>i)
            __put_page(page <span style=color:#f92672>+</span> i);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> ; i <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> order) ; <span style=color:#f92672>++</span>i)
        free_pages_check(__FUNCTION__, page <span style=color:#f92672>+</span> i);
    list_add(<span style=color:#f92672>&amp;</span>page<span style=color:#f92672>-&gt;</span>lru, <span style=color:#f92672>&amp;</span>list);
    kernel_map_pages(page, <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span>order, <span style=color:#ae81ff>0</span>);
    free_pages_bulk(page_zone(page), <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>list, order);
}

fastcall <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__free_pages</span>(<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>PageReserved(page) <span style=color:#f92672>&amp;&amp;</span> put_page_testzero(page)) {
        <span style=color:#66d9ef>if</span> (order <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            free_hot_page(page);
        <span style=color:#66d9ef>else</span>
            __free_pages_ok(page, order);
    }
}

EXPORT_SYMBOL(__free_pages);
</code></pre></td></tr></table></div></div><p><code>include/linux/mm.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * Drop a ref, return true if the logical refcount fell to zero (the page has
</span><span style=color:#75715e> * no users)
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>#define put_page_testzero(p)                \
</span><span style=color:#75715e>    ({                      \
</span><span style=color:#75715e>        BUG_ON(page_count(p) == 0);     \
</span><span style=color:#75715e>        atomic_add_negative(-1, &amp;(p)-&gt;_count);  \
</span><span style=color:#75715e>    })
</span></code></pre></td></tr></table></div></div><p>很多函数涉及<a href=/posts/kernel/memory/buddy_system>伙伴系统</a>和 <a href=/posts/kernel/memory/per_cpu>per-CPU 页框高速缓存</a>，这里就不展开了。</p><h2 id=内存池>内存池<a hidden class=anchor aria-hidden=true href=#内存池>#</a></h2><p>内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。</p><p>注意内存池与保留的页框池（见<a href=#%E4%BF%9D%E7%95%99%E7%9A%84%E9%A1%B5%E6%A1%86%E6%B1%A0>保留的页框池</a>）的区别。保留的页框池是用于满足中断处理程序或内部临界区发出的原子分配请求的；而内存池是动态内存的储备，只能被特定的内核成分（池的拥有者）使用。</p><p>拥有者通常不使用内存池的储备（而是从普通内存中分配），如果动态内存变得极其稀有以至于所有普通内存分配请求都失败的话，那么内核成分就能调用特地的内存池函数提取储备得到所需的内存。当然，这已经是最后的解决手段了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/linux-%E5%86%85%E6%A0%B8/>Linux 内核</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>内存管理</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E8%BF%9E%E7%BB%AD%E9%A1%B5%E6%A1%86%E7%9A%84%E7%AE%A1%E7%90%86/>连续页框的管理</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/kernel/memory/supplement/><span class=title>«</span><br><span>内存管理补充</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/kernel/memory/slab/><span class=title>»</span><br><span>slab 分配器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>