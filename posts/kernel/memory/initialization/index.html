<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>内存管理初始化 | FreeFlyingSheep 的小站</title><meta name=keywords content="Linux 内核,内存管理,内存管理初始化"><meta name=description content="Linux 内核学习笔记系列，内存管理部分，简单介绍内存管理初始化。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/kernel/memory/initialization/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="内存管理初始化"><meta property="og:description" content="Linux 内核学习笔记系列，内存管理部分，简单介绍内存管理初始化。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/kernel/memory/initialization/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-26T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="内存管理初始化"><meta name=twitter:description content="Linux 内核学习笔记系列，内存管理部分，简单介绍内存管理初始化。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"内存管理初始化","item":"https://freeflyingsheep.github.io/posts/kernel/memory/initialization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"内存管理初始化","name":"内存管理初始化","description":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存管理初始化。\n","keywords":["Linux 内核","内存管理","内存管理初始化"],"articleBody":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存管理初始化。\n内存管理初始化简介 体系结构相关的部分只考虑 x86-32 架构。\n初始化相关的操作总是从 start_kernel() 开始看起，与内存管理初始化相关的流程如下（图片来源于 PLKA）：\nstart_kernel()\" / start_kernel() 函数位于 init/main.c。\nsetup_arch() setup_arch() 的流程如下（图片来源于 PLKA）：\nsetup_arch()\" / setup_arch() 函数位于 arch/x86/kernel/setup.c。\n这部分内容在内核中经常被重构，导致不同内核版本间差异较大。事实上，我所查看的源码版本虽然与 PLKA 指示的内核版本很接近，但图中的很多函数已经重构了。\nmachine_specific_memory_setup() 直接搜索找不到 machine_specific_memory_setup() 函数，该函数应该已经被重构，推测功能接近的函数为 setup_memory_map()。\nx86-32 架构使用 BIOS 的 e820 功能来探测物理内存。\n在 arch/x86/kernel/e820.c 中，定义了 char *__init default_machine_specific_memory_setup(void) 函数，这个函数在 arch/x86/kernel/x86_init.c 中被赋值给了 resources.memory_setup：\n1 2 3 4 5 6 7 8 9 10 11 12  /* * The platform setup functions are preset with the default functions * for standard PC hardware. */ struct x86_init_ops x86_init __initdata = { .resources = { .probe_roms = x86_init_noop, .reserve_resources = reserve_standard_io_resources, .memory_setup = default_machine_specific_memory_setup, }, ...   之后在 setup_memory_map() 函数中被调用，而 setup_memory_map() 函数在 setup_arch() 中被调用。\narch/x86/kernel/e820.c：\n1 2 3 4 5 6 7 8 9  void __init setup_memory_map(void) { char *who; who = x86_init.resources.memory_setup(); memcpy(\u0026e820_saved, \u0026e820, sizeof(struct e820map)); printk(KERN_INFO \"BIOS-provided physical RAM map:\\n\"); e820_print_map(who); }   parse_early_param() 内核的命令行参数可能有与内存管理相关的选项，因此把 parse_early_param() 也视为内存管理初始化的一部分。\nparse_early_param() 函数首先在 setup_arch() 函数中调用，虽然之后 start_kernel() 也会调用它。该函数的定义位于 init/main.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* Arch code calls this early on, or if not, just before other parsing. */ void __init parse_early_param(void) { static __initdata int done = 0; static __initdata char tmp_cmdline[COMMAND_LINE_SIZE]; if (done) return; /* All fall through to do_early_param. */ strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE); parse_early_options(tmp_cmdline); done = 1; }   该函数调用 init/main.c 中的 parse_early_options()，通过 parse_args() 函数处理（parse_args() 细节不展开了）：\n1 2 3 4  void __init parse_early_options(char *cmdline) { parse_args(\"early options\", cmdline, NULL, 0, do_early_param); }   setup_memory() 该函数在当前版本内核源码里已经找不到了，推测改名为了 initmem_init() 和 ，UMA 和 NUMA 版本分别放置于 arch/x86/mm/init_32.c 和 arch/x86/mm/numa_32.c。\narch/x86/mm/init_32.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #ifndef CONFIG_NEED_MULTIPLE_NODES void __init initmem_init(unsigned long start_pfn, unsigned long end_pfn, int acpi, int k8) { #ifdef CONFIG_HIGHMEM  highstart_pfn = highend_pfn = max_pfn; if (max_pfn  max_low_pfn) highstart_pfn = max_low_pfn; e820_register_active_regions(0, 0, highend_pfn); sparse_memory_present_with_active_regions(0); printk(KERN_NOTICE \"%ldMB HIGHMEM available.\\n\", pages_to_mb(highend_pfn - highstart_pfn)); num_physpages = highend_pfn; high_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1; #else  e820_register_active_regions(0, 0, max_low_pfn); sparse_memory_present_with_active_regions(0); num_physpages = max_low_pfn; high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1; #endif #ifdef CONFIG_FLATMEM  max_mapnr = num_physpages; #endif  __vmalloc_start_set = true; printk(KERN_NOTICE \"%ldMB LOWMEM available.\\n\", pages_to_mb(max_low_pfn)); setup_bootmem_allocator(); } #endif /* !CONFIG_NEED_MULTIPLE_NODES */  arch/x86/mm/numa_32.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  void __init initmem_init(unsigned long start_pfn, unsigned long end_pfn, int acpi, int k8) { int nid; long kva_target_pfn; /* * When mapping a NUMA machine we allocate the node_mem_map arrays * from node local memory. They are then mapped directly into KVA * between zone normal and vmalloc space. Calculate the size of * this space and use it to adjust the boundary between ZONE_NORMAL * and ZONE_HIGHMEM. */ get_memcfg_numa(); kva_pages = roundup(calculate_numa_remap_pages(), PTRS_PER_PTE); kva_target_pfn = round_down(max_low_pfn - kva_pages, PTRS_PER_PTE); do { kva_start_pfn = find_e820_area(kva_target_pfnPAGE_SHIFT, max_low_pfnPAGE_SHIFT, kva_pagesPAGE_SHIFT, PTRS_PER_PTEPAGE_SHIFT)  PAGE_SHIFT; kva_target_pfn -= PTRS_PER_PTE; } while (kva_start_pfn == -1UL \u0026\u0026 kva_target_pfn  min_low_pfn); if (kva_start_pfn == -1UL) panic(\"Can not get kva space\\n\"); printk(KERN_INFO \"kva_start_pfn ~ %lx max_low_pfn ~ %lx\\n\", kva_start_pfn, max_low_pfn); printk(KERN_INFO \"max_pfn = %lx\\n\", max_pfn); /* avoid clash with initrd */ reserve_early(kva_start_pfnPAGE_SHIFT, (kva_start_pfn + kva_pages)PAGE_SHIFT, \"KVA PG\"); #ifdef CONFIG_HIGHMEM  highstart_pfn = highend_pfn = max_pfn; if (max_pfn  max_low_pfn) highstart_pfn = max_low_pfn; printk(KERN_NOTICE \"%ldMB HIGHMEM available.\\n\", pages_to_mb(highend_pfn - highstart_pfn)); num_physpages = highend_pfn; high_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1; #else  num_physpages = max_low_pfn; high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1; #endif  printk(KERN_NOTICE \"%ldMB LOWMEM available.\\n\", pages_to_mb(max_low_pfn)); printk(KERN_DEBUG \"max_low_pfn = %lx, highstart_pfn = %lx\\n\", max_low_pfn, highstart_pfn); printk(KERN_DEBUG \"Low memory ends at vaddr %08lx\\n\", (ulong) pfn_to_kaddr(max_low_pfn)); for_each_online_node(nid) { init_remap_allocator(nid); allocate_pgdat(nid); } remap_numa_kva(); printk(KERN_DEBUG \"High memory starts at vaddr %08lx\\n\", (ulong) pfn_to_kaddr(highstart_pfn)); for_each_online_node(nid) propagate_e820_map_node(nid); for_each_online_node(nid) { memset(NODE_DATA(nid), 0, sizeof(struct pglist_data)); NODE_DATA(nid)-node_id = nid; #ifndef CONFIG_NO_BOOTMEM  NODE_DATA(nid)-bdata = \u0026bootmem_node_data[nid]; #endif  } setup_bootmem_allocator(); }   该函数主要用于确定物理页的数目，然后初始化 bootmem 分配器，bootmem 分配器的具体细节见 bootmem 分配器。\npaging_init() paging_init() 函数位于 arch/x86/mm/init_32.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /* * paging_init() sets up the page tables - note that the first 8MB are * already mapped by head.S. * * This routines also unmaps the page at virtual kernel address 0, so * that we can trap those pesky NULL-reference errors in the kernel. */ void __init paging_init(void) { pagetable_init(); __flush_tlb_all(); kmap_init(); /* * NOTE: at this point the bootmem allocator is fully available. */ sparse_init(); zone_sizes_init(); }   该函数会调用 pagetable_init 来确保直接映射的地址空间的物理内存被初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #ifdef CONFIG_HIGHMEM static void __init permanent_kmaps_init(pgd_t *pgd_base) { unsigned long vaddr; pgd_t *pgd; pud_t *pud; pmd_t *pmd; pte_t *pte; vaddr = PKMAP_BASE; page_table_range_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base); pgd = swapper_pg_dir + pgd_index(vaddr); pud = pud_offset(pgd, vaddr); pmd = pmd_offset(pud, vaddr); pte = pte_offset_kernel(pmd, vaddr); pkmap_page_table = pte; } #else static inline void permanent_kmaps_init(pgd_t *pgd_base) { } #endif /* CONFIG_HIGHMEM */ static void __init pagetable_init(void) { pgd_t *pgd_base = swapper_pg_dir; permanent_kmaps_init(pgd_base); }   这部分的细节太多，我不打算深入看了。\nzone_sizes_init() 可以看到，在当前版本，该函数的调用者变成了 paging_init() 函数，而非 setup_arch() 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13  static void __init zone_sizes_init(void) { unsigned long max_zone_pfns[MAX_NR_ZONES]; memset(max_zone_pfns, 0, sizeof(max_zone_pfns)); max_zone_pfns[ZONE_DMA] = virt_to_phys((char *)MAX_DMA_ADDRESS)  PAGE_SHIFT; max_zone_pfns[ZONE_NORMAL] = max_low_pfn; #ifdef CONFIG_HIGHMEM  max_zone_pfns[ZONE_HIGHMEM] = highend_pfn; #endif  free_area_init_nodes(max_zone_pfns); }   add_active_range() 对可用的物理内存建立一个相对简单的列表。但该函数已经不在 zone_sizes_init() 中被调用了，搜索后发现该函数在 initmem_init() 中已经被调用了，函数调用链是 initmem_init() - e820_register_active_regions() - add_active_range()。\nfree_area_init_nodes() 它使用之前建立的列表来建立完备的内核数据结构。该函数是体系结构无关的，定义于 mm/page_alloc.c，这里不展开。\nsetup_per_cpu_areas() setup_per_cpu_areas() 函数位于 arch/x86/kernel/setup_percpu.c，用于初始化 per-CPU 高速缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  void __init setup_per_cpu_areas(void) { unsigned int cpu; unsigned long delta; int rc; pr_info(\"NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d\\n\", NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids); /* * Allocate percpu area. Embedding allocator is our favorite; * however, on NUMA configurations, it can result in very * sparse unit mapping and vmalloc area isn't spacious enough * on 32bit. Use page in that case. */ #ifdef CONFIG_X86_32  if (pcpu_chosen_fc == PCPU_FC_AUTO \u0026\u0026 pcpu_need_numa()) pcpu_chosen_fc = PCPU_FC_PAGE; #endif  rc = -EINVAL; if (pcpu_chosen_fc != PCPU_FC_PAGE) { const size_t atom_size = cpu_has_pse ? PMD_SIZE : PAGE_SIZE; const size_t dyn_size = PERCPU_MODULE_RESERVE + PERCPU_DYNAMIC_RESERVE - PERCPU_FIRST_CHUNK_RESERVE; rc = pcpu_embed_first_chunk(PERCPU_FIRST_CHUNK_RESERVE, dyn_size, atom_size, pcpu_cpu_distance, pcpu_fc_alloc, pcpu_fc_free); if (rc  0) pr_warning(\"%s allocator failed (%d), falling back to page size\\n\", pcpu_fc_names[pcpu_chosen_fc], rc); } if (rc  0) rc = pcpu_page_first_chunk(PERCPU_FIRST_CHUNK_RESERVE, pcpu_fc_alloc, pcpu_fc_free, pcpup_populate_pte); if (rc  0) panic(\"cannot initialize percpu area (err=%d)\", rc); /* alrighty, percpu areas up and running */ delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start; for_each_possible_cpu(cpu) { per_cpu_offset(cpu) = delta + pcpu_unit_offsets[cpu]; per_cpu(this_cpu_off, cpu) = per_cpu_offset(cpu); per_cpu(cpu_number, cpu) = cpu; setup_percpu_segment(cpu); setup_stack_canary_segment(cpu); /* * Copy data used in early init routines from the * initial arrays to the per cpu data areas. These * arrays then become expendable and the *_early_ptr's * are zeroed indicating that the static arrays are * gone. */ #ifdef CONFIG_X86_LOCAL_APIC  per_cpu(x86_cpu_to_apicid, cpu) = early_per_cpu_map(x86_cpu_to_apicid, cpu); per_cpu(x86_bios_cpu_apicid, cpu) = early_per_cpu_map(x86_bios_cpu_apicid, cpu); #endif #ifdef CONFIG_X86_64  per_cpu(irq_stack_ptr, cpu) = per_cpu(irq_stack_union.irq_stack, cpu) + IRQ_STACK_SIZE - 64; #ifdef CONFIG_NUMA  per_cpu(x86_cpu_to_node_map, cpu) = early_per_cpu_map(x86_cpu_to_node_map, cpu); #endif #endif  /* * Up to this point, the boot CPU has been using .data.init * area. Reload any changed state for the boot CPU. */ if (cpu == boot_cpu_id) switch_to_new_gdt(cpu); } /* indicate the early static arrays will soon be gone */ #ifdef CONFIG_X86_LOCAL_APIC  early_per_cpu_ptr(x86_cpu_to_apicid) = NULL; early_per_cpu_ptr(x86_bios_cpu_apicid) = NULL; #endif #if defined(CONFIG_X86_64) \u0026\u0026 defined(CONFIG_NUMA)  early_per_cpu_ptr(x86_cpu_to_node_map) = NULL; #endif  #if defined(CONFIG_X86_64) \u0026\u0026 defined(CONFIG_NUMA)  /* * make sure boot cpu node_number is right, when boot cpu is on the * node that doesn't have mem installed */ per_cpu(node_number, boot_cpu_id) = cpu_to_node(boot_cpu_id); #endif  /* Setup node to cpumask map */ setup_node_to_cpumask_map(); /* Setup cpu initialized, callin, callout masks */ setup_cpu_local_masks(); }   build_all_zonelists() build_all_zonelists() 函数位于 mm/page_alloc.c，用于初始化结点和内存区域。\n该函数和其调用的相关函数定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131  static void build_zonelists(pg_data_t *pgdat) { int j, node, load; enum zone_type i; nodemask_t used_mask; int local_node, prev_node; struct zonelist *zonelist; int order = current_zonelist_order; /* initialize zonelists */ for (i = 0; i  MAX_ZONELISTS; i++) { zonelist = pgdat-node_zonelists + i; zonelist-_zonerefs[0].zone = NULL; zonelist-_zonerefs[0].zone_idx = 0; } /* NUMA-aware ordering of nodes */ local_node = pgdat-node_id; load = nr_online_nodes; prev_node = local_node; nodes_clear(used_mask); memset(node_order, 0, sizeof(node_order)); j = 0; while ((node = find_next_best_node(local_node, \u0026used_mask)) = 0) { int distance = node_distance(local_node, node); /* * If another node is sufficiently far away then it is better * to reclaim pages in a zone before going off node. */ if (distance  RECLAIM_DISTANCE) zone_reclaim_mode = 1; /* * We don't want to pressure a particular node. * So adding penalty to the first node in same * distance group to make it round-robin. */ if (distance != node_distance(local_node, prev_node)) node_load[node] = load; prev_node = node; load--; if (order == ZONELIST_ORDER_NODE) build_zonelists_in_node_order(pgdat, node); else node_order[j++] = node; /* remember order */ } if (order == ZONELIST_ORDER_ZONE) { /* calculate node order -- i.e., DMA last! */ build_zonelists_in_zone_order(pgdat, j); } build_thisnode_zonelists(pgdat); } /* return values int ....just for stop_machine() */ static int __build_all_zonelists(void *dummy) { int nid; int cpu; #ifdef CONFIG_NUMA  memset(node_load, 0, sizeof(node_load)); #endif  for_each_online_node(nid) { pg_data_t *pgdat = NODE_DATA(nid); build_zonelists(pgdat); build_zonelist_cache(pgdat); } /* * Initialize the boot_pagesets that are going to be used * for bootstrapping processors. The real pagesets for * each zone will be allocated later when the per cpu * allocator is available. * * boot_pagesets are used also for bootstrapping offline * cpus if the system is already booted because the pagesets * are needed to initialize allocators on a specific cpu too. * F.e. the percpu allocator needs the page allocator which * needs the percpu allocator in order to allocate its pagesets * (a chicken-egg dilemma). */ for_each_possible_cpu(cpu) setup_pageset(\u0026per_cpu(boot_pageset, cpu), 0); return 0; } void build_all_zonelists(void) { set_zonelist_order(); if (system_state == SYSTEM_BOOTING) { __build_all_zonelists(NULL); mminit_verify_zonelist(); cpuset_init_current_mems_allowed(); } else { /* we have to stop all cpus to guarantee there is no user of zonelist */ stop_machine(__build_all_zonelists, NULL, NULL); /* cpuset refresh routine should be here */ } vm_total_pages = nr_free_pagecache_pages(); /* * Disable grouping by mobility if the number of pages in the * system is too low to allow the mechanism to work. It would be * more accurate, but expensive to check per-zone. This check is * made on memory-hotadd so a system can start with mobility * disabled and enable it later */ if (vm_total_pages  (pageblock_nr_pages * MIGRATE_TYPES)) page_group_by_mobility_disabled = 1; else page_group_by_mobility_disabled = 0; printk(\"Built %i zonelists in %s order, mobility grouping %s. \" \"Total pages: %ld\\n\", nr_online_nodes, zonelist_order_name[current_zonelist_order], page_group_by_mobility_disabled ? \"off\" : \"on\", vm_total_pages); #ifdef CONFIG_NUMA  printk(\"Policy zone: %s\\n\", zone_names[policy_zone]); #endif }   mm_init() mm_init() 函数位于 init/main.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /* * Set up kernel memory allocators */ static void __init mm_init(void) { /* * page_cgroup requires countinous pages as memmap * and it's bigger than MAX_ORDER unless SPARSEMEM. */ page_cgroup_init_flatmem(); mem_init(); kmem_cache_init(); pgtable_cache_init(); vmalloc_init(); }   mem_init() 函数用于停用 bootmem 分配器并迁移到实际的内存管理函数（见 bootmem 分配器），kmem_cache_init() 函数用于初始化 slab/slob/slub 分配器。\nsetup_per_cpu_pageset() setup_per_cpu_pageset() 函数位于 mm/page_alloc.c，用于分配并初始化 pageset：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* * Allocate per cpu pagesets and initialize them. * Before this call only boot pagesets were available. * Boot pagesets will no longer be used by this processorr * after setup_per_cpu_pageset(). */ void __init setup_per_cpu_pageset(void) { struct zone *zone; int cpu; for_each_populated_zone(zone) { zone-pageset = alloc_percpu(struct per_cpu_pageset); for_each_possible_cpu(cpu) { struct per_cpu_pageset *pcp = per_cpu_ptr(zone-pageset, cpu); setup_pageset(pcp, zone_batchsize(zone)); if (percpu_pagelist_fraction) setup_pagelist_highmark(pcp, (zone-present_pages / percpu_pagelist_fraction)); } } }   ","wordCount":"2179","inLanguage":"zh-cn","datePublished":"2021-04-26T00:00:00Z","dateModified":"2021-04-26T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/kernel/memory/initialization/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>内存管理初始化</h1><div class=post-meta>April 26, 2021&nbsp;·&nbsp;11 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%88%9d%e5%a7%8b%e5%8c%96%e7%ae%80%e4%bb%8b aria-label=内存管理初始化简介>内存管理初始化简介</a></li><li><a href=#setup_arch aria-label=setup_arch()><code>setup_arch()</code></a><ul><li><a href=#machine_specific_memory_setup aria-label=machine_specific_memory_setup()><code>machine_specific_memory_setup()</code></a></li><li><a href=#parse_early_param aria-label=parse_early_param()><code>parse_early_param()</code></a></li><li><a href=#setup_memory aria-label=setup_memory()><code>setup_memory()</code></a></li><li><a href=#paging_init aria-label=paging_init()><code>paging_init()</code></a></li><li><a href=#zone_sizes_init aria-label=zone_sizes_init()><code>zone_sizes_init()</code></a></li></ul></li><li><a href=#setup_per_cpu_areas aria-label=setup_per_cpu_areas()><code>setup_per_cpu_areas()</code></a><ul><li><a href=#build_all_zonelists aria-label=build_all_zonelists()><code>build_all_zonelists()</code></a></li><li><a href=#mm_init aria-label=mm_init()><code>mm_init()</code></a></li><li><a href=#setup_per_cpu_pageset aria-label=setup_per_cpu_pageset()><code>setup_per_cpu_pageset()</code></a></li></ul></li></ul></div></details></div><div class=post-content><p><a href=/posts/kernel/kernel>Linux 内核学习笔记系列</a>，内存管理部分，简单介绍内存管理初始化。</p><h2 id=内存管理初始化简介>内存管理初始化简介<a hidden class=anchor aria-hidden=true href=#内存管理初始化简介>#</a></h2><p>体系结构相关的部分只考虑 x86-32 架构。</p><p>初始化相关的操作总是从 <code>start_kernel()</code> 开始看起，与内存管理初始化相关的流程如下（图片来源于 PLKA）：</p><p><img loading=lazy src=/images/kernel/memory/start_kernel.png alt="<code>start_kernel()</code>"></p><p><code>start_kernel()</code> 函数位于 <code>init/main.c</code>。</p><h2 id=setup_arch><code>setup_arch()</code><a hidden class=anchor aria-hidden=true href=#setup_arch>#</a></h2><p><code>setup_arch()</code> 的流程如下（图片来源于 PLKA）：</p><p><img loading=lazy src=/images/kernel/memory/setup_arch.png alt="<code>setup_arch()</code>"></p><p><code>setup_arch()</code> 函数位于 <code>arch/x86/kernel/setup.c</code>。</p><p>这部分内容在内核中经常被重构，导致不同内核版本间差异较大。事实上，我所查看的源码版本虽然与 PLKA 指示的内核版本很接近，但图中的很多函数已经重构了。</p><h3 id=machine_specific_memory_setup><code>machine_specific_memory_setup()</code><a hidden class=anchor aria-hidden=true href=#machine_specific_memory_setup>#</a></h3><p>直接搜索找不到 <code>machine_specific_memory_setup()</code> 函数，该函数应该已经被重构，推测功能接近的函数为 <code>setup_memory_map()</code>。</p><p>x86-32 架构使用 BIOS 的 e820 功能来探测物理内存。</p><p>在 <code>arch/x86/kernel/e820.c</code> 中，定义了 <code>char *__init default_machine_specific_memory_setup(void)</code> 函数，这个函数在 <code>arch/x86/kernel/x86_init.c</code> 中被赋值给了 <code>resources.memory_setup</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * The platform setup functions are preset with the default functions
</span><span style=color:#75715e> * for standard PC hardware.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>struct</span> x86_init_ops x86_init __initdata <span style=color:#f92672>=</span> {

    .resources <span style=color:#f92672>=</span> {
        .probe_roms         <span style=color:#f92672>=</span> x86_init_noop,
        .reserve_resources  <span style=color:#f92672>=</span> reserve_standard_io_resources,
        .memory_setup       <span style=color:#f92672>=</span> default_machine_specific_memory_setup,
    },
    ...
</code></pre></td></tr></table></div></div><p>之后在 <code>setup_memory_map()</code> 函数中被调用，而 <code>setup_memory_map()</code> 函数在 <code>setup_arch()</code> 中被调用。</p><p><code>arch/x86/kernel/e820.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>setup_memory_map</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>who;

    who <span style=color:#f92672>=</span> x86_init.resources.memory_setup();
    memcpy(<span style=color:#f92672>&amp;</span>e820_saved, <span style=color:#f92672>&amp;</span>e820, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> e820map));
    printk(KERN_INFO <span style=color:#e6db74>&#34;BIOS-provided physical RAM map:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
e820_print_map(who);
}
</code></pre></td></tr></table></div></div><h3 id=parse_early_param><code>parse_early_param()</code><a hidden class=anchor aria-hidden=true href=#parse_early_param>#</a></h3><p>内核的命令行参数可能有与内存管理相关的选项，因此把 <code>parse_early_param()</code> 也视为内存管理初始化的一部分。</p><p><code>parse_early_param()</code> 函数首先在 <code>setup_arch()</code> 函数中调用，虽然之后 <code>start_kernel()</code> 也会调用它。该函数的定义位于 <code>init/main.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* Arch code calls this early on, or if not, just before other parsing. */</span>
<span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>parse_early_param</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>static</span> __initdata <span style=color:#66d9ef>int</span> done <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>static</span> __initdata <span style=color:#66d9ef>char</span> tmp_cmdline[COMMAND_LINE_SIZE];

    <span style=color:#66d9ef>if</span> (done)
        <span style=color:#66d9ef>return</span>;

    <span style=color:#75715e>/* All fall through to do_early_param. */</span>
    strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
    parse_early_options(tmp_cmdline);
    done <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></td></tr></table></div></div><p>该函数调用 <code>init/main.c</code> 中的 <code>parse_early_options()</code>，通过 <code>parse_args()</code> 函数处理（<code>parse_args()</code> 细节不展开了）：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>parse_early_options</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cmdline)
{
    parse_args(<span style=color:#e6db74>&#34;early options&#34;</span>, cmdline, NULL, <span style=color:#ae81ff>0</span>, do_early_param);
}
</code></pre></td></tr></table></div></div><h3 id=setup_memory><code>setup_memory()</code><a hidden class=anchor aria-hidden=true href=#setup_memory>#</a></h3><p>该函数在当前版本内核源码里已经找不到了，推测改名为了 <code>initmem_init()</code> 和 ，UMA 和 NUMA 版本分别放置于 <code>arch/x86/mm/init_32.c</code> 和 <code>arch/x86/mm/numa_32.c</code>。</p><p><code>arch/x86/mm/init_32.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#ifndef CONFIG_NEED_MULTIPLE_NODES
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>initmem_init</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> start_pfn, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> end_pfn,
                                <span style=color:#66d9ef>int</span> acpi, <span style=color:#66d9ef>int</span> k8)
{
<span style=color:#75715e>#ifdef CONFIG_HIGHMEM
</span><span style=color:#75715e></span>    highstart_pfn <span style=color:#f92672>=</span> highend_pfn <span style=color:#f92672>=</span> max_pfn;
    <span style=color:#66d9ef>if</span> (max_pfn <span style=color:#f92672>&gt;</span> max_low_pfn)
        highstart_pfn <span style=color:#f92672>=</span> max_low_pfn;
    e820_register_active_regions(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, highend_pfn);
    sparse_memory_present_with_active_regions(<span style=color:#ae81ff>0</span>);
    printk(KERN_NOTICE <span style=color:#e6db74>&#34;%ldMB HIGHMEM available.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
        pages_to_mb(highend_pfn <span style=color:#f92672>-</span> highstart_pfn));
    num_physpages <span style=color:#f92672>=</span> highend_pfn;
    high_memory <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) __va(highstart_pfn <span style=color:#f92672>*</span> PAGE_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    e820_register_active_regions(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, max_low_pfn);
    sparse_memory_present_with_active_regions(<span style=color:#ae81ff>0</span>);
    num_physpages <span style=color:#f92672>=</span> max_low_pfn;
    high_memory <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) __va(max_low_pfn <span style=color:#f92672>*</span> PAGE_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
<span style=color:#75715e>#endif
</span><span style=color:#75715e>#ifdef CONFIG_FLATMEM
</span><span style=color:#75715e></span>    max_mapnr <span style=color:#f92672>=</span> num_physpages;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    __vmalloc_start_set <span style=color:#f92672>=</span> true;

    printk(KERN_NOTICE <span style=color:#e6db74>&#34;%ldMB LOWMEM available.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            pages_to_mb(max_low_pfn));

    setup_bootmem_allocator();
}
<span style=color:#75715e>#endif </span><span style=color:#75715e>/* !CONFIG_NEED_MULTIPLE_NODES */</span><span style=color:#75715e>
</span></code></pre></td></tr></table></div></div><p><code>arch/x86/mm/numa_32.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>initmem_init</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> start_pfn, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> end_pfn,
                                <span style=color:#66d9ef>int</span> acpi, <span style=color:#66d9ef>int</span> k8)
{
    <span style=color:#66d9ef>int</span> nid;
    <span style=color:#66d9ef>long</span> kva_target_pfn;

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * When mapping a NUMA machine we allocate the node_mem_map arrays
</span><span style=color:#75715e>     * from node local memory.  They are then mapped directly into KVA
</span><span style=color:#75715e>     * between zone normal and vmalloc space.  Calculate the size of
</span><span style=color:#75715e>     * this space and use it to adjust the boundary between ZONE_NORMAL
</span><span style=color:#75715e>     * and ZONE_HIGHMEM.
</span><span style=color:#75715e>     */</span>

    get_memcfg_numa();

    kva_pages <span style=color:#f92672>=</span> roundup(calculate_numa_remap_pages(), PTRS_PER_PTE);

    kva_target_pfn <span style=color:#f92672>=</span> round_down(max_low_pfn <span style=color:#f92672>-</span> kva_pages, PTRS_PER_PTE);
    <span style=color:#66d9ef>do</span> {
        kva_start_pfn <span style=color:#f92672>=</span> find_e820_area(kva_target_pfn<span style=color:#f92672>&lt;&lt;</span>PAGE_SHIFT,
                    max_low_pfn<span style=color:#f92672>&lt;&lt;</span>PAGE_SHIFT,
                    kva_pages<span style=color:#f92672>&lt;&lt;</span>PAGE_SHIFT,
                    PTRS_PER_PTE<span style=color:#f92672>&lt;&lt;</span>PAGE_SHIFT) <span style=color:#f92672>&gt;&gt;</span> PAGE_SHIFT;
        kva_target_pfn <span style=color:#f92672>-=</span> PTRS_PER_PTE;
    } <span style=color:#66d9ef>while</span> (kva_start_pfn <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&amp;&amp;</span> kva_target_pfn <span style=color:#f92672>&gt;</span> min_low_pfn);

    <span style=color:#66d9ef>if</span> (kva_start_pfn <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1UL</span>)
        panic(<span style=color:#e6db74>&#34;Can not get kva space</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);

    printk(KERN_INFO <span style=color:#e6db74>&#34;kva_start_pfn ~ %lx max_low_pfn ~ %lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
        kva_start_pfn, max_low_pfn);
    printk(KERN_INFO <span style=color:#e6db74>&#34;max_pfn = %lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, max_pfn);

    <span style=color:#75715e>/* avoid clash with initrd */</span>
    reserve_early(kva_start_pfn<span style=color:#f92672>&lt;&lt;</span>PAGE_SHIFT,
              (kva_start_pfn <span style=color:#f92672>+</span> kva_pages)<span style=color:#f92672>&lt;&lt;</span>PAGE_SHIFT,
             <span style=color:#e6db74>&#34;KVA PG&#34;</span>);
<span style=color:#75715e>#ifdef CONFIG_HIGHMEM
</span><span style=color:#75715e></span>    highstart_pfn <span style=color:#f92672>=</span> highend_pfn <span style=color:#f92672>=</span> max_pfn;
    <span style=color:#66d9ef>if</span> (max_pfn <span style=color:#f92672>&gt;</span> max_low_pfn)
        highstart_pfn <span style=color:#f92672>=</span> max_low_pfn;
    printk(KERN_NOTICE <span style=color:#e6db74>&#34;%ldMB HIGHMEM available.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
           pages_to_mb(highend_pfn <span style=color:#f92672>-</span> highstart_pfn));
    num_physpages <span style=color:#f92672>=</span> highend_pfn;
    high_memory <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) __va(highstart_pfn <span style=color:#f92672>*</span> PAGE_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    num_physpages <span style=color:#f92672>=</span> max_low_pfn;
    high_memory <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) __va(max_low_pfn <span style=color:#f92672>*</span> PAGE_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    printk(KERN_NOTICE <span style=color:#e6db74>&#34;%ldMB LOWMEM available.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            pages_to_mb(max_low_pfn));
    printk(KERN_DEBUG <span style=color:#e6db74>&#34;max_low_pfn = %lx, highstart_pfn = %lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            max_low_pfn, highstart_pfn);

    printk(KERN_DEBUG <span style=color:#e6db74>&#34;Low memory ends at vaddr %08lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            (ulong) pfn_to_kaddr(max_low_pfn));
    for_each_online_node(nid) {
        init_remap_allocator(nid);

        allocate_pgdat(nid);
    }
    remap_numa_kva();

    printk(KERN_DEBUG <span style=color:#e6db74>&#34;High memory starts at vaddr %08lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            (ulong) pfn_to_kaddr(highstart_pfn));
    for_each_online_node(nid)
        propagate_e820_map_node(nid);

    for_each_online_node(nid) {
        memset(NODE_DATA(nid), <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> pglist_data));
        NODE_DATA(nid)<span style=color:#f92672>-&gt;</span>node_id <span style=color:#f92672>=</span> nid;
<span style=color:#75715e>#ifndef CONFIG_NO_BOOTMEM
</span><span style=color:#75715e></span>        NODE_DATA(nid)<span style=color:#f92672>-&gt;</span>bdata <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>bootmem_node_data[nid];
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    }

    setup_bootmem_allocator();
}
</code></pre></td></tr></table></div></div><p>该函数主要用于确定物理页的数目，然后初始化 bootmem 分配器，bootmem 分配器的具体细节见 <a href=/posts/kernel/memory/bootmem>bootmem 分配器</a>。</p><h3 id=paging_init><code>paging_init()</code><a hidden class=anchor aria-hidden=true href=#paging_init>#</a></h3><p><code>paging_init()</code> 函数位于 <code>arch/x86/mm/init_32.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * paging_init() sets up the page tables - note that the first 8MB are
</span><span style=color:#75715e> * already mapped by head.S.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * This routines also unmaps the page at virtual kernel address 0, so
</span><span style=color:#75715e> * that we can trap those pesky NULL-reference errors in the kernel.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>paging_init</span>(<span style=color:#66d9ef>void</span>)
{
    pagetable_init();

    __flush_tlb_all();

    kmap_init();

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * NOTE: at this point the bootmem allocator is fully available.
</span><span style=color:#75715e>     */</span>
    sparse_init();
    zone_sizes_init();
}
</code></pre></td></tr></table></div></div><p>该函数会调用 <code>pagetable_init</code> 来确保直接映射的地址空间的物理内存被初始化：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#ifdef CONFIG_HIGHMEM
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>permanent_kmaps_init</span>(pgd_t <span style=color:#f92672>*</span>pgd_base)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> vaddr;
    pgd_t <span style=color:#f92672>*</span>pgd;
    pud_t <span style=color:#f92672>*</span>pud;
    pmd_t <span style=color:#f92672>*</span>pmd;
    pte_t <span style=color:#f92672>*</span>pte;

    vaddr <span style=color:#f92672>=</span> PKMAP_BASE;
    page_table_range_init(vaddr, vaddr <span style=color:#f92672>+</span> PAGE_SIZE<span style=color:#f92672>*</span>LAST_PKMAP, pgd_base);

    pgd <span style=color:#f92672>=</span> swapper_pg_dir <span style=color:#f92672>+</span> pgd_index(vaddr);
    pud <span style=color:#f92672>=</span> pud_offset(pgd, vaddr);
    pmd <span style=color:#f92672>=</span> pmd_offset(pud, vaddr);
    pte <span style=color:#f92672>=</span> pte_offset_kernel(pmd, vaddr);
    pkmap_page_table <span style=color:#f92672>=</span> pte;
}
<span style=color:#75715e>#else
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>permanent_kmaps_init</span>(pgd_t <span style=color:#f92672>*</span>pgd_base)
{
}
<span style=color:#75715e>#endif </span><span style=color:#75715e>/* CONFIG_HIGHMEM */</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>pagetable_init</span>(<span style=color:#66d9ef>void</span>)
{
    pgd_t <span style=color:#f92672>*</span>pgd_base <span style=color:#f92672>=</span> swapper_pg_dir;

    permanent_kmaps_init(pgd_base);
}
</code></pre></td></tr></table></div></div><p>这部分的细节太多，我不打算深入看了。</p><h3 id=zone_sizes_init><code>zone_sizes_init()</code><a hidden class=anchor aria-hidden=true href=#zone_sizes_init>#</a></h3><p>可以看到，在当前版本，该函数的调用者变成了 <code>paging_init()</code> 函数，而非 <code>setup_arch()</code> 函数。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>zone_sizes_init</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> max_zone_pfns[MAX_NR_ZONES];
    memset(max_zone_pfns, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(max_zone_pfns));
    max_zone_pfns[ZONE_DMA] <span style=color:#f92672>=</span>
        virt_to_phys((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)MAX_DMA_ADDRESS) <span style=color:#f92672>&gt;&gt;</span> PAGE_SHIFT;
    max_zone_pfns[ZONE_NORMAL] <span style=color:#f92672>=</span> max_low_pfn;
<span style=color:#75715e>#ifdef CONFIG_HIGHMEM
</span><span style=color:#75715e></span>    max_zone_pfns[ZONE_HIGHMEM] <span style=color:#f92672>=</span> highend_pfn;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    free_area_init_nodes(max_zone_pfns);
}
</code></pre></td></tr></table></div></div><p><code>add_active_range()</code> 对可用的物理内存建立一个相对简单的列表。但该函数已经不在 <code>zone_sizes_init()</code> 中被调用了，搜索后发现该函数在 <code>initmem_init()</code> 中已经被调用了，函数调用链是 <code>initmem_init() -> e820_register_active_regions() -> add_active_range()</code>。</p><p><code>free_area_init_nodes()</code> 它使用之前建立的列表来建立完备的内核数据结构。该函数是体系结构无关的，定义于 <code>mm/page_alloc.c</code>，这里不展开。</p><h2 id=setup_per_cpu_areas><code>setup_per_cpu_areas()</code><a hidden class=anchor aria-hidden=true href=#setup_per_cpu_areas>#</a></h2><p><code>setup_per_cpu_areas()</code> 函数位于 <code>arch/x86/kernel/setup_percpu.c</code>，用于初始化 <a href=/posts/kernel/memory/per-cpu>per-CPU 高速缓存</a>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>setup_per_cpu_areas</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> cpu;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> delta;
    <span style=color:#66d9ef>int</span> rc;

    pr_info(<span style=color:#e6db74>&#34;NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
        NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids);

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Allocate percpu area.  Embedding allocator is our favorite;
</span><span style=color:#75715e>     * however, on NUMA configurations, it can result in very
</span><span style=color:#75715e>     * sparse unit mapping and vmalloc area isn&#39;t spacious enough
</span><span style=color:#75715e>     * on 32bit.  Use page in that case.
</span><span style=color:#75715e>     */</span>
<span style=color:#75715e>#ifdef CONFIG_X86_32
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (pcpu_chosen_fc <span style=color:#f92672>==</span> PCPU_FC_AUTO <span style=color:#f92672>&amp;&amp;</span> pcpu_need_numa())
        pcpu_chosen_fc <span style=color:#f92672>=</span> PCPU_FC_PAGE;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    rc <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>EINVAL;
    <span style=color:#66d9ef>if</span> (pcpu_chosen_fc <span style=color:#f92672>!=</span> PCPU_FC_PAGE) {
        <span style=color:#66d9ef>const</span> size_t atom_size <span style=color:#f92672>=</span> cpu_has_pse <span style=color:#f92672>?</span> PMD_SIZE : PAGE_SIZE;
        <span style=color:#66d9ef>const</span> size_t dyn_size <span style=color:#f92672>=</span> PERCPU_MODULE_RESERVE <span style=color:#f92672>+</span>
            PERCPU_DYNAMIC_RESERVE <span style=color:#f92672>-</span> PERCPU_FIRST_CHUNK_RESERVE;

        rc <span style=color:#f92672>=</span> pcpu_embed_first_chunk(PERCPU_FIRST_CHUNK_RESERVE,
                        dyn_size, atom_size,
                        pcpu_cpu_distance,
                        pcpu_fc_alloc, pcpu_fc_free);
        <span style=color:#66d9ef>if</span> (rc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
            pr_warning(<span style=color:#e6db74>&#34;%s allocator failed (%d), falling back to page size</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
                   pcpu_fc_names[pcpu_chosen_fc], rc);
    }
    <span style=color:#66d9ef>if</span> (rc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
        rc <span style=color:#f92672>=</span> pcpu_page_first_chunk(PERCPU_FIRST_CHUNK_RESERVE,
                       pcpu_fc_alloc, pcpu_fc_free,
                       pcpup_populate_pte);
    <span style=color:#66d9ef>if</span> (rc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
        panic(<span style=color:#e6db74>&#34;cannot initialize percpu area (err=%d)&#34;</span>, rc);

    <span style=color:#75715e>/* alrighty, percpu areas up and running */</span>
    delta <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)pcpu_base_addr <span style=color:#f92672>-</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)__per_cpu_start;
    for_each_possible_cpu(cpu) {
        per_cpu_offset(cpu) <span style=color:#f92672>=</span> delta <span style=color:#f92672>+</span> pcpu_unit_offsets[cpu];
        per_cpu(this_cpu_off, cpu) <span style=color:#f92672>=</span> per_cpu_offset(cpu);
        per_cpu(cpu_number, cpu) <span style=color:#f92672>=</span> cpu;
        setup_percpu_segment(cpu);
        setup_stack_canary_segment(cpu);
        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * Copy data used in early init routines from the
</span><span style=color:#75715e>         * initial arrays to the per cpu data areas.  These
</span><span style=color:#75715e>         * arrays then become expendable and the *_early_ptr&#39;s
</span><span style=color:#75715e>         * are zeroed indicating that the static arrays are
</span><span style=color:#75715e>         * gone.
</span><span style=color:#75715e>         */</span>
<span style=color:#75715e>#ifdef CONFIG_X86_LOCAL_APIC
</span><span style=color:#75715e></span>        per_cpu(x86_cpu_to_apicid, cpu) <span style=color:#f92672>=</span>
            early_per_cpu_map(x86_cpu_to_apicid, cpu);
        per_cpu(x86_bios_cpu_apicid, cpu) <span style=color:#f92672>=</span>
            early_per_cpu_map(x86_bios_cpu_apicid, cpu);
<span style=color:#75715e>#endif
</span><span style=color:#75715e>#ifdef CONFIG_X86_64
</span><span style=color:#75715e></span>        per_cpu(irq_stack_ptr, cpu) <span style=color:#f92672>=</span>
            per_cpu(irq_stack_union.irq_stack, cpu) <span style=color:#f92672>+</span>
            IRQ_STACK_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>64</span>;
<span style=color:#75715e>#ifdef CONFIG_NUMA
</span><span style=color:#75715e></span>        per_cpu(x86_cpu_to_node_map, cpu) <span style=color:#f92672>=</span>
            early_per_cpu_map(x86_cpu_to_node_map, cpu);
<span style=color:#75715e>#endif
</span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * Up to this point, the boot CPU has been using .data.init
</span><span style=color:#75715e>         * area.  Reload any changed state for the boot CPU.
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>if</span> (cpu <span style=color:#f92672>==</span> boot_cpu_id)
            switch_to_new_gdt(cpu);
    }

    <span style=color:#75715e>/* indicate the early static arrays will soon be gone */</span>
<span style=color:#75715e>#ifdef CONFIG_X86_LOCAL_APIC
</span><span style=color:#75715e></span>    early_per_cpu_ptr(x86_cpu_to_apicid) <span style=color:#f92672>=</span> NULL;
    early_per_cpu_ptr(x86_bios_cpu_apicid) <span style=color:#f92672>=</span> NULL;
<span style=color:#75715e>#endif
</span><span style=color:#75715e>#if defined(CONFIG_X86_64) &amp;&amp; defined(CONFIG_NUMA)
</span><span style=color:#75715e></span>    early_per_cpu_ptr(x86_cpu_to_node_map) <span style=color:#f92672>=</span> NULL;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
<span style=color:#75715e>#if defined(CONFIG_X86_64) &amp;&amp; defined(CONFIG_NUMA)
</span><span style=color:#75715e></span>    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * make sure boot cpu node_number is right, when boot cpu is on the
</span><span style=color:#75715e>     * node that doesn&#39;t have mem installed
</span><span style=color:#75715e>     */</span>
    per_cpu(node_number, boot_cpu_id) <span style=color:#f92672>=</span> cpu_to_node(boot_cpu_id);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#75715e>/* Setup node to cpumask map */</span>
    setup_node_to_cpumask_map();

    <span style=color:#75715e>/* Setup cpu initialized, callin, callout masks */</span>
    setup_cpu_local_masks();
}
</code></pre></td></tr></table></div></div><h3 id=build_all_zonelists><code>build_all_zonelists()</code><a hidden class=anchor aria-hidden=true href=#build_all_zonelists>#</a></h3><p><code>build_all_zonelists()</code> 函数位于 <code>mm/page_alloc.c</code>，用于初始化结点和内存区域。</p><p>该函数和其调用的相关函数定义如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">104
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">105
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">106
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">107
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">108
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">109
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">110
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">111
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">112
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">113
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">114
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">115
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">116
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">117
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">118
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">119
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">120
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">121
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">122
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">123
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">124
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">125
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">126
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">127
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">128
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">129
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">130
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">131
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build_zonelists</span>(pg_data_t <span style=color:#f92672>*</span>pgdat)
{
    <span style=color:#66d9ef>int</span> j, node, load;
    <span style=color:#66d9ef>enum</span> zone_type i;
    nodemask_t used_mask;
    <span style=color:#66d9ef>int</span> local_node, prev_node;
    <span style=color:#66d9ef>struct</span> zonelist <span style=color:#f92672>*</span>zonelist;
    <span style=color:#66d9ef>int</span> order <span style=color:#f92672>=</span> current_zonelist_order;

    <span style=color:#75715e>/* initialize zonelists */</span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> MAX_ZONELISTS; i<span style=color:#f92672>++</span>) {
        zonelist <span style=color:#f92672>=</span> pgdat<span style=color:#f92672>-&gt;</span>node_zonelists <span style=color:#f92672>+</span> i;
        zonelist<span style=color:#f92672>-&gt;</span>_zonerefs[<span style=color:#ae81ff>0</span>].zone <span style=color:#f92672>=</span> NULL;
        zonelist<span style=color:#f92672>-&gt;</span>_zonerefs[<span style=color:#ae81ff>0</span>].zone_idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    }

    <span style=color:#75715e>/* NUMA-aware ordering of nodes */</span>
    local_node <span style=color:#f92672>=</span> pgdat<span style=color:#f92672>-&gt;</span>node_id;
    load <span style=color:#f92672>=</span> nr_online_nodes;
    prev_node <span style=color:#f92672>=</span> local_node;
    nodes_clear(used_mask);

    memset(node_order, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(node_order));
    j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#66d9ef>while</span> ((node <span style=color:#f92672>=</span> find_next_best_node(local_node, <span style=color:#f92672>&amp;</span>used_mask)) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#66d9ef>int</span> distance <span style=color:#f92672>=</span> node_distance(local_node, node);

        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * If another node is sufficiently far away then it is better
</span><span style=color:#75715e>         * to reclaim pages in a zone before going off node.
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>if</span> (distance <span style=color:#f92672>&gt;</span> RECLAIM_DISTANCE)
            zone_reclaim_mode <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * We don&#39;t want to pressure a particular node.
</span><span style=color:#75715e>         * So adding penalty to the first node in same
</span><span style=color:#75715e>         * distance group to make it round-robin.
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>if</span> (distance <span style=color:#f92672>!=</span> node_distance(local_node, prev_node))
            node_load[node] <span style=color:#f92672>=</span> load;

        prev_node <span style=color:#f92672>=</span> node;
        load<span style=color:#f92672>--</span>;
        <span style=color:#66d9ef>if</span> (order <span style=color:#f92672>==</span> ZONELIST_ORDER_NODE)
            build_zonelists_in_node_order(pgdat, node);
        <span style=color:#66d9ef>else</span>
            node_order[j<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> node;     <span style=color:#75715e>/* remember order */</span>
    }

    <span style=color:#66d9ef>if</span> (order <span style=color:#f92672>==</span> ZONELIST_ORDER_ZONE) {
        <span style=color:#75715e>/* calculate node order -- i.e., DMA last! */</span>
        build_zonelists_in_zone_order(pgdat, j);
    }

    build_thisnode_zonelists(pgdat);
}

<span style=color:#75715e>/* return values int ....just for stop_machine() */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>__build_all_zonelists</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dummy)
{
    <span style=color:#66d9ef>int</span> nid;
    <span style=color:#66d9ef>int</span> cpu;

<span style=color:#75715e>#ifdef CONFIG_NUMA
</span><span style=color:#75715e></span>    memset(node_load, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(node_load));
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    for_each_online_node(nid) {
        pg_data_t <span style=color:#f92672>*</span>pgdat <span style=color:#f92672>=</span> NODE_DATA(nid);

        build_zonelists(pgdat);
        build_zonelist_cache(pgdat);
    }

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Initialize the boot_pagesets that are going to be used
</span><span style=color:#75715e>     * for bootstrapping processors. The real pagesets for
</span><span style=color:#75715e>     * each zone will be allocated later when the per cpu
</span><span style=color:#75715e>     * allocator is available.
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * boot_pagesets are used also for bootstrapping offline
</span><span style=color:#75715e>     * cpus if the system is already booted because the pagesets
</span><span style=color:#75715e>     * are needed to initialize allocators on a specific cpu too.
</span><span style=color:#75715e>     * F.e. the percpu allocator needs the page allocator which
</span><span style=color:#75715e>     * needs the percpu allocator in order to allocate its pagesets
</span><span style=color:#75715e>     * (a chicken-egg dilemma).
</span><span style=color:#75715e>     */</span>
    for_each_possible_cpu(cpu)
        setup_pageset(<span style=color:#f92672>&amp;</span>per_cpu(boot_pageset, cpu), <span style=color:#ae81ff>0</span>);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build_all_zonelists</span>(<span style=color:#66d9ef>void</span>)
{
    set_zonelist_order();

    <span style=color:#66d9ef>if</span> (system_state <span style=color:#f92672>==</span> SYSTEM_BOOTING) {
        __build_all_zonelists(NULL);
        mminit_verify_zonelist();
        cpuset_init_current_mems_allowed();
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>/* we have to stop all cpus to guarantee there is no user
</span><span style=color:#75715e>           of zonelist */</span>
        stop_machine(__build_all_zonelists, NULL, NULL);
        <span style=color:#75715e>/* cpuset refresh routine should be here */</span>
    }
    vm_total_pages <span style=color:#f92672>=</span> nr_free_pagecache_pages();
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Disable grouping by mobility if the number of pages in the
</span><span style=color:#75715e>     * system is too low to allow the mechanism to work. It would be
</span><span style=color:#75715e>     * more accurate, but expensive to check per-zone. This check is
</span><span style=color:#75715e>     * made on memory-hotadd so a system can start with mobility
</span><span style=color:#75715e>     * disabled and enable it later
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>if</span> (vm_total_pages <span style=color:#f92672>&lt;</span> (pageblock_nr_pages <span style=color:#f92672>*</span> MIGRATE_TYPES))
        page_group_by_mobility_disabled <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>else</span>
        page_group_by_mobility_disabled <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    printk(<span style=color:#e6db74>&#34;Built %i zonelists in %s order, mobility grouping %s.  &#34;</span>
        <span style=color:#e6db74>&#34;Total pages: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            nr_online_nodes,
            zonelist_order_name[current_zonelist_order],
            page_group_by_mobility_disabled <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;off&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;on&#34;</span>,
            vm_total_pages);
<span style=color:#75715e>#ifdef CONFIG_NUMA
</span><span style=color:#75715e></span>    printk(<span style=color:#e6db74>&#34;Policy zone: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, zone_names[policy_zone]);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>}
</code></pre></td></tr></table></div></div><h3 id=mm_init><code>mm_init()</code><a hidden class=anchor aria-hidden=true href=#mm_init>#</a></h3><p><code>mm_init()</code> 函数位于 <code>init/main.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * Set up kernel memory allocators
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>mm_init</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * page_cgroup requires countinous pages as memmap
</span><span style=color:#75715e>     * and it&#39;s bigger than MAX_ORDER unless SPARSEMEM.
</span><span style=color:#75715e>     */</span>
    page_cgroup_init_flatmem();
    mem_init();
    kmem_cache_init();
    pgtable_cache_init();
    vmalloc_init();
}
</code></pre></td></tr></table></div></div><p><code>mem_init()</code> 函数用于停用 bootmem 分配器并迁移到实际的内存管理函数（见 <a href=/posts/kernel/memory/bootmem>bootmem 分配器</a>），<code>kmem_cache_init()</code> 函数用于初始化 slab/slob/slub 分配器。</p><h3 id=setup_per_cpu_pageset><code>setup_per_cpu_pageset()</code><a hidden class=anchor aria-hidden=true href=#setup_per_cpu_pageset>#</a></h3><p><code>setup_per_cpu_pageset()</code> 函数位于 <code>mm/page_alloc.c</code>，用于分配并初始化 pageset：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * Allocate per cpu pagesets and initialize them.
</span><span style=color:#75715e> * Before this call only boot pagesets were available.
</span><span style=color:#75715e> * Boot pagesets will no longer be used by this processorr
</span><span style=color:#75715e> * after setup_per_cpu_pageset().
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>setup_per_cpu_pageset</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone;
    <span style=color:#66d9ef>int</span> cpu;

    for_each_populated_zone(zone) {
        zone<span style=color:#f92672>-&gt;</span>pageset <span style=color:#f92672>=</span> alloc_percpu(<span style=color:#66d9ef>struct</span> per_cpu_pageset);

        for_each_possible_cpu(cpu) {
            <span style=color:#66d9ef>struct</span> per_cpu_pageset <span style=color:#f92672>*</span>pcp <span style=color:#f92672>=</span> per_cpu_ptr(zone<span style=color:#f92672>-&gt;</span>pageset, cpu);

            setup_pageset(pcp, zone_batchsize(zone));

            <span style=color:#66d9ef>if</span> (percpu_pagelist_fraction)
                setup_pagelist_highmark(pcp,
                    (zone<span style=color:#f92672>-&gt;</span>present_pages <span style=color:#f92672>/</span>
                        percpu_pagelist_fraction));
        }
    }
}
</code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/linux-%E5%86%85%E6%A0%B8/>Linux 内核</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>内存管理</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%9D%E5%A7%8B%E5%8C%96/>内存管理初始化</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/kernel/memory/map/><span class=title>«</span><br><span>内存映射</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/kernel/memory/uncontinuous/><span class=title>»</span><br><span>非连续页框的管理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>