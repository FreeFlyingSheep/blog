<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>内存模型 | FreeFlyingSheep 的小站</title><meta name=keywords content="Linux 内核,内存管理,内存模型"><meta name=description content="Linux 内核学习笔记系列，内存管理部分，简单介绍内存模型。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/kernel/memory/model/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="内存模型"><meta property="og:description" content="Linux 内核学习笔记系列，内存管理部分，简单介绍内存模型。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/kernel/memory/model/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-27T00:00:00+00:00"><meta property="article:modified_time" content="2020-10-27T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="内存模型"><meta name=twitter:description content="Linux 内核学习笔记系列，内存管理部分，简单介绍内存模型。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"内存模型","item":"https://freeflyingsheep.github.io/posts/kernel/memory/model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"内存模型","name":"内存模型","description":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存模型。\n","keywords":["Linux 内核","内存管理","内存模型"],"articleBody":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存模型。\n内存模型简介 简单概括，内存被划分为若干个结点，每个结点又被划分为若干个区，而每个区又包含若干页框。\n结点（Node） 结点简介 我们习惯上认为计算机内存是一种均匀、共享的资源，即在忽略硬件高速缓存作用的情况下，任意 CPU 对任意内存单元的访问都需要相同时间。这种模型被称为一致访问内存（UMA） 模型。IBM 兼容 PC 一般都采用这种模型。\n但对于某些体系结构，如 ALpha 或 MIPS，这种假设不成立。它们使用非一致访问内存（NUMA） 模型。\nLinux 支持 NUMA 模型，它通过把物理内存划分为多个结点，来保证对于每个结点，给定的 CPU 访问页面需要的时间相同。这样对于每个 CPU，内核可以试图把耗时结点的访问次数减到最小。\n在配置不使用 NUMA 的情况下，Linux 还是会使用一个单独的结点，包括所有的物理内存。\n结点数据结构 include/linux/mm_types.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  typedef struct pglist_data { struct zone node_zones[MAX_NR_ZONES]; struct zonelist node_zonelists[MAX_ZONELISTS]; int nr_zones; ... struct page *node_mem_map; ... struct bootmem_data *bdata; ... unsigned long node_start_pfn; unsigned long node_present_pages; /* total number of physical pages */ unsigned long node_spanned_pages; /* total size of physical page range, including holes */ int node_id; wait_queue_head_t kswapd_wait; struct task_struct *kswapd; int kswapd_max_order; } pg_data_t;    node_zones：包含结点中区数据结构的数组。若区没有那么多，其余项用 0 填充。 node_zonelists：备用结点及内存区域列表，以便在当前结点没有可用空间时，在备用结点分配内存。 nr_zones：不同区的数目。 node_mem_map：指向页实例的指针，包含了当前结点所有区的页。 bdata：指向自举内存分配器实例的指针，见内存管理初始化。 node_start_pfn：当前结点第一个页帧的逻辑编号，系统中所有页帧是依次编号的，因此每个页帧的号码都是全局唯一的。特别地，在 UMA 系统中，因为只有一个结点，所以该值总为 0。 node_present_pages：当前结点中页帧的数目。 node_spanned_pages：以页帧为单位计算的长度。 node_id：全局结点编号，从 0 开始。 kswapd_wait、kswapd 和 kswapd_max_order：交换守护进程（swap daemon）相关的内容，见 TODO。  结点状态管理 include/linux/nodemask.h：\n1 2 3 4 5 6 7 8 9 10 11 12  enum node_states { N_POSSIBLE, /* The node could become online at some point */ N_ONLINE, /* The node is online */ N_NORMAL_MEMORY, /* The node has regular memory */ #ifdef CONFIG_HIGHMEM  N_HIGH_MEMORY, /* The node has regular or high memory */ #else  N_HIGH_MEMORY = N_NORMAL_MEMORY, #endif  N_CPU, /* The node has one or more cpus */ NR_NODE_STATES };   N_POSSIBLE、N_ONLINE 和 N_NORMAL_MEMORY 用于内存热插拔，这部分内容不属于该系列学习笔记的范畴。\n设置和清除结点的特定位使用 void node_set_state(int node, enum node_states state) 和 void node_clear_state(int node, enum node_states state) 函数。\n区（内存域，Zone） 区简介 理想模型中，所有的页框都是相同的，可以对其执行任何操作。现实中，硬件是有限制的：\n 一些硬件只能用某些特定的内存地址来执行 DMA。 一些体系结构的内存的物理地址范围比虚拟地址范围大得多，线性地址空间太小导致 CPU 不能直接访问所有的物理内存。  对内存的每个结点，Linux 分了 3 个区来解决这些限制：\n ZONE_DMA：执行 DMA 操作的页框。 ZONE_NORMAL：能正常映射的页框。 ZONE_HIGHMEM：动态映射的页框。  此处两本书的描述略有不同，《Linux 内核设计与实现》基于 2.6.34 版本，这时候已经新加了 ZONE_DMA32 区，该区和 ZONE_DMA 的区别在于这个区能被 32 位的设备访问。在 32 位系统上，该区长度为 0，而在 64 位系统上，该区长度可能为 0-4G。该区是 2.6.14 版本添加的，参考社区新闻 ZONE_DMA32。\nZONE_HIGHMEM 区的内存被称为高端内存，其余部分则被称为低端内存。\n举个例子，在 x86 上，ZONE_DMA 包含了物理内存 0-16MB，ZONE_NORMAL 包含了 16-896MB，ZONE_HIGHMEM 包含了剩下的部分。\n但不是所有体系结构都定义了全部区，如 x86-64 可以映射处理 64 位的内存空间，就不需要 ZONE_HIGHMEM 区了。\n区的类型 include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  enum zone_type { #ifdef CONFIG_ZONE_DMA  ZONE_DMA, #endif #ifdef CONFIG_ZONE_DMA32  ZONE_DMA32, #endif  ZONE_NORMAL, #ifdef CONFIG_HIGHMEM  ZONE_HIGHMEM, #endif  ZONE_MOVABLE, __MAX_NR_ZONES };   其中，ZONE_MOVABLE 是伪内存区域，用于防止内存碎片的机制，见 TODO。__MAX_NR_ZONES 在构建过程中会生成 include/generated/bounds.h 中的 MAX_NR_ZONES 宏（具体生成过程涉及 Kbuild，已经不属于本系列学习笔记的范畴），充当结束标记。\n区数据结构 区相关的枚举和结构体大部分位于 include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  struct zone { /* Fields commonly accessed by the page allocator */ unsigned long watermark[NR_WMARK]; unsigned long lowmem_reserve[MAX_NR_ZONES]; struct per_cpu_pageset __percpu *pageset; /* * free areas of different sizes */ spinlock_t lock; ... struct free_area free_area[MAX_ORDER]; ... ZONE_PADDING(_pad1_) /* Fields commonly accessed by the page reclaim scanner */ spinlock_t lru_lock; struct zone_lru { struct list_head list; } lru[NR_LRU_LISTS]; ... unsigned long pages_scanned; /* since last reclaim */ unsigned long flags; /* zone flags, see below */ /* Zone statistics */ atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS]; int prev_priority; ... ZONE_PADDING(_pad2_) /* Rarely used or read-mostly fields */ wait_queue_head_t * wait_table; unsigned long wait_table_hash_nr_entries; unsigned long wait_table_bits; /* * Discontig memory support fields. */ struct pglist_data *zone_pgdat; /* zone_start_pfn == zone_start_paddr  PAGE_SHIFT */ unsigned long zone_start_pfn; unsigned long spanned_pages; /* total size, including holes */ unsigned long present_pages; /* amount of memory (excluding holes) */ /* * rarely used fields: */ const char *name; } ____cacheline_internodealigned_in_smp;   该结构体被 ZONE_PADDING 分割为多个部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * zone-lock and zone-lru_lock are two of the hottest locks in the kernel. * So add a wild amount of padding here to ensure that they fall into separate * cachelines. There are very few zone structures in the machine, so space * consumption is not a concern here. */ #if defined(CONFIG_SMP) struct zone_padding { char x[0]; } ____cacheline_internodealigned_in_smp; #define ZONE_PADDING(name) struct zone_padding name; #else #define ZONE_PADDING(name) #endif   因为对该结构体的访问非常频繁，在多处理系统上，通常会有不同的 CPU 试图访问结构体成员。使用 ZONE_PADDING 宏填充结构体，以确保每个自旋锁都处于自己的缓存行中。使用 ____cacheline_internodealigned_in_smp，实现最优的告诉缓存对齐方式。\n第一部分 先来看该结构体的第一部分，通常由页分配器访问的字段。\nwatermark 是页换出时使用的“水位标志”：\n1 2 3 4 5 6  enum zone_watermarks { WMARK_MIN, WMARK_LOW, WMARK_HIGH, NR_WMARK };   在较早版本的内核中，“水位标志”由三个 unsigned long 变量 pages_min、pages_low 和 pages_high 构成，现在它们被合并到了 watermark 数组。下面为了方便讨论该数组的三个元素，依然使用它们的旧变量名。\n这三个元素会影响交换守护程序的行为，这里只做简单介绍：\n pages_high：若空闲页多于该值，则区的状态是理想的。 pages_low：若空闲页低于该值，则内核开始讲页换出到硬盘。 pages_min：若空闲页低于该值，那么页回收工作的压力较大，内存急需空闲页。  lowmem_reserve 数组代表每个区必须保留的页框数目，见保留的页框池。\npageset 用于实现每个 CPU 的冷/热页帧列表，见 per-CPU 高速缓存。\nfree_area 用于实现伙伴系统，见伙伴系统。\n第二部分 再来看该结构体的第二部分，通常由页面回收扫描程序访问的字段。\n根据 lru 数组的名字，可以推测现在内核使用了 LRU 算法来管理页，该数组包含了若干个链表：\n1 2 3 4 5 6 7 8 9 10 11 12  #define LRU_BASE 0 #define LRU_ACTIVE 1 #define LRU_FILE 2  enum lru_list { LRU_INACTIVE_ANON = LRU_BASE, LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE, LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE, LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE, LRU_UNEVICTABLE, NR_LRU_LISTS };   这里先定义宏，再用宏的值定义枚举成员的值，目的是方便后续计算时使用这些宏的值，同时又可以用枚举成员作为与之对应的数组下标。\n较早的版本没有使用 lru 数组，而是用 struct list_head active_list 表示活动页的集合，struct list_head inactive_list 表示不活动页的集合，unsigned long nr_scan_active 和 unsigned long nr_scan_inactive 指定在回收内存时需要扫描的活动页和不活动页的数目，后面的内容针对的是较新的版本。\npages_scanned 指定了上次换出一页以来，有多少页未能成功扫描，见 TODO。\nflags 描述当前区的状态：\n1 2 3 4  typedef enum { ZONE_RECLAIM_LOCKED, /* prevents concurrent reclaim */ ZONE_OOM_LOCKED, /* zone is in OOM killer zonelist */ } zone_flags_t;   同样的，内核提供了相应的辅助函数来设置状态：\n1 2 3  void zone_set_flag(struct zone *zone, zone_flags_t flag); int zone_test_and_set_flag(struct zone *zone, zone_flags_t flag); void zone_clear_flag(struct zone *zone, zone_flags_t flag);   vm_stat 维护了当前区的统计信息。可以使用辅助函数 unsigned long zone_page_state(struct zone *zone, enum zone_stat_item item) 来读取其中的信息，该函数定义于 include/linux/vmstat.h。\nprev_priority 存储了上一次扫描操作扫描当前区的优先级，见 TODO。\n第三部分 最后来看该结构体的第三部分，很少使用或大多数情况下只读的字段。\nwait_table、wait_table_hash_nr_entries 和 wait_table_bits 实现了一个等待队列，可用于等待某一页变为可用进程。可以简单理解为进程排成一一个队列，等待某些条件，在条件变为真时，内核会通知进程恢复工作。具体原理见 TODO。\nzone_pgdat 指向对应的 pg_list_data 实例，建立了区和父结点之间的关联。\nzone_start_pfn 是内存域第一个页帧的索引。\nspanned_pages 指定区中页的总数，但并非所有都是可用的，内存中可能存在一些小的空洞。\npresent_pages 则给出了实际可用的页的总数。\nname 是一个字符串，保存当前区的惯用名称。\n页（Page） 页和页框简介 页框是系统内存的最小单位，对内存中的每个页，内核都会创建一个 struct page 实例。\n注意区分术语“页”和“页框”。操作系统为了方便管理存储器，把数据分成固定大小的区块，这些区块被称为页（页面，page）。处理器的分页单元会根据页的大小把物理内存划分为若干个物理块，这些物理块就是页框（页帧，page frame）。页存放于页框中，而 struct page 是页对应的描述符。\n页数据结构 页的数据结构在较新的内核中由 include/linux/mm.h 移到了 include/linux/mm_types.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  struct page { unsigned long flags; /* Atomic flags, some possibly * updated asynchronously */ atomic_t _count; /* Usage count, see below. */ union { atomic_t _mapcount; /* Count of ptes mapped in mms, * to show when page is mapped * \u0026 limit reverse map searches. */ struct { /* SLUB */ u16 inuse; u16 objects; }; }; union { struct { unsigned long private; /* Mapping-private opaque data: * usually used for buffer_heads * if PagePrivate set; used for * swp_entry_t if PageSwapCache; * indicates order in the buddy * system if PG_buddy is set. */ struct address_space *mapping; /* If low bit clear, points to * inode address_space, or NULL. * If page mapped as anonymous * memory, low bit is set, and * it points to anon_vma object: * see PAGE_MAPPING_ANON below. */ }; ... struct kmem_cache *slab; /* SLUB: Pointer to slab */ struct page *first_page; /* Compound tail pages */ }; union { pgoff_t index; /* Our offset within mapping. */ void *freelist; /* SLUB: freelist req. slab lock */ }; struct list_head lru; /* Pageout list, eg. active_list * protected by zone-lru_lock ! */ #if defined(WANT_PAGE_VIRTUAL)  void *virtual; /* Kernel virtual address (NULL if not kmapped, ie. highmem) */ #endif /* WANT_PAGE_VIRTUAL */ ... };    flags：存储体系结构无关的标志，用于描述页的属性，相关标志位于 include/linux/page-flags.h。 _count：使用计数，表示内核中引用该页的次数。在其值为 0 时，内核知道 page 实例当前不使用，因此可以删除。 _mapcount：表示在页表中有多少项指向该页。 inuse、objects、slab 和 freelist：用于 slub 分配器，这部分内容不属于该学习笔记的范畴。 private：指向“私有”数据的指针，这里不准备展开介绍。 mapping 和 index：分部指定了页框所在的地址空间和页框在映射内部的偏移量。特别地，若 mapping 的低位被置 1，则该指针不指向 address_space 实例，而是指向 anon_vma，实现匿名页的逆向映射，见 TODO。 first_page：指向首页的指针。内核可以将多个连续的页合并成较大的复合页（compound page），分组中的第一个页被称为首页（head page），其余各页称为尾页（tail page）。 lru：用于在各种链表上维护该页，以便将页按不同类别分组。一个重要的例子是活动页和不活动页，见 TODO。 virtual：存储高端内存区域中页的虚拟地址。  用联合体的原因是，某些字段只会被内核的特定部分使用，对于其他部分是多余的，而 C 语言的联合体刚好能解决这一问题。例如，若某一页被用于 slub 分配器，则可以确保该页只被内核使用，那映射计数信息（_mapcount）就是多余的，该字段可以被用来存储 slub 分配器相关的信息（inuse 和 objects）。\n值得注意的是，mapping 指向的 address_space 实例总是对齐到 sizeof(long)，因此该指针的低位总是 0，可以用于存储额外的信息。内核中很多地方利用了这种方式，来尽可能地节约内存使用，但这种方式从可读性角度来看，确实是很糟糕的，正如书上说的，这是一种近乎“肆无忌惮”的技巧。\n个人理解 内核开发者试图在可读性与高效间权衡，在希望节省关键数据结构占用的空间时，他们尽可能复用现有的字段，甚至不想看到任何一个多余的字段。而在复用字段时，由于内核不同的部分需要的字段类型可能不同，他们不能接受用同一个类型来表示不同的数据类型，因此使用联合体来解决这一问题，如上面的 _mapcount、inuse 和 objects。但对于一些字段，如上面的 private，因为不同内核部分使用时需要的类型相同，都是 unsigned long，所以就没用到联合体。而对于一些特定的数据，如上面的指针 mapping，因为低位总是 0，所以低位可以用于存储额外的信息，进一步节省内存占用。如果说用联合体是为了可读性，复用字段是为了高效（降低内存占用），page 结构体则是这两者结合的产物。\n既然是为了可读性和高效，那思考下面的问题：\n 从可读性角度出发，就如上面的 private，为何不用联合体来为不同内核部分定义不同的字段名？ 从高效角度出发，对于其他指针，为何不复用它们的低位存储其他信息，来进一步减少内存空间的使用？ 可读性和高效间的度谁来权衡，怎么权衡？  这究竟是不是一种好的编程技巧呢？或许与大部分人的想法背道而驰，我认为这种代码是“糟糕的”而不是“巧妙的”，这更像是高手的“任性”，尽管这种技巧确实为内核节省了很多空间。\n我认为学习内核，重要的学习它的设计思想和实用的编程技巧。而上面用到的一些编程技巧，个人认为并不“实用”。在平时开发过程中，如果不是遇到一些极端的情况，比如需要尽可能压榨内存的使用等等，完全没必要做到这种程度，滥用这些编程技巧的危害往往更大。\n","wordCount":"1161","inLanguage":"zh-cn","datePublished":"2020-10-27T00:00:00Z","dateModified":"2020-10-27T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/kernel/memory/model/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>内存模型</h1><div class=post-meta>October 27, 2020&nbsp;·&nbsp;6 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e7%ae%80%e4%bb%8b aria-label=内存模型简介>内存模型简介</a></li><li><a href=#%e7%bb%93%e7%82%b9node aria-label=结点（Node）>结点（Node）</a><ul><li><a href=#%e7%bb%93%e7%82%b9%e7%ae%80%e4%bb%8b aria-label=结点简介>结点简介</a></li><li><a href=#%e7%bb%93%e7%82%b9%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=结点数据结构>结点数据结构</a></li><li><a href=#%e7%bb%93%e7%82%b9%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86 aria-label=结点状态管理>结点状态管理</a></li></ul></li><li><a href=#%e5%8c%ba%e5%86%85%e5%ad%98%e5%9f%9fzone aria-label=区（内存域，Zone）>区（内存域，Zone）</a><ul><li><a href=#%e5%8c%ba%e7%ae%80%e4%bb%8b aria-label=区简介>区简介</a></li><li><a href=#%e5%8c%ba%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=区的类型>区的类型</a></li><li><a href=#%e5%8c%ba%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=区数据结构>区数据结构</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86 aria-label=第一部分>第一部分</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86 aria-label=第二部分>第二部分</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86 aria-label=第三部分>第三部分</a></li></ul></li></ul></li><li><a href=#%e9%a1%b5page aria-label=页（Page）>页（Page）</a><ul><li><a href=#%e9%a1%b5%e5%92%8c%e9%a1%b5%e6%a1%86%e7%ae%80%e4%bb%8b aria-label=页和页框简介>页和页框简介</a></li><li><a href=#%e9%a1%b5%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=页数据结构>页数据结构</a></li></ul></li><li><a href=#%e4%b8%aa%e4%ba%ba%e7%90%86%e8%a7%a3 aria-label=个人理解>个人理解</a></li></ul></div></details></div><div class=post-content><p><a href=/posts/kernel/kernel>Linux 内核学习笔记系列</a>，内存管理部分，简单介绍内存模型。</p><h2 id=内存模型简介>内存模型简介<a hidden class=anchor aria-hidden=true href=#内存模型简介>#</a></h2><p>简单概括，内存被划分为若干个结点，每个结点又被划分为若干个区，而每个区又包含若干页框。</p><h2 id=结点node>结点（Node）<a hidden class=anchor aria-hidden=true href=#结点node>#</a></h2><h3 id=结点简介>结点简介<a hidden class=anchor aria-hidden=true href=#结点简介>#</a></h3><p>我们习惯上认为计算机内存是一种均匀、共享的资源，即在忽略硬件高速缓存作用的情况下，任意 CPU 对任意内存单元的访问都需要相同时间。这种模型被称为<strong>一致访问内存（UMA）</strong> 模型。IBM 兼容 PC 一般都采用这种模型。</p><p>但对于某些体系结构，如 ALpha 或 MIPS，这种假设不成立。它们使用<strong>非一致访问内存（NUMA）</strong> 模型。</p><p>Linux 支持 NUMA 模型，它通过把物理内存划分为多个结点，来保证对于每个结点，给定的 CPU 访问页面需要的时间相同。这样对于每个 CPU，内核可以试图把耗时结点的访问次数减到最小。</p><p>在配置不使用 NUMA 的情况下，Linux 还是会使用一个单独的结点，包括所有的物理内存。</p><h3 id=结点数据结构>结点数据结构<a hidden class=anchor aria-hidden=true href=#结点数据结构>#</a></h3><p><code>include/linux/mm_types.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> pglist_data {
    <span style=color:#66d9ef>struct</span> zone node_zones[MAX_NR_ZONES];
    <span style=color:#66d9ef>struct</span> zonelist node_zonelists[MAX_ZONELISTS];
    <span style=color:#66d9ef>int</span> nr_zones;
    ...
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>node_mem_map;
    ...
    <span style=color:#66d9ef>struct</span> bootmem_data <span style=color:#f92672>*</span>bdata;
    ...
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> node_start_pfn;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> node_present_pages; <span style=color:#75715e>/* total number of physical pages */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> node_spanned_pages; <span style=color:#75715e>/* total size of physical page
</span><span style=color:#75715e>                                         range, including holes */</span>
    <span style=color:#66d9ef>int</span> node_id;
    wait_queue_head_t kswapd_wait;
    <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>kswapd;
    <span style=color:#66d9ef>int</span> kswapd_max_order;
} pg_data_t;
</code></pre></td></tr></table></div></div><ul><li><code>node_zones</code>：包含结点中区数据结构的数组。若区没有那么多，其余项用 <code>0</code> 填充。</li><li><code>node_zonelists</code>：备用结点及内存区域列表，以便在当前结点没有可用空间时，在备用结点分配内存。</li><li><code>nr_zones</code>：不同区的数目。</li><li><code>node_mem_map</code>：指向页实例的指针，包含了当前结点所有区的页。</li><li><code>bdata</code>：指向自举内存分配器实例的指针，见<a href=/posts/kernel/memory/init>内存管理初始化</a>。</li><li><code>node_start_pfn</code>：当前结点第一个页帧的逻辑编号，系统中所有页帧是依次编号的，因此每个页帧的号码都是全局唯一的。特别地，在 UMA 系统中，因为只有一个结点，所以该值总为 <code>0</code>。</li><li><code>node_present_pages</code>：当前结点中页帧的数目。</li><li><code>node_spanned_pages</code>：以页帧为单位计算的长度。</li><li><code>node_id</code>：全局结点编号，从 <code>0</code> 开始。</li><li><code>kswapd_wait</code>、<code>kswapd</code> 和 <code>kswapd_max_order</code>：交换守护进程（swap daemon）相关的内容，见 <a href=/posts/kernel/todo>TODO</a>。</li></ul><h3 id=结点状态管理>结点状态管理<a hidden class=anchor aria-hidden=true href=#结点状态管理>#</a></h3><p><code>include/linux/nodemask.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>enum</span> node_states {
    N_POSSIBLE,         <span style=color:#75715e>/* The node could become online at some point */</span>
    N_ONLINE,           <span style=color:#75715e>/* The node is online */</span>
    N_NORMAL_MEMORY,    <span style=color:#75715e>/* The node has regular memory */</span>
<span style=color:#75715e>#ifdef CONFIG_HIGHMEM
</span><span style=color:#75715e></span>    N_HIGH_MEMORY,      <span style=color:#75715e>/* The node has regular or high memory */</span>
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    N_HIGH_MEMORY <span style=color:#f92672>=</span> N_NORMAL_MEMORY,
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    N_CPU,              <span style=color:#75715e>/* The node has one or more cpus */</span>
    NR_NODE_STATES
};
</code></pre></td></tr></table></div></div><p><code>N_POSSIBLE</code>、<code>N_ONLINE</code> 和 <code>N_NORMAL_MEMORY</code> 用于内存热插拔，这部分内容不属于该系列学习笔记的范畴。</p><p>设置和清除结点的特定位使用 <code>void node_set_state(int node, enum node_states state)</code> 和 <code>void node_clear_state(int node, enum node_states state)</code> 函数。</p><h2 id=区内存域zone>区（内存域，Zone）<a hidden class=anchor aria-hidden=true href=#区内存域zone>#</a></h2><h3 id=区简介>区简介<a hidden class=anchor aria-hidden=true href=#区简介>#</a></h3><p>理想模型中，所有的页框都是相同的，可以对其执行任何操作。现实中，硬件是有限制的：</p><ul><li>一些硬件只能用某些特定的内存地址来执行 DMA。</li><li>一些体系结构的内存的物理地址范围比虚拟地址范围大得多，线性地址空间太小导致 CPU 不能直接访问所有的物理内存。</li></ul><p>对内存的每个结点，Linux 分了 3 个区来解决这些限制：</p><ul><li><code>ZONE_DMA</code>：执行 DMA 操作的页框。</li><li><code>ZONE_NORMAL</code>：能正常映射的页框。</li><li><code>ZONE_HIGHMEM</code>：动态映射的页框。</li></ul><p>此处两本书的描述略有不同，《Linux 内核设计与实现》基于 2.6.34 版本，这时候已经新加了 <code>ZONE_DMA32</code> 区，该区和 <code>ZONE_DMA</code> 的区别在于这个区能被 32 位的设备访问。在 32 位系统上，该区长度为 <code>0</code>，而在 64 位系统上，该区长度可能为 <code>0-4G</code>。该区是 2.6.14 版本添加的，参考社区新闻 <a href=https://lwn.net/Articles/152462/>ZONE_DMA32</a>。</p><p><code>ZONE_HIGHMEM</code> 区的内存被称为<strong>高端内存</strong>，其余部分则被称为<strong>低端内存</strong>。</p><p>举个例子，在 x86 上，<code>ZONE_DMA</code> 包含了物理内存 <code>0-16MB</code>，<code>ZONE_NORMAL</code> 包含了 <code>16-896MB</code>，<code>ZONE_HIGHMEM</code> 包含了剩下的部分。</p><p>但<strong>不是所有体系结构都定义了全部区</strong>，如 x86-64 可以映射处理 64 位的内存空间，就不需要 <code>ZONE_HIGHMEM</code> 区了。</p><h3 id=区的类型>区的类型<a hidden class=anchor aria-hidden=true href=#区的类型>#</a></h3><p><code>include/linux/mmzone.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>enum</span> zone_type {
<span style=color:#75715e>#ifdef CONFIG_ZONE_DMA
</span><span style=color:#75715e></span>    ZONE_DMA,
<span style=color:#75715e>#endif
</span><span style=color:#75715e>#ifdef CONFIG_ZONE_DMA32
</span><span style=color:#75715e></span>    ZONE_DMA32,
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    ZONE_NORMAL,
<span style=color:#75715e>#ifdef CONFIG_HIGHMEM
</span><span style=color:#75715e></span>    ZONE_HIGHMEM,
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    ZONE_MOVABLE,
    __MAX_NR_ZONES
};
</code></pre></td></tr></table></div></div><p>其中，<code>ZONE_MOVABLE</code> 是伪内存区域，用于防止内存碎片的机制，见 <a href=/posts/kernel/todo>TODO</a>。<code>__MAX_NR_ZONES</code> 在构建过程中会生成 <code>include/generated/bounds.h</code> 中的 <code>MAX_NR_ZONES</code> 宏（具体生成过程涉及 Kbuild，已经不属于本系列学习笔记的范畴），充当结束标记。</p><h3 id=区数据结构>区数据结构<a hidden class=anchor aria-hidden=true href=#区数据结构>#</a></h3><p>区相关的枚举和结构体大部分位于 <code>include/linux/mmzone.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> zone {
    <span style=color:#75715e>/* Fields commonly accessed by the page allocator */</span>

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> watermark[NR_WMARK];

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           lowmem_reserve[MAX_NR_ZONES];

    <span style=color:#66d9ef>struct</span> per_cpu_pageset __percpu <span style=color:#f92672>*</span>pageset;

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * free areas of different sizes
</span><span style=color:#75715e>     */</span>
    spinlock_t              lock;
    ...
    <span style=color:#66d9ef>struct</span> free_area        free_area[MAX_ORDER];
    ...
    ZONE_PADDING(_pad1_)

    <span style=color:#75715e>/* Fields commonly accessed by the page reclaim scanner */</span>
    spinlock_t              lru_lock;
    <span style=color:#66d9ef>struct</span> zone_lru {
        <span style=color:#66d9ef>struct</span> list_head list;
    } lru[NR_LRU_LISTS];

    ...

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>            pages_scanned; <span style=color:#75715e>/* since last reclaim */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>            flags;         <span style=color:#75715e>/* zone flags, see below */</span>

    <span style=color:#75715e>/* Zone statistics */</span>
    atomic_long_t            vm_stat[NR_VM_ZONE_STAT_ITEMS];

    <span style=color:#66d9ef>int</span> prev_priority;

    ...

    ZONE_PADDING(_pad2_)
    <span style=color:#75715e>/* Rarely used or read-mostly fields */</span>

    wait_queue_head_t       <span style=color:#f92672>*</span> wait_table;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           wait_table_hash_nr_entries;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           wait_table_bits;

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Discontig memory support fields.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>struct</span> pglist_data      <span style=color:#f92672>*</span>zone_pgdat;
    <span style=color:#75715e>/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           zone_start_pfn;

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           spanned_pages;  <span style=color:#75715e>/* total size, including holes */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           present_pages;  <span style=color:#75715e>/* amount of memory (excluding holes) */</span>

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * rarely used fields:
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>              <span style=color:#f92672>*</span>name;
} ____cacheline_internodealigned_in_smp;
</code></pre></td></tr></table></div></div><p>该结构体被 <code>ZONE_PADDING</code> 分割为多个部分：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * zone-&gt;lock and zone-&gt;lru_lock are two of the hottest locks in the kernel.
</span><span style=color:#75715e> * So add a wild amount of padding here to ensure that they fall into separate
</span><span style=color:#75715e> * cachelines.  There are very few zone structures in the machine, so space
</span><span style=color:#75715e> * consumption is not a concern here.
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>#if defined(CONFIG_SMP)
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> zone_padding {
    <span style=color:#66d9ef>char</span> x[<span style=color:#ae81ff>0</span>];
} ____cacheline_internodealigned_in_smp;
<span style=color:#75715e>#define ZONE_PADDING(name) struct zone_padding name;
</span><span style=color:#75715e>#else
</span><span style=color:#75715e>#define ZONE_PADDING(name)
</span><span style=color:#75715e>#endif
</span></code></pre></td></tr></table></div></div><p>因为对该结构体的访问非常频繁，在多处理系统上，通常会有不同的 CPU 试图访问结构体成员。使用 <code>ZONE_PADDING</code> 宏填充结构体，以确保每个自旋锁都处于自己的缓存行中。使用 <code>____cacheline_internodealigned_in_smp</code>，实现最优的告诉缓存对齐方式。</p><h4 id=第一部分>第一部分<a hidden class=anchor aria-hidden=true href=#第一部分>#</a></h4><p>先来看该结构体的第一部分，通常由页分配器访问的字段。</p><p><code>watermark</code> 是页换出时使用的“水位标志”：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>enum</span> zone_watermarks {
    WMARK_MIN,
    WMARK_LOW,
    WMARK_HIGH,
    NR_WMARK
};
</code></pre></td></tr></table></div></div><p>在较早版本的内核中，“水位标志”由三个 <code>unsigned long</code> 变量 <code>pages_min</code>、<code>pages_low</code> 和 <code>pages_high</code> 构成，现在它们被合并到了 <code>watermark</code> 数组。下面为了方便讨论该数组的三个元素，依然使用它们的旧变量名。</p><p>这三个元素会影响交换守护程序的行为，这里只做简单介绍：</p><ul><li><code>pages_high</code>：若空闲页多于该值，则区的状态是理想的。</li><li><code>pages_low</code>：若空闲页低于该值，则内核开始讲页换出到硬盘。</li><li><code>pages_min</code>：若空闲页低于该值，那么页回收工作的压力较大，内存急需空闲页。</li></ul><p><code>lowmem_reserve</code> 数组代表每个区必须保留的页框数目，见<a href=/posts/kernel/memory/continuous#%E4%BF%9D%E7%95%99%E7%9A%84%E9%A1%B5%E6%A1%86%E6%B1%A0>保留的页框池</a>。</p><p><code>pageset</code> 用于实现每个 CPU 的冷/热页帧列表，见 <a href=/posts/kernel/memory/per-cpu>per-CPU 高速缓存</a>。</p><p><code>free_area</code> 用于实现伙伴系统，见<a href=/posts/kernel/memory/buddy-system>伙伴系统</a>。</p><h4 id=第二部分>第二部分<a hidden class=anchor aria-hidden=true href=#第二部分>#</a></h4><p>再来看该结构体的第二部分，通常由页面回收扫描程序访问的字段。</p><p>根据 <code>lru</code> 数组的名字，可以推测现在内核使用了 LRU 算法来管理页，该数组包含了若干个链表：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define LRU_BASE 0
</span><span style=color:#75715e>#define LRU_ACTIVE 1
</span><span style=color:#75715e>#define LRU_FILE 2
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>enum</span> lru_list {
    LRU_INACTIVE_ANON <span style=color:#f92672>=</span> LRU_BASE,
    LRU_ACTIVE_ANON <span style=color:#f92672>=</span> LRU_BASE <span style=color:#f92672>+</span> LRU_ACTIVE,
    LRU_INACTIVE_FILE <span style=color:#f92672>=</span> LRU_BASE <span style=color:#f92672>+</span> LRU_FILE,
    LRU_ACTIVE_FILE <span style=color:#f92672>=</span> LRU_BASE <span style=color:#f92672>+</span> LRU_FILE <span style=color:#f92672>+</span> LRU_ACTIVE,
    LRU_UNEVICTABLE,
    NR_LRU_LISTS
};
</code></pre></td></tr></table></div></div><p>这里先定义宏，再用宏的值定义枚举成员的值，目的是方便后续计算时使用这些宏的值，同时又可以用枚举成员作为与之对应的数组下标。</p><p>较早的版本没有使用 <code>lru</code> 数组，而是用 <code>struct list_head active_list</code> 表示活动页的集合，<code>struct list_head inactive_list</code> 表示不活动页的集合，<code>unsigned long nr_scan_active</code> 和 <code>unsigned long nr_scan_inactive</code> 指定在回收内存时需要扫描的活动页和不活动页的数目，后面的内容针对的是较新的版本。</p><p><code>pages_scanned</code> 指定了上次换出一页以来，有多少页未能成功扫描，见 <a href=/posts/kernel/todo>TODO</a>。</p><p><code>flags</code> 描述当前区的状态：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
    ZONE_RECLAIM_LOCKED,    <span style=color:#75715e>/* prevents concurrent reclaim */</span>
    ZONE_OOM_LOCKED,        <span style=color:#75715e>/* zone is in OOM killer zonelist */</span>
} zone_flags_t;
</code></pre></td></tr></table></div></div><p>同样的，内核提供了相应的辅助函数来设置状态：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>zone_set_flag</span>(<span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone, zone_flags_t flag);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>zone_test_and_set_flag</span>(<span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone, zone_flags_t flag);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>zone_clear_flag</span>(<span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone, zone_flags_t flag);
</code></pre></td></tr></table></div></div><p><code>vm_stat</code> 维护了当前区的统计信息。可以使用辅助函数 <code>unsigned long zone_page_state(struct zone *zone, enum zone_stat_item item)</code> 来读取其中的信息，该函数定义于 <code>include/linux/vmstat.h</code>。</p><p><code>prev_priority</code> 存储了上一次扫描操作扫描当前区的优先级，见 <a href=/posts/kernel/todo>TODO</a>。</p><h4 id=第三部分>第三部分<a hidden class=anchor aria-hidden=true href=#第三部分>#</a></h4><p>最后来看该结构体的第三部分，很少使用或大多数情况下只读的字段。</p><p><code>wait_table</code>、<code>wait_table_hash_nr_entries</code> 和 <code>wait_table_bits</code> 实现了一个等待队列，可用于等待某一页变为可用进程。可以简单理解为进程排成一一个队列，等待某些条件，在条件变为真时，内核会通知进程恢复工作。具体原理见 <a href=/posts/kernel/todo>TODO</a>。</p><p><code>zone_pgdat</code> 指向对应的 <code>pg_list_data</code> 实例，建立了区和父结点之间的关联。</p><p><code>zone_start_pfn</code> 是内存域第一个页帧的索引。</p><p><code>spanned_pages</code> 指定区中页的总数，但并非所有都是可用的，内存中可能存在一些小的空洞。</p><p><code>present_pages</code> 则给出了实际可用的页的总数。</p><p><code>name</code> 是一个字符串，保存当前区的惯用名称。</p><h2 id=页page>页（Page）<a hidden class=anchor aria-hidden=true href=#页page>#</a></h2><h3 id=页和页框简介>页和页框简介<a hidden class=anchor aria-hidden=true href=#页和页框简介>#</a></h3><p>页框是系统内存的最小单位，对内存中的每个页，内核都会创建一个 <code>struct page</code> 实例。</p><p>注意区分术语“页”和“页框”。操作系统为了方便管理存储器，把数据分成固定大小的区块，这些区块被称为页（页面，page）。处理器的分页单元会根据页的大小把物理内存划分为若干个物理块，这些物理块就是页框（页帧，page frame）。页存放于页框中，而 <code>struct page</code> 是页对应的描述符。</p><h3 id=页数据结构>页数据结构<a hidden class=anchor aria-hidden=true href=#页数据结构>#</a></h3><p>页的数据结构在较新的内核中由 <code>include/linux/mm.h</code> 移到了 <code>include/linux/mm_types.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> page {
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;                <span style=color:#75715e>/* Atomic flags, some possibly
</span><span style=color:#75715e>                                         * updated asynchronously */</span>
    atomic_t _count;                    <span style=color:#75715e>/* Usage count, see below. */</span>
    <span style=color:#66d9ef>union</span> {
        atomic_t _mapcount;             <span style=color:#75715e>/* Count of ptes mapped in mms,
</span><span style=color:#75715e>                                         * to show when page is mapped
</span><span style=color:#75715e>                                         * &amp; limit reverse map searches.
</span><span style=color:#75715e>                                         */</span>
        <span style=color:#66d9ef>struct</span> {                        <span style=color:#75715e>/* SLUB */</span>
            u16 inuse;
            u16 objects;
        };
    };
    <span style=color:#66d9ef>union</span> {
        <span style=color:#66d9ef>struct</span> {
            <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> private;          <span style=color:#75715e>/* Mapping-private opaque data:
</span><span style=color:#75715e>                                             * usually used for buffer_heads
</span><span style=color:#75715e>                                             * if PagePrivate set; used for
</span><span style=color:#75715e>                                             * swp_entry_t if PageSwapCache;
</span><span style=color:#75715e>                                             * indicates order in the buddy
</span><span style=color:#75715e>                                             * system if PG_buddy is set.
</span><span style=color:#75715e>                                             */</span>
            <span style=color:#66d9ef>struct</span> address_space <span style=color:#f92672>*</span>mapping;  <span style=color:#75715e>/* If low bit clear, points to
</span><span style=color:#75715e>                                             * inode address_space, or NULL.
</span><span style=color:#75715e>                                             * If page mapped as anonymous
</span><span style=color:#75715e>                                             * memory, low bit is set, and
</span><span style=color:#75715e>                                             * it points to anon_vma object:
</span><span style=color:#75715e>                                             * see PAGE_MAPPING_ANON below.
</span><span style=color:#75715e>                                             */</span>
        };
        ...
        <span style=color:#66d9ef>struct</span> kmem_cache <span style=color:#f92672>*</span>slab;        <span style=color:#75715e>/* SLUB: Pointer to slab */</span>
        <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>first_page;        <span style=color:#75715e>/* Compound tail pages */</span>
    };
    <span style=color:#66d9ef>union</span> {
        pgoff_t index;                  <span style=color:#75715e>/* Our offset within mapping. */</span>
        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>freelist;                 <span style=color:#75715e>/* SLUB: freelist req. slab lock */</span>
    };
    <span style=color:#66d9ef>struct</span> list_head lru;               <span style=color:#75715e>/* Pageout list, eg. active_list
</span><span style=color:#75715e>                                         * protected by zone-&gt;lru_lock !
</span><span style=color:#75715e>                                         */</span>

<span style=color:#75715e>#if defined(WANT_PAGE_VIRTUAL)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>virtual;                      <span style=color:#75715e>/* Kernel virtual address (NULL if
</span><span style=color:#75715e>                                           not kmapped, ie. highmem) */</span>
<span style=color:#75715e>#endif </span><span style=color:#75715e>/* WANT_PAGE_VIRTUAL */</span><span style=color:#75715e>
</span><span style=color:#75715e></span>    ...
};
</code></pre></td></tr></table></div></div><ul><li><code>flags</code>：存储体系结构无关的标志，用于描述页的属性，相关标志位于 <code>include/linux/page-flags.h</code>。</li><li><code>_count</code>：使用计数，表示内核中引用该页的次数。在其值为 <code>0</code> 时，内核知道 <code>page</code> 实例当前不使用，因此可以删除。</li><li><code>_mapcount</code>：表示在页表中有多少项指向该页。</li><li><code>inuse</code>、<code>objects</code>、<code>slab</code> 和 <code>freelist</code>：用于 slub 分配器，这部分内容不属于该学习笔记的范畴。</li><li><code>private</code>：指向“私有”数据的指针，这里不准备展开介绍。</li><li><code>mapping</code> 和 <code>index</code>：分部指定了页框所在的地址空间和页框在映射内部的偏移量。特别地，若 <code>mapping</code> 的低位被置 <code>1</code>，则该指针不指向 <code>address_space</code> 实例，而是指向 <code>anon_vma</code>，实现匿名页的逆向映射，见 <a href=/posts/kernel/todo>TODO</a>。</li><li><code>first_page</code>：指向首页的指针。内核可以将多个连续的页合并成较大的复合页（compound page），分组中的第一个页被称为首页（head page），其余各页称为尾页（tail page）。</li><li><code>lru</code>：用于在各种链表上维护该页，以便将页按不同类别分组。一个重要的例子是活动页和不活动页，见 <a href=/posts/kernel/todo>TODO</a>。</li><li><code>virtual</code>：存储高端内存区域中页的虚拟地址。</li></ul><p>用联合体的原因是，某些字段只会被内核的特定部分使用，对于其他部分是多余的，而 C 语言的联合体刚好能解决这一问题。例如，若某一页被用于 slub 分配器，则可以确保该页只被内核使用，那映射计数信息（<code>_mapcount</code>）就是多余的，该字段可以被用来存储 slub 分配器相关的信息（<code>inuse</code> 和 <code>objects</code>）。</p><p>值得注意的是，<code>mapping</code> 指向的 <code>address_space</code> 实例总是对齐到 <code>sizeof(long)</code>，因此该指针的低位总是 <code>0</code>，可以用于存储额外的信息。内核中很多地方利用了这种方式，来尽可能地节约内存使用，但这种方式从可读性角度来看，确实是很糟糕的，正如书上说的，这是一种近乎“肆无忌惮”的技巧。</p><h2 id=个人理解>个人理解<a hidden class=anchor aria-hidden=true href=#个人理解>#</a></h2><p>内核开发者试图在可读性与高效间权衡，在希望节省关键数据结构占用的空间时，他们尽可能复用现有的字段，甚至不想看到任何一个多余的字段。而在复用字段时，由于内核不同的部分需要的字段类型可能不同，他们不能接受用同一个类型来表示不同的数据类型，因此使用联合体来解决这一问题，如上面的 <code>_mapcount</code>、<code>inuse</code> 和 <code>objects</code>。但对于一些字段，如上面的 <code>private</code>，因为不同内核部分使用时需要的类型相同，都是 <code>unsigned long</code>，所以就没用到联合体。而对于一些特定的数据，如上面的指针 <code>mapping</code>，因为低位总是 <code>0</code>，所以低位可以用于存储额外的信息，进一步节省内存占用。如果说用联合体是为了可读性，复用字段是为了高效（降低内存占用），<code>page</code> 结构体则是这两者结合的产物。</p><p>既然是为了可读性和高效，那思考下面的问题：</p><ul><li>从可读性角度出发，就如上面的 <code>private</code>，为何不用联合体来为不同内核部分定义不同的字段名？</li><li>从高效角度出发，对于其他指针，为何不复用它们的低位存储其他信息，来进一步减少内存空间的使用？</li><li>可读性和高效间的度谁来权衡，怎么权衡？</li></ul><p>这究竟是不是一种好的编程技巧呢？或许与大部分人的想法背道而驰，我认为这种代码是“糟糕的”而不是“巧妙的”，这更像是高手的“任性”，尽管这种技巧确实为内核节省了很多空间。</p><p>我认为学习内核，重要的学习它的设计思想和实用的编程技巧。而上面用到的一些编程技巧，个人认为并不“实用”。在平时开发过程中，如果不是遇到一些极端的情况，比如需要尽可能压榨内存的使用等等，完全没必要做到这种程度，滥用这些编程技巧的危害往往更大。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/linux-%E5%86%85%E6%A0%B8/>Linux 内核</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>内存管理</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/>内存模型</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/kernel/todo/><span class=title>«</span><br><span>TODO 列表</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/kernel/develop/develop/><span class=title>»</span><br><span>内核开发相关知识</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>