<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>伙伴系统 | FreeFlyingSheep 的小站</title><meta name=keywords content="Linux 内核,内存管理,伙伴系统"><meta name=description content="Linux 内核学习笔记系列，内存管理部分，简单介绍伙伴系统。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/kernel/memory/buddy-system/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="伙伴系统"><meta property="og:description" content="Linux 内核学习笔记系列，内存管理部分，简单介绍伙伴系统。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/kernel/memory/buddy-system/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-21T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-21T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="伙伴系统"><meta name=twitter:description content="Linux 内核学习笔记系列，内存管理部分，简单介绍伙伴系统。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"伙伴系统","item":"https://freeflyingsheep.github.io/posts/kernel/memory/buddy-system/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"伙伴系统","name":"伙伴系统","description":"Linux 内核学习笔记系列，内存管理部分，简单介绍伙伴系统。\n","keywords":["Linux 内核","内存管理","伙伴系统"],"articleBody":"Linux 内核学习笔记系列，内存管理部分，简单介绍伙伴系统。\n伙伴系统简介 伙伴（Buddy）系统是为了解决外碎片问题而设计的。\n伙伴系统算法把所有的空闲页框分为 11 个块链表，每个块链表分别包含 1、2、4、8、16、32、64、128、256、512 和 1024 个连续的页框。每个块的第一个页框的物理地址是该块大小的整数倍。由于内核页大小是 4 KB，所以最大请求为 4 MB 大小连续的 RAM 块。\n在请求块时，算法会先在请求页框大小块的链表中检查是否有一个空闲块，如果没有，就查找下一个更大的块，把这个块分裂为两个小块。如果还是没有找到，就继续查找更大块，直到最大的 1024 个页框的块。如果 1024 个页框的链表还是空的，算法就放弃并发出错误信号。\n在释放块时，算法会试图把一对空闲伙伴合并为一个单独的块，且算法是迭代的，即算法会再次试图合成的生成的块。满足以下条件的两个块被称为伙伴：\n 两个块具有相同的大小，记作 $b$。 它们的物理地址连续。 第一个块的第一个页框的物理地址是 $2 \\times b \\times 2^{12}$。  由于块的大小都是 2 的幂，所以被称为伙伴的块只有一位二进制位不同。对于一个块，只需要与掩码（1 ）进行异或操作，就能找到它的伙伴。\n伙伴系统分配器 数据结构 include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  struct zone { ... /* * free areas of different sizes */ spinlock_t lock; struct free_area free_area[MAX_ORDER]; ... /* * Discontig memory support fields. */ struct pglist_data *zone_pgdat; struct page *zone_mem_map; /* zone_start_pfn == zone_start_paddr  PAGE_SHIFT */ unsigned long zone_start_pfn; unsigned long spanned_pages; /* total size, including holes */ unsigned long present_pages; /* amount of memory (excluding holes) */ ... }   对每个管理区，Linux 采用不同的伙伴系统，每个伙伴系统使用的主要数据结构如下：\n mem_map 数组。每个区都关系到该数组的子集，由 zone_mem_map 指定子集的第一个元素。 free_area 数组。该数组的元素类型为 free_area，每个元素对应一种块大小。  分配块 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  static inline struct page * expand(struct zone *zone, struct page *page, int low, int high, struct free_area *area) { unsigned long size = 1  high; while (high  low) { // current_order  order  area--; high--; size = 1; BUG_ON(bad_range(zone, \u0026page[size])); list_add(\u0026page[size].lru, \u0026area-free_list); // 添加到空闲链表  area-nr_free++; set_page_order(\u0026page[size], high); // 设置 private  } return page; } /* * Do the hard work of removing an element from the buddy allocator. * Call me with the zone-lock already held. */ static struct page *__rmqueue(struct zone *zone, unsigned int order) { struct free_area * area; unsigned int current_order; struct page *page; for (current_order = order; current_order  MAX_ORDER; ++current_order) { area = zone-free_area + current_order; if (list_empty(\u0026area-free_list)) continue; page = list_entry(area-free_list.next, struct page, lru); list_del(\u0026page-lru); // 从空闲链表中删除  rmv_page_order(page); // 清除 private  area-nr_free--; zone-free_pages -= 1UL  order; return expand(zone, page, order, current_order, area); } return NULL; }   释放块 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  static inline void __free_pages_bulk (struct page *page, struct page *base, struct zone *zone, unsigned int order) { unsigned long page_idx; struct page *coalesced; int order_size = 1  order; if (unlikely(order)) // 复合页  destroy_compound_page(page, order); page_idx = page - base; // 当前块的下标  BUG_ON(page_idx \u0026 (order_size - 1)); BUG_ON(bad_range(zone, page)); zone-free_pages += order_size; while (order  MAX_ORDER-1) { // 合并一个块和它的伙伴  struct free_area *area; struct page *buddy; int buddy_idx; buddy_idx = (page_idx ^ (1  order)); // 当前块的伙伴的下标  buddy = base + buddy_idx; if (bad_range(zone, buddy)) break; if (!page_is_buddy(buddy, order)) break; /* Move the buddy up one level. */ list_del(\u0026buddy-lru); area = zone-free_area + order; area-nr_free--; rmv_page_order(buddy); // 清除 private  page_idx \u0026= buddy_idx; // 恢复当前块的下标  order++; } coalesced = base + page_idx; set_page_order(coalesced, order); list_add(\u0026coalesced-lru, \u0026zone-free_area[order].free_list); // 添加到空闲链表  zone-free_area[order].nr_free++; }   复合页：将物理上连续的两个或多个页看成一个独立的大页，具体可以参考社区新闻 An introduction to compound pages。\n","wordCount":"498","inLanguage":"zh-cn","datePublished":"2020-07-21T00:00:00Z","dateModified":"2020-07-21T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/kernel/memory/buddy-system/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>伙伴系统</h1><div class=post-meta>July 21, 2020&nbsp;·&nbsp;3 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e4%bc%99%e4%bc%b4%e7%b3%bb%e7%bb%9f%e7%ae%80%e4%bb%8b aria-label=伙伴系统简介>伙伴系统简介</a></li><li><a href=#%e4%bc%99%e4%bc%b4%e7%b3%bb%e7%bb%9f%e5%88%86%e9%85%8d%e5%99%a8 aria-label=伙伴系统分配器>伙伴系统分配器</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a></li><li><a href=#%e5%88%86%e9%85%8d%e5%9d%97 aria-label=分配块>分配块</a></li><li><a href=#%e9%87%8a%e6%94%be%e5%9d%97 aria-label=释放块>释放块</a></li></ul></li></ul></div></details></div><div class=post-content><p><a href=/posts/kernel/kernel>Linux 内核学习笔记系列</a>，内存管理部分，简单介绍伙伴系统。</p><h2 id=伙伴系统简介>伙伴系统简介<a hidden class=anchor aria-hidden=true href=#伙伴系统简介>#</a></h2><p>伙伴（Buddy）系统是为了解决外碎片问题而设计的。</p><p>伙伴系统算法把所有的空闲页框分为 11 个块链表，每个块链表分别包含 1、2、4、8、16、32、64、128、256、512 和 1024 个连续的页框。每个块的第一个页框的物理地址是该块大小的整数倍。由于内核页大小是 4 KB，所以最大请求为 4 MB 大小连续的 RAM 块。</p><p>在请求块时，算法会先在请求页框大小块的链表中检查是否有一个空闲块，如果没有，就查找下一个更大的块，把这个块分裂为两个小块。如果还是没有找到，就继续查找更大块，直到最大的 1024 个页框的块。如果 1024 个页框的链表还是空的，算法就放弃并发出错误信号。</p><p>在释放块时，算法会试图把一对空闲伙伴合并为一个单独的块，且算法是迭代的，即算法会再次试图合成的生成的块。满足以下条件的两个块被称为伙伴：</p><ul><li>两个块具有相同的大小，记作 $b$。</li><li>它们的物理地址连续。</li><li>第一个块的第一个页框的物理地址是 $2 \times b \times 2^{12}$。</li></ul><p>由于块的大小都是 2 的幂，所以被称为伙伴的块只有一位二进制位不同。对于一个块，只需要与掩码（<code>1 &lt;&lt; order</code>）进行异或操作，就能找到它的伙伴。</p><h2 id=伙伴系统分配器>伙伴系统分配器<a hidden class=anchor aria-hidden=true href=#伙伴系统分配器>#</a></h2><h3 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h3><p><code>include/linux/mmzone.h</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> zone {
    ...
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * free areas of different sizes
</span><span style=color:#75715e>     */</span>
    spinlock_t lock;
    <span style=color:#66d9ef>struct</span> free_area free_area[MAX_ORDER];
    ...
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Discontig memory support fields.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>struct</span> pglist_data <span style=color:#f92672>*</span>zone_pgdat;
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>zone_mem_map;
    <span style=color:#75715e>/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> zone_start_pfn;

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> spanned_pages; <span style=color:#75715e>/* total size, including holes */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> present_pages; <span style=color:#75715e>/* amount of memory (excluding holes) */</span>
    ...
}
</code></pre></td></tr></table></div></div><p>对每个管理区，Linux 采用不同的伙伴系统，每个伙伴系统使用的主要数据结构如下：</p><ul><li><code>mem_map</code> 数组。每个区都关系到该数组的子集，由 <code>zone_mem_map</code> 指定子集的第一个元素。</li><li><code>free_area</code> 数组。该数组的元素类型为 <code>free_area</code>，每个元素对应一种块大小。</li></ul><h3 id=分配块>分配块<a hidden class=anchor aria-hidden=true href=#分配块>#</a></h3><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>
<span style=color:#a6e22e>expand</span>(<span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone, <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page,
    <span style=color:#66d9ef>int</span> low, <span style=color:#66d9ef>int</span> high, <span style=color:#66d9ef>struct</span> free_area <span style=color:#f92672>*</span>area)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> high;

    <span style=color:#66d9ef>while</span> (high <span style=color:#f92672>&gt;</span> low) { <span style=color:#75715e>// current_order &gt; order
</span><span style=color:#75715e></span>        area<span style=color:#f92672>--</span>;
        high<span style=color:#f92672>--</span>;
        size <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;
        BUG_ON(bad_range(zone, <span style=color:#f92672>&amp;</span>page[size]));
        list_add(<span style=color:#f92672>&amp;</span>page[size].lru, <span style=color:#f92672>&amp;</span>area<span style=color:#f92672>-&gt;</span>free_list); <span style=color:#75715e>// 添加到空闲链表
</span><span style=color:#75715e></span>        area<span style=color:#f92672>-&gt;</span>nr_free<span style=color:#f92672>++</span>;
        set_page_order(<span style=color:#f92672>&amp;</span>page[size], high); <span style=color:#75715e>// 设置 private
</span><span style=color:#75715e></span>    }
    <span style=color:#66d9ef>return</span> page;
}

<span style=color:#75715e>/*
</span><span style=color:#75715e> * Do the hard work of removing an element from the buddy allocator.
</span><span style=color:#75715e> * Call me with the zone-&gt;lock already held.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span><span style=color:#a6e22e>__rmqueue</span>(<span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>struct</span> free_area <span style=color:#f92672>*</span> area;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> current_order;
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page;

    <span style=color:#66d9ef>for</span> (current_order <span style=color:#f92672>=</span> order; current_order <span style=color:#f92672>&lt;</span> MAX_ORDER; <span style=color:#f92672>++</span>current_order) {
        area <span style=color:#f92672>=</span> zone<span style=color:#f92672>-&gt;</span>free_area <span style=color:#f92672>+</span> current_order;
        <span style=color:#66d9ef>if</span> (list_empty(<span style=color:#f92672>&amp;</span>area<span style=color:#f92672>-&gt;</span>free_list))
            <span style=color:#66d9ef>continue</span>;

        page <span style=color:#f92672>=</span> list_entry(area<span style=color:#f92672>-&gt;</span>free_list.next, <span style=color:#66d9ef>struct</span> page, lru);
        list_del(<span style=color:#f92672>&amp;</span>page<span style=color:#f92672>-&gt;</span>lru); <span style=color:#75715e>// 从空闲链表中删除
</span><span style=color:#75715e></span>        rmv_page_order(page); <span style=color:#75715e>// 清除 private
</span><span style=color:#75715e></span>        area<span style=color:#f92672>-&gt;</span>nr_free<span style=color:#f92672>--</span>;
        zone<span style=color:#f92672>-&gt;</span>free_pages <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> order;
        <span style=color:#66d9ef>return</span> expand(zone, page, order, current_order, area);
    }

    <span style=color:#66d9ef>return</span> NULL;
}
</code></pre></td></tr></table></div></div><h3 id=释放块>释放块<a hidden class=anchor aria-hidden=true href=#释放块>#</a></h3><p><code>mm/page_alloc.c</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__free_pages_bulk</span> (<span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page, <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>base,
        <span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> order)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> page_idx;
    <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>coalesced;
    <span style=color:#66d9ef>int</span> order_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> order;

    <span style=color:#66d9ef>if</span> (unlikely(order)) <span style=color:#75715e>// 复合页
</span><span style=color:#75715e></span>        destroy_compound_page(page, order);

    page_idx <span style=color:#f92672>=</span> page <span style=color:#f92672>-</span> base; <span style=color:#75715e>// 当前块的下标
</span><span style=color:#75715e></span>
    BUG_ON(page_idx <span style=color:#f92672>&amp;</span> (order_size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>));
    BUG_ON(bad_range(zone, page));

    zone<span style=color:#f92672>-&gt;</span>free_pages <span style=color:#f92672>+=</span> order_size;
    <span style=color:#66d9ef>while</span> (order <span style=color:#f92672>&lt;</span> MAX_ORDER<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// 合并一个块和它的伙伴
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>struct</span> free_area <span style=color:#f92672>*</span>area;
        <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>buddy;
        <span style=color:#66d9ef>int</span> buddy_idx;

        buddy_idx <span style=color:#f92672>=</span> (page_idx <span style=color:#f92672>^</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> order)); <span style=color:#75715e>// 当前块的伙伴的下标
</span><span style=color:#75715e></span>        buddy <span style=color:#f92672>=</span> base <span style=color:#f92672>+</span> buddy_idx;
        <span style=color:#66d9ef>if</span> (bad_range(zone, buddy))
            <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>page_is_buddy(buddy, order))
            <span style=color:#66d9ef>break</span>;
        <span style=color:#75715e>/* Move the buddy up one level. */</span>
        list_del(<span style=color:#f92672>&amp;</span>buddy<span style=color:#f92672>-&gt;</span>lru);
        area <span style=color:#f92672>=</span> zone<span style=color:#f92672>-&gt;</span>free_area <span style=color:#f92672>+</span> order;
        area<span style=color:#f92672>-&gt;</span>nr_free<span style=color:#f92672>--</span>;
        rmv_page_order(buddy); <span style=color:#75715e>// 清除 private
</span><span style=color:#75715e></span>        page_idx <span style=color:#f92672>&amp;=</span> buddy_idx; <span style=color:#75715e>// 恢复当前块的下标
</span><span style=color:#75715e></span>        order<span style=color:#f92672>++</span>;
    }
    coalesced <span style=color:#f92672>=</span> base <span style=color:#f92672>+</span> page_idx;
    set_page_order(coalesced, order);
    list_add(<span style=color:#f92672>&amp;</span>coalesced<span style=color:#f92672>-&gt;</span>lru, <span style=color:#f92672>&amp;</span>zone<span style=color:#f92672>-&gt;</span>free_area[order].free_list); <span style=color:#75715e>// 添加到空闲链表
</span><span style=color:#75715e></span>    zone<span style=color:#f92672>-&gt;</span>free_area[order].nr_free<span style=color:#f92672>++</span>;
}
</code></pre></td></tr></table></div></div><p>复合页：将物理上连续的两个或多个页看成一个独立的大页，具体可以参考社区新闻 <em><a href=https://lwn.net/Articles/619514/>An introduction to compound pages</a></em>。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/linux-%E5%86%85%E6%A0%B8/>Linux 内核</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>内存管理</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/>伙伴系统</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/kernel/memory/per-cpu/><span class=title>«</span><br><span>per-CPU 高速缓存</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/tips/mips-boot/><span class=title>»</span><br><span>Linux/MIPS 启动</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>