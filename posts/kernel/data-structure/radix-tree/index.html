<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>内核基数树 | FreeFlyingSheep 的小站</title><meta name=keywords content="Linux 内核,内核数据结构,链表"><meta name=description content="Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/kernel/data-structure/radix-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="内核基数树"><meta property="og:description" content="Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/kernel/data-structure/radix-tree/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-28T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-28T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="内核基数树"><meta name=twitter:description content="Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"内核基数树","item":"https://freeflyingsheep.github.io/posts/kernel/data-structure/radix-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"内核基数树","name":"内核基数树","description":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。\n","keywords":["Linux 内核","内核数据结构","链表"],"articleBody":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。\n基数树简介 前缀树（字典树） 该部分内容来源于维基百科。\n 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。\n键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。\ntrie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串比特，可以用于表示整数或者内存地址。\n 基数树 该部分内容来源于维基百科。\n 在计算机科学中，基数树（也叫基数特里树或压缩前缀树）是一种数据结构，是一种更节省空间的Trie（前缀树），其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。因此每个内部节点的子节点数最多为基数树的基数r ，其中r为正整数，x为2的幂，x≥1，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。\n  基数树支持插入、删除、查找操作。查找包括完全匹配、前缀匹配、前驱查找、后继查找。所有这些操作都是O(k)复杂度，其中k是所有字符串中最大的长度。\n 内核基数树的使用 内核红黑树的实现称为 radix_tree，头文件为 include/linux/radix-tree.h。下面只介绍几个基本的 API 和相关实现。\n基数树的创建 最简单的方式，直接使用宏创建：\n1  RADIX_TREE(name, gfp_mask);   或者，也可以手工创建：\n1 2  struct radix_tree_root tree; INIT_RADIX_TREE(\u0026tree, gfp_mask);   基数树的查找 1  void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index);   该函数在以 root 为根的基数树中查找索引为 index 的内容，返回查找的内容的地址（没找到要查找的内容则返回 NULL）。\n1  unsigned int radix_tree_gang_lookup(struct radix_tree_root *root, void **results, unsigned long first_index, unsigned int max_items);   该函数在以 root 为根的基数树中查找非空内容，从索引为 first_index 的结点开始，最多查找 max_items 个非空内容，查找结果放 results 中，返回找到的个数。\n基数树的插入 1  int radix_tree_insert(struct radix_tree_root *root, unsigned long index, void *item);   该函数将内容 item 插入到以 root 为根的基数树中索引为 index 的地方，插入成功返回 0，失败返回错误值。\n基数树的删除 1  void *radix_tree_delete(struct radix_tree_root *root, unsigned long index);   该函数将索引为 index 的内容从以 root 为根的基数树中删除，返回删除的内容的地址（要删除的内容不存在则返回 NULL）。\n内核基数树的的实现 内核基数树的实现均位于 lib/radix-tree.c 和 include/linux/radix-tree.h。我只求会用 API，具体实现的原理要参考数据结构书籍，下面也只贴出部分核心代码。\n基数树的定义 根的定义如下：\n1 2 3 4 5 6  /* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */ struct radix_tree_root { unsigned int height; gfp_t gfp_mask; struct radix_tree_node *rnode; };   结点的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define RADIX_TREE_MAX_TAGS 2  #ifdef __KERNEL__ #define RADIX_TREE_MAP_SHIFT (CONFIG_BASE_SMALL ? 4 : 6) #else #define RADIX_TREE_MAP_SHIFT 3 /* For more stressful testing */#endif  #define RADIX_TREE_MAP_SIZE (1UL  #define RADIX_TREE_TAG_LONGS \\ ((RADIX_TREE_MAP_SIZE + BITS_PER_LONG - 1) / BITS_PER_LONG)  struct radix_tree_node { unsigned int height; /* Height from the bottom */ unsigned int count; struct rcu_head rcu_head; void *slots[RADIX_TREE_MAP_SIZE]; unsigned long tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS]; };   其中，BITS_PER_LONG 是体系结构相关的，指该体系结构下 long 占多少位，该宏在 32 位系统下通常是 32，64 位系统下通常是 64。\n基数树创建的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #define RADIX_TREE_INIT(mask) { \\ .height = 0, \\ .gfp_mask = (mask), \\ .rnode = NULL, \\ }  #define RADIX_TREE(name, mask) \\ struct radix_tree_root name = RADIX_TREE_INIT(mask)  #define INIT_RADIX_TREE(root, mask) \\ do { \\ (root)-height = 0; \\ (root)-gfp_mask = (mask); \\ (root)-rnode = NULL; \\ } while (0)   辅助函数/宏的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define RADIX_TREE_INDIRECT_PTR 1  static inline void *radix_tree_indirect_to_ptr(void *ptr) { return (void *)((unsigned long)ptr \u0026 ~RADIX_TREE_INDIRECT_PTR); } static inline int radix_tree_is_indirect_ptr(void *ptr) { return (int)((unsigned long)ptr \u0026 RADIX_TREE_INDIRECT_PTR); } /* * Return the maximum key which can be store into a * radix tree with height HEIGHT. */ static inline unsigned long radix_tree_maxindex(unsigned int height) { return height_to_maxindex[height]; }   对于前两个函数，由于地址总是对齐的，不管哪种体系结构，地址的最后一位总是 0。所以可以利用这一位，存储该结点是直接结点（指针直接指向内容）还是间接结点（指针指向其他树的结点）。\n基数树的查找的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  #define RADIX_TREE_MAP_MASK (RADIX_TREE_MAP_SIZE-1)  /* * is_slot == 1 : search for the slot. * is_slot == 0 : search for the node. */ static void *radix_tree_lookup_element(struct radix_tree_root *root, unsigned long index, int is_slot) { unsigned int height, shift; struct radix_tree_node *node, **slot; node = rcu_dereference_raw(root-rnode); if (node == NULL) return NULL; if (!radix_tree_is_indirect_ptr(node)) { if (index  0) return NULL; return is_slot ? (void *)\u0026root-rnode : node; } node = radix_tree_indirect_to_ptr(node); height = node-height; if (index  radix_tree_maxindex(height)) return NULL; shift = (height-1) * RADIX_TREE_MAP_SHIFT; do { slot = (struct radix_tree_node **) (node-slots + ((indexshift) \u0026 RADIX_TREE_MAP_MASK)); node = rcu_dereference_raw(*slot); if (node == NULL) return NULL; shift -= RADIX_TREE_MAP_SHIFT; height--; } while (height  0); return is_slot ? (void *)slot:node; } /** * radix_tree_lookup - perform lookup operation on a radix tree * @root: radix tree root * @index: index key * * Lookup the item at the position @index in the radix tree @root. * * This function can be called under rcu_read_lock, however the caller * must manage lifetimes of leaf nodes (eg. RCU may also be used to free * them safely). No RCU barriers are required to access or modify the * returned item, however. */ void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index) { return radix_tree_lookup_element(root, index, 0); } EXPORT_SYMBOL(radix_tree_lookup);   radix_tree_lookup() 用于查找单个内容，RCU 相关的内容还没看，这里先无视（见 TODO 列表）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  static unsigned int __lookup(struct radix_tree_node *slot, void ***results, unsigned long index, unsigned int max_items, unsigned long *next_index) { unsigned int nr_found = 0; unsigned int shift, height; unsigned long i; height = slot-height; if (height == 0) goto out; shift = (height-1) * RADIX_TREE_MAP_SHIFT; for ( ; height  1; height--) { i = (index  shift) \u0026 RADIX_TREE_MAP_MASK; for (;;) { if (slot-slots[i] != NULL) break; index \u0026= ~((1UL  shift) - 1); index += 1UL  shift; if (index == 0) goto out; /* 32-bit wraparound */ i++; if (i == RADIX_TREE_MAP_SIZE) goto out; } shift -= RADIX_TREE_MAP_SHIFT; slot = rcu_dereference_raw(slot-slots[i]); if (slot == NULL) goto out; } /* Bottom level: grab some items */ for (i = index \u0026 RADIX_TREE_MAP_MASK; i  RADIX_TREE_MAP_SIZE; i++) { index++; if (slot-slots[i]) { results[nr_found++] = \u0026(slot-slots[i]); if (nr_found == max_items) goto out; } } out: *next_index = index; return nr_found; } /** * radix_tree_gang_lookup - perform multiple lookup on a radix tree * @root: radix tree root * @results: where the results of the lookup are placed * @first_index: start the lookup from this key * @max_items: place up to this many items at *results * * Performs an index-ascending scan of the tree for present items. Places * them at *@results and returns the number of items which were placed at * *@results. * * The implementation is naive. * * Like radix_tree_lookup, radix_tree_gang_lookup may be called under * rcu_read_lock. In this case, rather than the returned results being * an atomic snapshot of the tree at a single point in time, the semantics * of an RCU protected gang lookup are as though multiple radix_tree_lookups * have been issued in individual locks, and results stored in 'results'. */ unsigned int radix_tree_gang_lookup(struct radix_tree_root *root, void **results, unsigned long first_index, unsigned int max_items) { unsigned long max_index; struct radix_tree_node *node; unsigned long cur_index = first_index; unsigned int ret; node = rcu_dereference_raw(root-rnode); if (!node) return 0; if (!radix_tree_is_indirect_ptr(node)) { if (first_index  0) return 0; results[0] = node; return 1; } node = radix_tree_indirect_to_ptr(node); max_index = radix_tree_maxindex(node-height); ret = 0; while (ret  max_items) { unsigned int nr_found, slots_found, i; unsigned long next_index; /* Index of next search */ if (cur_index  max_index) break; slots_found = __lookup(node, (void ***)results + ret, cur_index, max_items - ret, \u0026next_index); nr_found = 0; for (i = 0; i  slots_found; i++) { struct radix_tree_node *slot; slot = *(((void ***)results)[ret + i]); if (!slot) continue; results[ret + nr_found] = rcu_dereference_raw(slot); nr_found++; } ret += nr_found; if (next_index == 0) break; cur_index = next_index; } return ret; } EXPORT_SYMBOL(radix_tree_gang_lookup);   radix_tree_gang_lookup() 用于查找多个内容。\n其他查找函数都是同理，只是查找的东西，比如查找 slot 和 tag 等。\n基数树的插入的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  static inline gfp_t root_gfp_mask(struct radix_tree_root *root) { return root-gfp_mask \u0026 __GFP_BITS_MASK; } /* * This assumes that the caller has performed appropriate preallocation, and * that the caller has pinned this thread of control to the current CPU. */ static struct radix_tree_node * radix_tree_node_alloc(struct radix_tree_root *root) { struct radix_tree_node *ret = NULL; gfp_t gfp_mask = root_gfp_mask(root); if (!(gfp_mask \u0026 __GFP_WAIT)) { struct radix_tree_preload *rtp; /* * Provided the caller has preloaded here, we will always * succeed in getting a node here (and never reach * kmem_cache_alloc) */ rtp = \u0026__get_cpu_var(radix_tree_preloads); if (rtp-nr) { ret = rtp-nodes[rtp-nr - 1]; rtp-nodes[rtp-nr - 1] = NULL; rtp-nr--; } } if (ret == NULL) ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask); BUG_ON(radix_tree_is_indirect_ptr(ret)); return ret; } /* * Extend a radix tree so it can store key @index. */ static int radix_tree_extend(struct radix_tree_root *root, unsigned long index) { struct radix_tree_node *node; unsigned int height; int tag; /* Figure out what the height should be. */ height = root-height + 1; while (index  radix_tree_maxindex(height)) height++; if (root-rnode == NULL) { root-height = height; goto out; } do { unsigned int newheight; if (!(node = radix_tree_node_alloc(root))) return -ENOMEM; /* Increase the height. */ node-slots[0] = radix_tree_indirect_to_ptr(root-rnode); /* Propagate the aggregated tag info into the new root */ for (tag = 0; tag  RADIX_TREE_MAX_TAGS; tag++) { if (root_tag_get(root, tag)) tag_set(node, tag, 0); } newheight = root-height+1; node-height = newheight; node-count = 1; node = radix_tree_ptr_to_indirect(node); rcu_assign_pointer(root-rnode, node); root-height = newheight; } while (height  root-height); out: return 0; } /** * radix_tree_insert - insert into a radix tree * @root: radix tree root * @index: index key * @item: item to insert * * Insert an item into the radix tree at position @index. */ int radix_tree_insert(struct radix_tree_root *root, unsigned long index, void *item) { struct radix_tree_node *node = NULL, *slot; unsigned int height, shift; int offset; int error; BUG_ON(radix_tree_is_indirect_ptr(item)); /* Make sure the tree is high enough. */ if (index  radix_tree_maxindex(root-height)) { error = radix_tree_extend(root, index); if (error) return error; } slot = radix_tree_indirect_to_ptr(root-rnode); height = root-height; shift = (height-1) * RADIX_TREE_MAP_SHIFT; offset = 0; /* uninitialised var warning */ while (height  0) { if (slot == NULL) { /* Have to add a child node. */ if (!(slot = radix_tree_node_alloc(root))) return -ENOMEM; slot-height = height; if (node) { rcu_assign_pointer(node-slots[offset], slot); node-count++; } else rcu_assign_pointer(root-rnode, radix_tree_ptr_to_indirect(slot)); } /* Go a level down */ offset = (index  shift) \u0026 RADIX_TREE_MAP_MASK; node = slot; slot = node-slots[offset]; shift -= RADIX_TREE_MAP_SHIFT; height--; } if (slot != NULL) return -EEXIST; if (node) { node-count++; rcu_assign_pointer(node-slots[offset], item); BUG_ON(tag_get(node, 0, offset)); BUG_ON(tag_get(node, 1, offset)); } else { rcu_assign_pointer(root-rnode, item); BUG_ON(root_tag_get(root, 0)); BUG_ON(root_tag_get(root, 1)); } return 0; } EXPORT_SYMBOL(radix_tree_insert);   基数树的删除的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  /** * radix_tree_shrink - shrink height of a radix tree to minimal * @root radix tree root */ static inline void radix_tree_shrink(struct radix_tree_root *root) { /* try to shrink tree height */ while (root-height  0) { struct radix_tree_node *to_free = root-rnode; void *newptr; BUG_ON(!radix_tree_is_indirect_ptr(to_free)); to_free = radix_tree_indirect_to_ptr(to_free); /* * The candidate node has more than one child, or its child * is not at the leftmost slot, we cannot shrink. */ if (to_free-count != 1) break; if (!to_free-slots[0]) break; /* * We don't need rcu_assign_pointer(), since we are simply * moving the node from one part of the tree to another. If * it was safe to dereference the old pointer to it * (to_free-slots[0]), it will be safe to dereference the new * one (root-rnode). */ newptr = to_free-slots[0]; if (root-height  1) newptr = radix_tree_ptr_to_indirect(newptr); root-rnode = newptr; root-height--; radix_tree_node_free(to_free); } } static inline void radix_tree_node_free(struct radix_tree_node *node) { call_rcu(\u0026node-rcu_head, radix_tree_node_rcu_free); } /** * radix_tree_delete - delete an item from a radix tree * @root: radix tree root * @index: index key * * Remove the item at @index from the radix tree rooted at @root. * * Returns the address of the deleted item, or NULL if it was not present. */ void *radix_tree_delete(struct radix_tree_root *root, unsigned long index) { /* * The radix tree path needs to be one longer than the maximum path * since the \"list\" is null terminated. */ struct radix_tree_path path[RADIX_TREE_MAX_PATH + 1], *pathp = path; struct radix_tree_node *slot = NULL; struct radix_tree_node *to_free; unsigned int height, shift; int tag; int offset; height = root-height; if (index  radix_tree_maxindex(height)) goto out; slot = root-rnode; if (height == 0) { root_tag_clear_all(root); root-rnode = NULL; goto out; } slot = radix_tree_indirect_to_ptr(slot); shift = (height - 1) * RADIX_TREE_MAP_SHIFT; pathp-node = NULL; do { if (slot == NULL) goto out; pathp++; offset = (index  shift) \u0026 RADIX_TREE_MAP_MASK; pathp-offset = offset; pathp-node = slot; slot = slot-slots[offset]; shift -= RADIX_TREE_MAP_SHIFT; height--; } while (height  0); if (slot == NULL) goto out; /* * Clear all tags associated with the just-deleted item */ for (tag = 0; tag  RADIX_TREE_MAX_TAGS; tag++) { if (tag_get(pathp-node, tag, pathp-offset)) radix_tree_tag_clear(root, index, tag); } to_free = NULL; /* Now free the nodes we do not need anymore */ while (pathp-node) { pathp-node-slots[pathp-offset] = NULL; pathp-node-count--; /* * Queue the node for deferred freeing after the * last reference to it disappears (set NULL, above). */ if (to_free) radix_tree_node_free(to_free); if (pathp-node-count) { if (pathp-node == radix_tree_indirect_to_ptr(root-rnode)) radix_tree_shrink(root); goto out; } /* Node with zero slots in use so free it */ to_free = pathp-node; pathp--; } root_tag_clear_all(root); root-height = 0; root-rnode = NULL; if (to_free) radix_tree_node_free(to_free); out: return slot; } EXPORT_SYMBOL(radix_tree_delete);   ","wordCount":"2409","inLanguage":"zh-cn","datePublished":"2021-04-28T00:00:00Z","dateModified":"2021-04-28T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/kernel/data-structure/radix-tree/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>内核基数树</h1><div class=post-meta>April 28, 2021&nbsp;·&nbsp;12 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%ae%80%e4%bb%8b aria-label=基数树简介>基数树简介</a><ul><li><a href=#%e5%89%8d%e7%bc%80%e6%a0%91%e5%ad%97%e5%85%b8%e6%a0%91 aria-label=前缀树（字典树）>前缀树（字典树）</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91 aria-label=基数树>基数树</a></li></ul></li><li><a href=#%e5%86%85%e6%a0%b8%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=内核基数树的使用>内核基数树的使用</a><ul><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e5%88%9b%e5%bb%ba aria-label=基数树的创建>基数树的创建</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e6%9f%a5%e6%89%be aria-label=基数树的查找>基数树的查找</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e6%8f%92%e5%85%a5 aria-label=基数树的插入>基数树的插入</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4 aria-label=基数树的删除>基数树的删除</a></li></ul></li><li><a href=#%e5%86%85%e6%a0%b8%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=内核基数树的的实现>内核基数树的的实现</a><ul><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=基数树的定义>基数树的定义</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e5%88%9b%e5%bb%ba%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=基数树创建的实现>基数树创建的实现</a></li><li><a href=#%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0%e5%ae%8f%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=辅助函数/宏的实现>辅助函数/宏的实现</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e6%9f%a5%e6%89%be%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=基数树的查找的实现>基数树的查找的实现</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e6%8f%92%e5%85%a5%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=基数树的插入的实现>基数树的插入的实现</a></li><li><a href=#%e5%9f%ba%e6%95%b0%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=基数树的删除的实现>基数树的删除的实现</a></li></ul></li></ul></div></details></div><div class=post-content><p><a href=/posts/kernel/kernel>Linux 内核学习笔记系列</a>，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。</p><h2 id=基数树简介>基数树简介<a hidden class=anchor aria-hidden=true href=#基数树简介>#</a></h2><h3 id=前缀树字典树>前缀树（字典树）<a hidden class=anchor aria-hidden=true href=#前缀树字典树>#</a></h3><p>该部分内容来源于<a href=https://zh.wikipedia.org/wiki/Trie>维基百科</a>。</p><blockquote><p>在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p>在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。</p><p>键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。</p><p>trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串比特，可以用于表示整数或者内存地址。</p></blockquote><p><img loading=lazy src=/images/kernel/data-structure/trie.png alt=前缀树（字典树）></p><h3 id=基数树>基数树<a hidden class=anchor aria-hidden=true href=#基数树>#</a></h3><p>该部分内容来源于<a href=https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%A0%91>维基百科</a>。</p><blockquote><p>在计算机科学中，基数树（也叫基数特里树或压缩前缀树）是一种数据结构，是一种更节省空间的Trie（前缀树），其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。因此每个内部节点的子节点数最多为基数树的基数r ，其中r为正整数，x为2的幂，x≥1，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。</p></blockquote><p><img loading=lazy src=/images/kernel/data-structure/patricia_trie.png alt=基数树></p><blockquote><p>基数树支持插入、删除、查找操作。查找包括完全匹配、前缀匹配、前驱查找、后继查找。所有这些操作都是O(k)复杂度，其中k是所有字符串中最大的长度。</p></blockquote><h2 id=内核基数树的使用>内核基数树的使用<a hidden class=anchor aria-hidden=true href=#内核基数树的使用>#</a></h2><p>内核红黑树的实现称为 <code>radix_tree</code>，头文件为 <code>include/linux/radix-tree.h</code>。下面只介绍几个基本的 API 和相关实现。</p><h3 id=基数树的创建>基数树的创建<a hidden class=anchor aria-hidden=true href=#基数树的创建>#</a></h3><p>最简单的方式，直接使用宏创建：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>RADIX_TREE(name, gfp_mask);
</code></pre></td></tr></table></div></div><p>或者，也可以手工创建：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> radix_tree_root tree;
INIT_RADIX_TREE(<span style=color:#f92672>&amp;</span>tree, gfp_mask);
</code></pre></td></tr></table></div></div><h3 id=基数树的查找>基数树的查找<a hidden class=anchor aria-hidden=true href=#基数树的查找>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radix_tree_lookup</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index);
</code></pre></td></tr></table></div></div><p>该函数在以 <code>root</code> 为根的基数树中查找索引为 <code>index</code> 的内容，返回查找的内容的地址（没找到要查找的内容则返回 <code>NULL</code>）。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>radix_tree_gang_lookup</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>results, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> first_index, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> max_items);
</code></pre></td></tr></table></div></div><p>该函数在以 <code>root</code> 为根的基数树中查找非空内容，从索引为 <code>first_index</code> 的结点开始，最多查找 <code>max_items</code> 个非空内容，查找结果放 <code>results</code> 中，返回找到的个数。</p><h3 id=基数树的插入>基数树的插入<a hidden class=anchor aria-hidden=true href=#基数树的插入>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>radix_tree_insert</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>item);
</code></pre></td></tr></table></div></div><p>该函数将内容 <code>item</code> 插入到以 <code>root</code> 为根的基数树中索引为 <code>index</code> 的地方，插入成功返回 <code>0</code>，失败返回错误值。</p><h3 id=基数树的删除>基数树的删除<a hidden class=anchor aria-hidden=true href=#基数树的删除>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radix_tree_delete</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index);
</code></pre></td></tr></table></div></div><p>该函数将索引为 <code>index</code> 的内容从以 <code>root</code> 为根的基数树中删除，返回删除的内容的地址（要删除的内容不存在则返回 <code>NULL</code>）。</p><h2 id=内核基数树的的实现>内核基数树的的实现<a hidden class=anchor aria-hidden=true href=#内核基数树的的实现>#</a></h2><p>内核基数树的实现均位于 <code>lib/radix-tree.c</code> 和 <code>include/linux/radix-tree.h</code>。我只求会用 API，具体实现的原理要参考数据结构书籍，下面也只贴出部分核心代码。</p><h3 id=基数树的定义>基数树的定义<a hidden class=anchor aria-hidden=true href=#基数树的定义>#</a></h3><p><img loading=lazy src=/images/kernel/data-structure/radix-tree.png alt=内核基数树示例></p><p>根的定义如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */</span>
<span style=color:#66d9ef>struct</span> radix_tree_root {
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            height;
    gfp_t                   gfp_mask;
    <span style=color:#66d9ef>struct</span> radix_tree_node  <span style=color:#f92672>*</span>rnode;
};
</code></pre></td></tr></table></div></div><p>结点的定义如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define RADIX_TREE_MAX_TAGS 2
</span><span style=color:#75715e></span>
<span style=color:#75715e>#ifdef __KERNEL__
</span><span style=color:#75715e>#define RADIX_TREE_MAP_SHIFT (CONFIG_BASE_SMALL ? 4 : 6)
</span><span style=color:#75715e>#else
</span><span style=color:#75715e>#define RADIX_TREE_MAP_SHIFT 3 </span><span style=color:#75715e>/* For more stressful testing */</span><span style=color:#75715e>
</span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define RADIX_TREE_MAP_SIZE (1UL &lt;&lt; RADIX_TREE_MAP_SHIFT)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define RADIX_TREE_TAG_LONGS \
</span><span style=color:#75715e>        ((RADIX_TREE_MAP_SIZE + BITS_PER_LONG - 1) / BITS_PER_LONG)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> radix_tree_node {
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            height; <span style=color:#75715e>/* Height from the bottom */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            count;
    <span style=color:#66d9ef>struct</span> rcu_head         rcu_head;
    <span style=color:#66d9ef>void</span>                    <span style=color:#f92672>*</span>slots[RADIX_TREE_MAP_SIZE];
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];
};
</code></pre></td></tr></table></div></div><p>其中，<code>BITS_PER_LONG</code> 是体系结构相关的，指该体系结构下 <code>long</code> 占多少位，该宏在 32 位系统下通常是 <code>32</code>，64 位系统下通常是 <code>64</code>。</p><h3 id=基数树创建的实现>基数树创建的实现<a hidden class=anchor aria-hidden=true href=#基数树创建的实现>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define RADIX_TREE_INIT(mask)   {           \
</span><span style=color:#75715e>    .height = 0,                            \
</span><span style=color:#75715e>    .gfp_mask = (mask),                     \
</span><span style=color:#75715e>    .rnode = NULL,                          \
</span><span style=color:#75715e>}
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define RADIX_TREE(name, mask) \
</span><span style=color:#75715e>    struct radix_tree_root name = RADIX_TREE_INIT(mask)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define INIT_RADIX_TREE(root, mask)         \
</span><span style=color:#75715e>do {                                        \
</span><span style=color:#75715e>    (root)-&gt;height = 0;                     \
</span><span style=color:#75715e>    (root)-&gt;gfp_mask = (mask);              \
</span><span style=color:#75715e>    (root)-&gt;rnode = NULL;                   \
</span><span style=color:#75715e>} while (0)
</span></code></pre></td></tr></table></div></div><h3 id=辅助函数宏的实现>辅助函数/宏的实现<a hidden class=anchor aria-hidden=true href=#辅助函数宏的实现>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define RADIX_TREE_INDIRECT_PTR 1
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radix_tree_indirect_to_ptr</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr)
{
    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)ptr <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>RADIX_TREE_INDIRECT_PTR);
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>radix_tree_is_indirect_ptr</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr)
{
    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>int</span>)((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)ptr <span style=color:#f92672>&amp;</span> RADIX_TREE_INDIRECT_PTR);
}

<span style=color:#75715e>/*
</span><span style=color:#75715e> *  Return the maximum key which can be store into a
</span><span style=color:#75715e> *  radix tree with height HEIGHT.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>radix_tree_maxindex</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> height)
{
    <span style=color:#66d9ef>return</span> height_to_maxindex[height];
}
</code></pre></td></tr></table></div></div><p>对于前两个函数，由于地址总是对齐的，不管哪种体系结构，地址的最后一位总是 <code>0</code>。所以可以利用这一位，存储该结点是直接结点（指针直接指向内容）还是间接结点（指针指向其他树的结点）。</p><h3 id=基数树的查找的实现>基数树的查找的实现<a hidden class=anchor aria-hidden=true href=#基数树的查找的实现>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define RADIX_TREE_MAP_MASK (RADIX_TREE_MAP_SIZE-1)
</span><span style=color:#75715e></span>
<span style=color:#75715e>/*
</span><span style=color:#75715e> * is_slot == 1 : search for the slot.
</span><span style=color:#75715e> * is_slot == 0 : search for the node.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radix_tree_lookup_element</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root,
                                       <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index, <span style=color:#66d9ef>int</span> is_slot)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> height, shift;
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>node, <span style=color:#f92672>**</span>slot;

    node <span style=color:#f92672>=</span> rcu_dereference_raw(root<span style=color:#f92672>-&gt;</span>rnode);
    <span style=color:#66d9ef>if</span> (node <span style=color:#f92672>==</span> NULL)
        <span style=color:#66d9ef>return</span> NULL;

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>radix_tree_is_indirect_ptr(node)) {
        <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> NULL;
        <span style=color:#66d9ef>return</span> is_slot <span style=color:#f92672>?</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>root<span style=color:#f92672>-&gt;</span>rnode : node;
    }
    node <span style=color:#f92672>=</span> radix_tree_indirect_to_ptr(node);

    height <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>height;
    <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;</span> radix_tree_maxindex(height))
        <span style=color:#66d9ef>return</span> NULL;

    shift <span style=color:#f92672>=</span> (height<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> RADIX_TREE_MAP_SHIFT;

    <span style=color:#66d9ef>do</span> {
        slot <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>**</span>)
            (node<span style=color:#f92672>-&gt;</span>slots <span style=color:#f92672>+</span> ((index<span style=color:#f92672>&gt;&gt;</span>shift) <span style=color:#f92672>&amp;</span> RADIX_TREE_MAP_MASK));
        node <span style=color:#f92672>=</span> rcu_dereference_raw(<span style=color:#f92672>*</span>slot);
        <span style=color:#66d9ef>if</span> (node <span style=color:#f92672>==</span> NULL)
            <span style=color:#66d9ef>return</span> NULL;

        shift <span style=color:#f92672>-=</span> RADIX_TREE_MAP_SHIFT;
        height<span style=color:#f92672>--</span>;
    } <span style=color:#66d9ef>while</span> (height <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);

    <span style=color:#66d9ef>return</span> is_slot <span style=color:#f92672>?</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)slot:node;
}

<span style=color:#75715e>/**
</span><span style=color:#75715e> *  radix_tree_lookup    -    perform lookup operation on a radix tree
</span><span style=color:#75715e> *  @root:          radix tree root
</span><span style=color:#75715e> *  @index:         index key
</span><span style=color:#75715e> *  
</span><span style=color:#75715e> *  Lookup the item at the position @index in the radix tree @root.
</span><span style=color:#75715e> *  
</span><span style=color:#75715e> *  This function can be called under rcu_read_lock, however the caller
</span><span style=color:#75715e> *  must manage lifetimes of leaf nodes (eg. RCU may also be used to free
</span><span style=color:#75715e> *  them safely). No RCU barriers are required to access or modify the
</span><span style=color:#75715e> *  returned item, however.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radix_tree_lookup</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index)
{
    <span style=color:#66d9ef>return</span> radix_tree_lookup_element(root, index, <span style=color:#ae81ff>0</span>);
}
EXPORT_SYMBOL(radix_tree_lookup);
</code></pre></td></tr></table></div></div><p><code>radix_tree_lookup()</code> 用于查找单个内容，RCU 相关的内容还没看，这里先无视（见 <a href=/posts/kernel/todo>TODO 列表</a>）。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">104
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">105
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">106
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">107
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">108
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">109
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">110
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">111
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">112
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">113
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">114
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">115
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">116
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>__lookup</span>(<span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>slot, <span style=color:#66d9ef>void</span> <span style=color:#f92672>***</span>results, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index,
         <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> max_items, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>next_index)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> nr_found <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> shift, height;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> i;

    height <span style=color:#f92672>=</span> slot<span style=color:#f92672>-&gt;</span>height;
    <span style=color:#66d9ef>if</span> (height <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
        <span style=color:#66d9ef>goto</span> out;
    shift <span style=color:#f92672>=</span> (height<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> RADIX_TREE_MAP_SHIFT;

    <span style=color:#66d9ef>for</span> ( ; height <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>; height<span style=color:#f92672>--</span>) {
        i <span style=color:#f92672>=</span> (index <span style=color:#f92672>&gt;&gt;</span> shift) <span style=color:#f92672>&amp;</span> RADIX_TREE_MAP_MASK;
        <span style=color:#66d9ef>for</span> (;;) {
            <span style=color:#66d9ef>if</span> (slot<span style=color:#f92672>-&gt;</span>slots[i] <span style=color:#f92672>!=</span> NULL)
                <span style=color:#66d9ef>break</span>;
            index <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>((<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> shift) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
            index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> shift;
            <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
                <span style=color:#66d9ef>goto</span> out;   <span style=color:#75715e>/* 32-bit wraparound */</span>
            i<span style=color:#f92672>++</span>;
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> RADIX_TREE_MAP_SIZE)
                <span style=color:#66d9ef>goto</span> out;
        }

        shift <span style=color:#f92672>-=</span> RADIX_TREE_MAP_SHIFT;
        slot <span style=color:#f92672>=</span> rcu_dereference_raw(slot<span style=color:#f92672>-&gt;</span>slots[i]);
        <span style=color:#66d9ef>if</span> (slot <span style=color:#f92672>==</span> NULL)
            <span style=color:#66d9ef>goto</span> out;
    }

    <span style=color:#75715e>/* Bottom level: grab some items */</span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> index <span style=color:#f92672>&amp;</span> RADIX_TREE_MAP_MASK; i <span style=color:#f92672>&lt;</span> RADIX_TREE_MAP_SIZE; i<span style=color:#f92672>++</span>) {
        index<span style=color:#f92672>++</span>;
        <span style=color:#66d9ef>if</span> (slot<span style=color:#f92672>-&gt;</span>slots[i]) {
            results[nr_found<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(slot<span style=color:#f92672>-&gt;</span>slots[i]);
            <span style=color:#66d9ef>if</span> (nr_found <span style=color:#f92672>==</span> max_items)
                <span style=color:#66d9ef>goto</span> out;
        }
    }
out:
    <span style=color:#f92672>*</span>next_index <span style=color:#f92672>=</span> index;
    <span style=color:#66d9ef>return</span> nr_found;
}

<span style=color:#75715e>/**
</span><span style=color:#75715e> *  radix_tree_gang_lookup - perform multiple lookup on a radix tree
</span><span style=color:#75715e> *  @root:          radix tree root
</span><span style=color:#75715e> *  @results:       where the results of the lookup are placed
</span><span style=color:#75715e> *  @first_index:   start the lookup from this key
</span><span style=color:#75715e> *  @max_items:     place up to this many items at *results
</span><span style=color:#75715e> *  
</span><span style=color:#75715e> *  Performs an index-ascending scan of the tree for present items.  Places
</span><span style=color:#75715e> *  them at *@results and returns the number of items which were placed at
</span><span style=color:#75715e> *  *@results.
</span><span style=color:#75715e> *  
</span><span style=color:#75715e> *  The implementation is naive.
</span><span style=color:#75715e> *  
</span><span style=color:#75715e> *  Like radix_tree_lookup, radix_tree_gang_lookup may be called under
</span><span style=color:#75715e> *  rcu_read_lock. In this case, rather than the returned results being
</span><span style=color:#75715e> *  an atomic snapshot of the tree at a single point in time, the semantics
</span><span style=color:#75715e> *  of an RCU protected gang lookup are as though multiple radix_tree_lookups
</span><span style=color:#75715e> *  have been issued in individual locks, and results stored in &#39;results&#39;.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>radix_tree_gang_lookup</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>results,
            <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> first_index, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> max_items)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> max_index;
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>node;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> cur_index <span style=color:#f92672>=</span> first_index;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ret;

    node <span style=color:#f92672>=</span> rcu_dereference_raw(root<span style=color:#f92672>-&gt;</span>rnode);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node)
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>radix_tree_is_indirect_ptr(node)) {
        <span style=color:#66d9ef>if</span> (first_index <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        results[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> node;
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
    }
    node <span style=color:#f92672>=</span> radix_tree_indirect_to_ptr(node);

    max_index <span style=color:#f92672>=</span> radix_tree_maxindex(node<span style=color:#f92672>-&gt;</span>height);

    ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span> (ret <span style=color:#f92672>&lt;</span> max_items) {
        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> nr_found, slots_found, i;
        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> next_index;   <span style=color:#75715e>/* Index of next search */</span>

        <span style=color:#66d9ef>if</span> (cur_index <span style=color:#f92672>&gt;</span> max_index)
            <span style=color:#66d9ef>break</span>;
        slots_found <span style=color:#f92672>=</span> __lookup(node, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>***</span>)results <span style=color:#f92672>+</span> ret, cur_index,
                    max_items <span style=color:#f92672>-</span> ret, <span style=color:#f92672>&amp;</span>next_index);
        nr_found <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> slots_found; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>slot;
            slot <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(((<span style=color:#66d9ef>void</span> <span style=color:#f92672>***</span>)results)[ret <span style=color:#f92672>+</span> i]);
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>slot)
                <span style=color:#66d9ef>continue</span>;
            results[ret <span style=color:#f92672>+</span> nr_found] <span style=color:#f92672>=</span> rcu_dereference_raw(slot);
            nr_found<span style=color:#f92672>++</span>;
        }
        ret <span style=color:#f92672>+=</span> nr_found;
        <span style=color:#66d9ef>if</span> (next_index <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>break</span>;
        cur_index <span style=color:#f92672>=</span> next_index;
    }

    <span style=color:#66d9ef>return</span> ret;
}
EXPORT_SYMBOL(radix_tree_gang_lookup);
</code></pre></td></tr></table></div></div><p><code>radix_tree_gang_lookup()</code> 用于查找多个内容。</p><p>其他查找函数都是同理，只是查找的东西，比如查找 slot 和 tag 等。</p><h3 id=基数树的插入的实现>基数树的插入的实现<a hidden class=anchor aria-hidden=true href=#基数树的插入的实现>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">104
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">105
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">106
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">107
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">108
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">109
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">110
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">111
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">112
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">113
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">114
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">115
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">116
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">117
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">118
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">119
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">120
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">121
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">122
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">123
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">124
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">125
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">126
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">127
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">128
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">129
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">130
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">131
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">132
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">133
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">134
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">135
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">136
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">137
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">138
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">139
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">140
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">141
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">142
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">143
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">144
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">145
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">146
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">147
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">148
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">149
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">151
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> gfp_t <span style=color:#a6e22e>root_gfp_mask</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root)
{
    <span style=color:#66d9ef>return</span> root<span style=color:#f92672>-&gt;</span>gfp_mask <span style=color:#f92672>&amp;</span> __GFP_BITS_MASK;
}

<span style=color:#75715e>/*
</span><span style=color:#75715e> * This assumes that the caller has performed appropriate preallocation, and
</span><span style=color:#75715e> * that the caller has pinned this thread of control to the current CPU.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>
<span style=color:#a6e22e>radix_tree_node_alloc</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root)
{
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>ret <span style=color:#f92672>=</span> NULL;
    gfp_t gfp_mask <span style=color:#f92672>=</span> root_gfp_mask(root);

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(gfp_mask <span style=color:#f92672>&amp;</span> __GFP_WAIT)) {
        <span style=color:#66d9ef>struct</span> radix_tree_preload <span style=color:#f92672>*</span>rtp;

        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * Provided the caller has preloaded here, we will always
</span><span style=color:#75715e>         * succeed in getting a node here (and never reach
</span><span style=color:#75715e>         * kmem_cache_alloc)
</span><span style=color:#75715e>         */</span>
        rtp <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>__get_cpu_var(radix_tree_preloads);
        <span style=color:#66d9ef>if</span> (rtp<span style=color:#f92672>-&gt;</span>nr) {
            ret <span style=color:#f92672>=</span> rtp<span style=color:#f92672>-&gt;</span>nodes[rtp<span style=color:#f92672>-&gt;</span>nr <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
            rtp<span style=color:#f92672>-&gt;</span>nodes[rtp<span style=color:#f92672>-&gt;</span>nr <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> NULL;
            rtp<span style=color:#f92672>-&gt;</span>nr<span style=color:#f92672>--</span>;
        }
    }
    <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> NULL)
        ret <span style=color:#f92672>=</span> kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);

    BUG_ON(radix_tree_is_indirect_ptr(ret));
    <span style=color:#66d9ef>return</span> ret;
}

<span style=color:#75715e>/*
</span><span style=color:#75715e> *  Extend a radix tree so it can store key @index.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>radix_tree_extend</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index)
{
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>node;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> height;
    <span style=color:#66d9ef>int</span> tag;

    <span style=color:#75715e>/* Figure out what the height should be.  */</span>
    height <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>while</span> (index <span style=color:#f92672>&gt;</span> radix_tree_maxindex(height))
        height<span style=color:#f92672>++</span>;

    <span style=color:#66d9ef>if</span> (root<span style=color:#f92672>-&gt;</span>rnode <span style=color:#f92672>==</span> NULL) {
        root<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>=</span> height;
        <span style=color:#66d9ef>goto</span> out;
    }

    <span style=color:#66d9ef>do</span> {
        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> newheight;
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(node <span style=color:#f92672>=</span> radix_tree_node_alloc(root)))
            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;

        <span style=color:#75715e>/* Increase the height.  */</span>
        node<span style=color:#f92672>-&gt;</span>slots[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> radix_tree_indirect_to_ptr(root<span style=color:#f92672>-&gt;</span>rnode);

        <span style=color:#75715e>/* Propagate the aggregated tag info into the new root */</span>
        <span style=color:#66d9ef>for</span> (tag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; tag <span style=color:#f92672>&lt;</span> RADIX_TREE_MAX_TAGS; tag<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span> (root_tag_get(root, tag))
                tag_set(node, tag, <span style=color:#ae81ff>0</span>);
        }

        newheight <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>height<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
        node<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>=</span> newheight;
        node<span style=color:#f92672>-&gt;</span>count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        node <span style=color:#f92672>=</span> radix_tree_ptr_to_indirect(node);
        rcu_assign_pointer(root<span style=color:#f92672>-&gt;</span>rnode, node);
        root<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>=</span> newheight;
    } <span style=color:#66d9ef>while</span> (height <span style=color:#f92672>&gt;</span> root<span style=color:#f92672>-&gt;</span>height);
out:
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>/**
</span><span style=color:#75715e> *  radix_tree_insert    -    insert into a radix tree
</span><span style=color:#75715e> *  @root:          radix tree root
</span><span style=color:#75715e> *  @index:         index key
</span><span style=color:#75715e> *  @item:          item to insert
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> *  Insert an item into the radix tree at position @index.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>radix_tree_insert</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root,
            <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>item)
{
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> NULL, <span style=color:#f92672>*</span>slot;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> height, shift;
    <span style=color:#66d9ef>int</span> offset;
    <span style=color:#66d9ef>int</span> error;

    BUG_ON(radix_tree_is_indirect_ptr(item));

    <span style=color:#75715e>/* Make sure the tree is high enough.  */</span>
    <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;</span> radix_tree_maxindex(root<span style=color:#f92672>-&gt;</span>height)) {
        error <span style=color:#f92672>=</span> radix_tree_extend(root, index);
        <span style=color:#66d9ef>if</span> (error)
            <span style=color:#66d9ef>return</span> error;
    }

    slot <span style=color:#f92672>=</span> radix_tree_indirect_to_ptr(root<span style=color:#f92672>-&gt;</span>rnode);

    height <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>height;
    shift <span style=color:#f92672>=</span> (height<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> RADIX_TREE_MAP_SHIFT;

    offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;         <span style=color:#75715e>/* uninitialised var warning */</span>
    <span style=color:#66d9ef>while</span> (height <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#66d9ef>if</span> (slot <span style=color:#f92672>==</span> NULL) {
            <span style=color:#75715e>/* Have to add a child node.  */</span>
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(slot <span style=color:#f92672>=</span> radix_tree_node_alloc(root)))
                <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;
            slot<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>=</span> height;
            <span style=color:#66d9ef>if</span> (node) {
                rcu_assign_pointer(node<span style=color:#f92672>-&gt;</span>slots[offset], slot);
                node<span style=color:#f92672>-&gt;</span>count<span style=color:#f92672>++</span>;
            } <span style=color:#66d9ef>else</span>
                rcu_assign_pointer(root<span style=color:#f92672>-&gt;</span>rnode,
                    radix_tree_ptr_to_indirect(slot));
        }

        <span style=color:#75715e>/* Go a level down */</span>
        offset <span style=color:#f92672>=</span> (index <span style=color:#f92672>&gt;&gt;</span> shift) <span style=color:#f92672>&amp;</span> RADIX_TREE_MAP_MASK;
        node <span style=color:#f92672>=</span> slot;
        slot <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>slots[offset];
        shift <span style=color:#f92672>-=</span> RADIX_TREE_MAP_SHIFT;
        height<span style=color:#f92672>--</span>;
    }

    <span style=color:#66d9ef>if</span> (slot <span style=color:#f92672>!=</span> NULL)
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EEXIST;

    <span style=color:#66d9ef>if</span> (node) {
        node<span style=color:#f92672>-&gt;</span>count<span style=color:#f92672>++</span>;
        rcu_assign_pointer(node<span style=color:#f92672>-&gt;</span>slots[offset], item);
        BUG_ON(tag_get(node, <span style=color:#ae81ff>0</span>, offset));
        BUG_ON(tag_get(node, <span style=color:#ae81ff>1</span>, offset));
    } <span style=color:#66d9ef>else</span> {
        rcu_assign_pointer(root<span style=color:#f92672>-&gt;</span>rnode, item);
        BUG_ON(root_tag_get(root, <span style=color:#ae81ff>0</span>));
        BUG_ON(root_tag_get(root, <span style=color:#ae81ff>1</span>));
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
EXPORT_SYMBOL(radix_tree_insert);
</code></pre></td></tr></table></div></div><h3 id=基数树的删除的实现>基数树的删除的实现<a hidden class=anchor aria-hidden=true href=#基数树的删除的实现>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">104
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">105
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">106
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">107
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">108
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">109
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">110
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">111
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">112
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">113
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">114
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">115
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">116
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">117
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">118
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">119
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">120
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">121
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">122
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">123
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">124
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">125
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">126
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">127
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">128
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">129
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">130
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">131
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">132
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">133
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">134
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">135
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">136
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">137
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">138
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">139
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">140
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/**
</span><span style=color:#75715e> *  radix_tree_shrink    -    shrink height of a radix tree to minimal
</span><span style=color:#75715e> *  @root           radix tree root
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>radix_tree_shrink</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root)
{
    <span style=color:#75715e>/* try to shrink tree height */</span>
    <span style=color:#66d9ef>while</span> (root<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>to_free <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>rnode;
        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>newptr;

        BUG_ON(<span style=color:#f92672>!</span>radix_tree_is_indirect_ptr(to_free));
        to_free <span style=color:#f92672>=</span> radix_tree_indirect_to_ptr(to_free);

        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * The candidate node has more than one child, or its child
</span><span style=color:#75715e>         * is not at the leftmost slot, we cannot shrink.
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>if</span> (to_free<span style=color:#f92672>-&gt;</span>count <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>to_free<span style=color:#f92672>-&gt;</span>slots[<span style=color:#ae81ff>0</span>])
            <span style=color:#66d9ef>break</span>;

        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * We don&#39;t need rcu_assign_pointer(), since we are simply
</span><span style=color:#75715e>         * moving the node from one part of the tree to another. If
</span><span style=color:#75715e>         * it was safe to dereference the old pointer to it
</span><span style=color:#75715e>         * (to_free-&gt;slots[0]), it will be safe to dereference the new
</span><span style=color:#75715e>         * one (root-&gt;rnode).
</span><span style=color:#75715e>         */</span>
        newptr <span style=color:#f92672>=</span> to_free<span style=color:#f92672>-&gt;</span>slots[<span style=color:#ae81ff>0</span>];
        <span style=color:#66d9ef>if</span> (root<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>)
            newptr <span style=color:#f92672>=</span> radix_tree_ptr_to_indirect(newptr);
        root<span style=color:#f92672>-&gt;</span>rnode <span style=color:#f92672>=</span> newptr;
        root<span style=color:#f92672>-&gt;</span>height<span style=color:#f92672>--</span>;
        radix_tree_node_free(to_free);
    }
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span>
<span style=color:#a6e22e>radix_tree_node_free</span>(<span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>node)
{
    call_rcu(<span style=color:#f92672>&amp;</span>node<span style=color:#f92672>-&gt;</span>rcu_head, radix_tree_node_rcu_free);
}

<span style=color:#75715e>/**
</span><span style=color:#75715e> *  radix_tree_delete    -    delete an item from a radix tree
</span><span style=color:#75715e> *  @root:          radix tree root
</span><span style=color:#75715e> *  @index:         index key
</span><span style=color:#75715e> *
</span><span style=color:#75715e> *  Remove the item at @index from the radix tree rooted at @root.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> *  Returns the address of the deleted item, or NULL if it was not present.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>radix_tree_delete</span>(<span style=color:#66d9ef>struct</span> radix_tree_root <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> index)
{
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * The radix tree path needs to be one longer than the maximum path
</span><span style=color:#75715e>     * since the &#34;list&#34; is null terminated.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>struct</span> radix_tree_path path[RADIX_TREE_MAX_PATH <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], <span style=color:#f92672>*</span>pathp <span style=color:#f92672>=</span> path;
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>slot <span style=color:#f92672>=</span> NULL;
    <span style=color:#66d9ef>struct</span> radix_tree_node <span style=color:#f92672>*</span>to_free;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> height, shift;
    <span style=color:#66d9ef>int</span> tag;
    <span style=color:#66d9ef>int</span> offset;

    height <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>height;
    <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;</span> radix_tree_maxindex(height))
        <span style=color:#66d9ef>goto</span> out;

    slot <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>rnode;
    <span style=color:#66d9ef>if</span> (height <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
        root_tag_clear_all(root);
        root<span style=color:#f92672>-&gt;</span>rnode <span style=color:#f92672>=</span> NULL;
        <span style=color:#66d9ef>goto</span> out;
    }
    slot <span style=color:#f92672>=</span> radix_tree_indirect_to_ptr(slot);

    shift <span style=color:#f92672>=</span> (height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> RADIX_TREE_MAP_SHIFT;
    pathp<span style=color:#f92672>-&gt;</span>node <span style=color:#f92672>=</span> NULL;

    <span style=color:#66d9ef>do</span> {
        <span style=color:#66d9ef>if</span> (slot <span style=color:#f92672>==</span> NULL)
            <span style=color:#66d9ef>goto</span> out;

        pathp<span style=color:#f92672>++</span>;
        offset <span style=color:#f92672>=</span> (index <span style=color:#f92672>&gt;&gt;</span> shift) <span style=color:#f92672>&amp;</span> RADIX_TREE_MAP_MASK;
        pathp<span style=color:#f92672>-&gt;</span>offset <span style=color:#f92672>=</span> offset;
        pathp<span style=color:#f92672>-&gt;</span>node <span style=color:#f92672>=</span> slot;
        slot <span style=color:#f92672>=</span> slot<span style=color:#f92672>-&gt;</span>slots[offset];
        shift <span style=color:#f92672>-=</span> RADIX_TREE_MAP_SHIFT;
        height<span style=color:#f92672>--</span>;
    } <span style=color:#66d9ef>while</span> (height <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);

    <span style=color:#66d9ef>if</span> (slot <span style=color:#f92672>==</span> NULL)
        <span style=color:#66d9ef>goto</span> out;

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Clear all tags associated with the just-deleted item
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>for</span> (tag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; tag <span style=color:#f92672>&lt;</span> RADIX_TREE_MAX_TAGS; tag<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>if</span> (tag_get(pathp<span style=color:#f92672>-&gt;</span>node, tag, pathp<span style=color:#f92672>-&gt;</span>offset))
            radix_tree_tag_clear(root, index, tag);
    }

    to_free <span style=color:#f92672>=</span> NULL;
    <span style=color:#75715e>/* Now free the nodes we do not need anymore */</span>
    <span style=color:#66d9ef>while</span> (pathp<span style=color:#f92672>-&gt;</span>node) {
        pathp<span style=color:#f92672>-&gt;</span>node<span style=color:#f92672>-&gt;</span>slots[pathp<span style=color:#f92672>-&gt;</span>offset] <span style=color:#f92672>=</span> NULL;
        pathp<span style=color:#f92672>-&gt;</span>node<span style=color:#f92672>-&gt;</span>count<span style=color:#f92672>--</span>;
        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * Queue the node for deferred freeing after the
</span><span style=color:#75715e>         * last reference to it disappears (set NULL, above).
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>if</span> (to_free)
            radix_tree_node_free(to_free);

        <span style=color:#66d9ef>if</span> (pathp<span style=color:#f92672>-&gt;</span>node<span style=color:#f92672>-&gt;</span>count) {
            <span style=color:#66d9ef>if</span> (pathp<span style=color:#f92672>-&gt;</span>node <span style=color:#f92672>==</span>
                    radix_tree_indirect_to_ptr(root<span style=color:#f92672>-&gt;</span>rnode))
                radix_tree_shrink(root);
            <span style=color:#66d9ef>goto</span> out;
        }

        <span style=color:#75715e>/* Node with zero slots in use so free it */</span>
        to_free <span style=color:#f92672>=</span> pathp<span style=color:#f92672>-&gt;</span>node;
        pathp<span style=color:#f92672>--</span>;

    }
    root_tag_clear_all(root);
    root<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    root<span style=color:#f92672>-&gt;</span>rnode <span style=color:#f92672>=</span> NULL;
    <span style=color:#66d9ef>if</span> (to_free)
        radix_tree_node_free(to_free);

out:
    <span style=color:#66d9ef>return</span> slot;
}
EXPORT_SYMBOL(radix_tree_delete);
</code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/linux-%E5%86%85%E6%A0%B8/>Linux 内核</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>内核数据结构</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E9%93%BE%E8%A1%A8/>链表</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/tips/github/><span class=title>«</span><br><span>Github 模板</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/kernel/memory/map/><span class=title>»</span><br><span>内存映射</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>