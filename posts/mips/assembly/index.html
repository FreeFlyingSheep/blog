<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MIPS 汇编 | FreeFlyingSheep 的小站</title><meta name=keywords content="MIPS,汇编"><meta name=description content="根据 Programmed Introduction to MIPS Assembly Language 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/mips/assembly/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="MIPS 汇编"><meta property="og:description" content="根据 Programmed Introduction to MIPS Assembly Language 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/mips/assembly/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-10T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="MIPS 汇编"><meta name=twitter:description content="根据 Programmed Introduction to MIPS Assembly Language 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"MIPS 汇编","item":"https://freeflyingsheep.github.io/posts/mips/assembly/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIPS 汇编","name":"MIPS 汇编","description":"根据 Programmed Introduction to MIPS Assembly Language 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。\n","keywords":["MIPS","汇编"],"articleBody":"根据 Programmed Introduction to MIPS Assembly Language 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。\n寄存器 通用寄存器 MIPS 提供 32 个 32 位的通用寄存器。\n   寄存器 助记符 用途     $0 zero 常数零   $1 $at 汇编器保留   $2，$3 $v0，$v1 子程序返回值   $4-$7 $a0-$a3 子程序参数   $8-$15 $t0-$t7 临时寄存器（调用者保存）   $16-$23 $s0-$s7 保存寄存器（被调用者保存）   $24，$25 $t8，$t9 临时寄存器（调用者保存）   $26，$27 $k0，$k1 操作系统保留   $28 $gp 全局指针   $29 $sp 栈指针   $30 $fp 帧指针   $31 $ra 返回地址    特殊寄存器 MIPS 提供一对 32 位寄存器 hi 和 lo 来帮助完成乘法、除法运算。\n浮点寄存器 MIPS 有 32 个 32 位的浮点寄存器 $f0 – $f31。\n指令格式 R 型（用于寄存器）    字段名 op rs rt rd shamt funct     含义 操作码 第一个源操作数寄存器 第二个源操作数寄存器 目的寄存器 位移量 功能码   长度 6 5 5 5 5 6    由于 shamt 用 5 位表示，所以 $0 \\le$ shamt $I 型（用于立即数）    字段名 op rs rt immediate     含义 操作码 源操作数寄存器 目的寄存器 立即数   长度 6 5 5 16    由于 immediate 用 16 位表示，所以 $-2^{15} \\le$ immediate $注意，此处 rt 的含义与上面不同，且后面的指令如不注明，immediate 默认被符号扩展为 32 位！\nJ 型（用于分支和跳转）    字段名 op address     含义 操作码 地址   长度 6 26    特别的，对于条件分支指令，地址字段可能又被划分为了多个部分。\n基本汇编指令 算术运算指令 加法指令    指令格式 含义     addu rd,rs,rt rd = rs + rt（溢出时不产生异常）   add rd,rs,rt rd = rs + rt（溢出时产生异常）   addiu rt,rs,immediate rt = rs + immediate（溢出时不产生异常）   addi rt,rs,immediate rt = rs + immediate（溢出时产生异常）    注意，MIPS 只有 32 位算术运算，在高级语言中需要进行 16 位或 8 位算术运算时，编译器可能产生更多的指令来模拟这些运算，这意味这 32 位算术运算的速度往往会快于其他情况，而不是数据长度越短运算越快。\n减法指令    指令格式 含义     subu rd,rs,rt d = rs-rt（溢出时不产生异常）   sub rd,rs,t d = rs-rt（溢出时产生异常）   subiu rd,rs,immediate d = rs-immediate （溢出时不产生异常）   subi rd,rs,immediate d = rs-immediate（溢出时产生异常）    乘法指令    指令格式 含义     mult rd,rt hilo = rd * rt（有符号数）   multu rd,rt hilo = rd * rt（无符号数）     hi：结果的高 32 位 lo：结果的低 32 位  注意，此处指令中带的 u 和加减法指令含义不同。对于加减法，有符号和无符号数的运算相同，区别仅在带 u 的版本溢出时不产生异常；而对于乘除法，有符号和无符号数的运算不同，且无论是否溢出，都不产生异常，区别仅在带 u 的版本特指无符号数运算。\n除法指令    指令格式 含义     div rd,rt lo = rd / rt; hi = rd % rt（有符号数）   divu rd,rt lo = rd / rt; hi = rd % rt（无符号数）     lo：商 hi：余数  逻辑运算指令 位运算指令    指令格式 含义     ori rt,rs,immediate `rt = rs   andi rt,rs,immediate rt = rs \u0026 immediate   xori d,s,immediate rt = rs ^ immediate   or rd,rs,rt `rd = rs   and rd,rs,rt rd = rs \u0026 rt   xor rd,rs,rt rd = rs ^ rt   nor rd,rs,rt `rd = ~(rs    移位指令    指令格式 含义     sll rd,rt,shamt rd = rt    srl rd,rt,shamt rd = rt  shamt（逻辑右移）   sra rd,rt,shamt rd = rt  shamt（算术右移）    特殊用法    指令格式 含义     nor rd,rs,$0 rd = ~rs   or rd,rs,$0 rd = rs   sll $0,$0,0 空操作    由于对 $0 的改写无实际意义，所以可以借助 $0 实现空操作。\n数据传输指令    指令格式 含义     lw rt,immediate(rs) rt = memory[rs + immediate]   sw rt,immediate(rs) memory[rs + immediate] = rt   lh rt,immediate(rs) rt = memory[rs + immediate]   lhu rt,immediate(rs) rt = memory[rs + immediate]（零扩展）   sh rt,immediate(rs) memory[rs + immediate] = rt   lb rt,immediate(rs) rt = memory[rs + immediate]   lbu rt,immediate(rs) rt = memory[rs + immediate]（零扩展）   sb rt,immediate(rs) memory[rs + immediate] = rt   lui rt,immediate rt = immediate * 2^16     w：字，32 位 h：半字，16位 b：字节，8 位  MIPS 可以使用大端序和小端序，具体由系统设计人员决定。\n若要生成 32 位立即数用于寄存器基址寻址，可以先用 lui 指令加载高位，再用 ori 或者 lw 指令填充低位，以完成 $12 = memory[$13 + 0xC] 为例，有以下两种方式：\n# 方式一 lui $13,0x0060 ori $13,0x5000 # 简化版 ori 指令，同 ori $13,$13,0x5000 lw $12,0xC($13) # 方式二 lui $13,0x0060 lw $12,0x500C($13)  无条件跳转指令    指令格式 含义     j address goto address * 4   jal address $ra = PC + 4; goto address * 4   jr register goto register    MIPS 的指令总是 32 位的，因此指令是 4 字节对齐的，32 位地址的低 2 位永远为 0。将 32 位目标地址右移 2 位，然后存储低 26 位，这 26 位的地址实际可以替代 PC 的低 28 位。\n注意，使用 j 指令时，PC 的高 4 位是不变的，这意味着寻址界限为 256 MB，超过该界限时，应该使用寄存器跳转指令 （通常编译器会完成这些操作）。\n可以使用符号地址来简化编程：\nmain: ... j main  条件分支指令 条件跳转指令    指令格式 含义     beq register1,register2,address if (register1 == register2) goto PC + 4 + address * 4   bne register1,register2,address if (register1 != register2) goto PC + 4 + address * 4   bltz register,label if (register    bgez register,label if (register = 0) goto PC + 4 + address * 4    条件跳转指令使用 PC 相对寻址。\n条件置位指令    指令格式 含义     slt rd,rs,rt if (rs （有符号数）   sltu rd,rs,rt if (rs （无符号数）   slti rt,rs,immediate if (rs （有符号数）   sltiu rt,rs,immediate if (rs （无符号数）    再次强调，虽然 sltiu 代表无符号版本，但立即数会先被符号展开，然后再作为无符号数比较。\n其他指令    指令格式 含义     mfhi rd rd = hi   mflo rd rd = lo   syscall 系统调用    注意，在早期的 MIPS 处理器上，mfhi 和 mflo 指令后的两条指令，不得出现乘法和除法指令，其原因涉及 MIPS 流水线的工作方式。\n伪指令 算术运算伪指令    指令格式 含义     addu d,s,x d = s + x   subu d,s,x d = s-x   negu d,s d = -s   mul d,s,t d = s * t（结果不超过 32 位）   div d,s,t d = s / t（有符号数）   divu d,s,t d = s / t（无符号数）   remu d,s,t d = s % t（无符号数）   abs d,s `d =    其中，x 可以是寄存器、 16 位立即数或 32 位立即数，后面的 x 含义相同，不再重复。\n逻辑运算伪指令    指令格式 含义     not d,s d = ~s   or d,s,x `d = s   and d,s,x d = s \u0026 x   rol d,s,t d = s （循环左移）   ror d,s,t d = s  t（循环右移）    数据传输伪指令    指令格式 含义     move d,s d = s   li d,value d = value（value 可以是 16 位或 32 位）   la d,exp d = address(exp)（exp 通常是一个符号地址）   lw d,exp d = memory[exp]   sw d,exp memory[exp] = d    伪指令还允许借助符号地址来寻址，示例如下：\nli $t1,2 # index 2 lb $v0,data($t1) # $v0 = data[$t1] ... data: .byte 6,34,12,-32, 90  条件分支伪指令 条件跳转伪指令    指令格式 含义     b label goto label   beq s,x,label if (s == x) goto label   beqz s,label if (s == 0) goto label   bge s,x,label if (s = x) goto label (有符号数)   bgeu s,x,label if (s = x) goto label (无符号数)   bgez s,label if (s = 0) goto label (有符号数)   bgt s,x,label if (s  x) goto label (有符号数)   bgtu s,x,label if (s  x) goto label (无符号数)   bgtz s,label if (s  0) goto label (有符号数)   ble s,x,label if (s (有符号数)   bleu s,x,label if (s (无符号数)   blez s,label if (s (有符号数)   blt s,x,label if (s (有符号数)   bltu s,x,label if (s (无符号数)   bltz s,label if (s (有符号数)   bnez s,label if (s != 0) goto label   bne s,x,label if (s != x) goto label    注意，所有的分支指令都只能跳转到分支附近的位置，它只使用 16 位来表示地址。\n条件置位伪指令    指令格式 含义     slt d,s,x if (s    seq d,s,x if (s == x) d = 1; else d = 0   sge d,s,x if (s = x) d = 1; else d = 0 (有符号数)   sgeu d,s,x if (s = x) d = 1; else d = 0 (无符号数)   sgt d,s,x if (s  x) d = 1; else d = 0 (有符号数)   sgtu d,s,x if (s  x) d = 1; else d = 0 (无符号数)   sle d,s,x if (s (有符号数)   sleu d,s,x if (s (无符号数)   slt d,s,x if (s (有符号数)   slti d,s,immediate if (s (有符号数)   sltu d,s,x if (s (无符号数)   sltiu d,s,immediate if (s (无符号数)   sne d,s,x if (s != x)    浮点伪指令    指令格式 含义     l.s fd,address fd = memory[address]   s.s fd,address memory[address] = fd   li.s fd,value fd = value   abs.s fd,fs `$d =   add.s fd,fs,ft fd = fs + ft   sub.s fd,fs,ft fd = fs-ft   mul.s fd,fs,ft fd = fs * ft   div.s fd,fs,ft fd = fs / ft   neg.s fd,fs fd = -fs   mov.s fd, fs fd = fs   mtc1 rs, fd fd = rs（直接赋值，不进行转换，注意此处目标寄存器和源寄存器顺序）   mfc1 rd, fs rd = fs（直接赋值，不进行转换）   c.eq.s fs, ft if (fs == ft) condition bit = 1; else condition bit = 0   c.lt.s fs, ft if (fs    c.le.s fs, ft if (fs    bc1t label if (condition bit = 1) goto label   bc1f label if (condition bit = 0) goto label    部分 MIPS 处理器只允许在单精度浮点指令中使用 $f0、$f2 、 … 、 $f30 寄存器。以上 .s 结尾的都是单精度浮点指令，对于双精度，将 s 替换为 d 即可，这样 MIPS 将使用寄存器对来进行运算，寄存器对的名称是 $f0、$f2 、 … 、 $f30。\n其他伪指令    指令格式 含义     nop 空操作    汇编器指令    语法 用途     .text 表明代码段的开始   .globl 表明标识符是一个全局符号   .data 表明数据段的开始   .byte 放置一个 8 位的整数，多个整数用逗号隔开   .word 放置一个 32 位的整数，多个整数用逗号隔开   .space 在内存中保留的字节数   .ascii 放置一个 ASCII 字符串   .asciiz 放置一个 C 风格的字符串 (以 \\0 结尾的 ASCII 字符串)   .float 放置一个 32 位的单精度浮点数，多个浮点数用逗号隔开    栈 在 MIPS 中，栈是向下增长的。\n通过以下代码实现 push 操作：\n# PUSH the item in $t0: subu $sp,$sp,4 # point to the place for the new item, sw $t0,($sp) # store the contents of $t0 as the new top.  通过以下代码实现 pop 操作：\n# POP the item into $t0: lw $t0,($sp) # Copy top item to $t0. addu $sp,$sp,4 # Point to the item beneath the old top.  子程序连接 基于堆栈的连接约定  调用子程序（由调用者完成）： 1.1. 将需要保存的 $t0-$t9 寄存器入栈，子程序可能会修改它们。 1.2. 将参数放入 $a0-$a3。 1.3. 使用 jal 指令调用子程序。 子程序 prolog（由子程序在开头完成）： 2.1. 如果该子程序需要调用其他子程序，将 $ra 入栈。 2.2. 将需要修改的 $s0-$s7 寄存器入栈。 子程序主体: 3.1. 子程序可以修改 $t0-$t9、$a0-$a3 和 2.2 中保存的寄存器。 3.2. 如果子程序需要调用其他子程序，也必须遵守这些约定。 子程序 epilog（由子程序在返回前完成）： 4.1. 将返回值放入 $v0-$v1。 4.2. 将 2.2 中保存的寄存器按与入栈时相反的顺序出栈。 4.3. 如果 $ra 在 2.1 中被保存，将它出栈。 4.4. 使用 ja $ra 指令返回。 从子程序重新获得控制权（由调用者完成）： 5.1. 将 1.1 中保存的寄存器按与入栈时相反的顺序出栈。  基于栈帧的连接约定 以下约定假设栈只存储 32 位的数据。\n 调用子程序（由调用者完成）： 1.1. 按数字顺序将需要保存的 $t0-$t9 寄存器入栈。 1.2. 将参数放入 $a0-$a3。 1.3. 使用 jal 指令调用子程序。 子程序 prolog（由子程序在开头完成）： 2.1. 将 $ra 入栈。 2.2. 将调用者的帧指针 $fp 入栈。 2.3. 将需要修改的 $s0-$s7 寄存器入栈。 2.4. 初始化帧指针： $fp = $sp-space，其中 space 指变量占用空间，此处是变量个数的 4 倍。 2.5. 初始化栈指针： $sp = $fp。 子程序主体： 3.1. 子程序可以修改 $t0-$t9、$a0-$a3 和 2.3 中保存的寄存器。 3.2. 子程序根据 disp($fp) 的形式寻址来使用局部变量。 3.3. 子程序可以通过修改 $sp 在栈上存储数据。 3.4. 如果子程序需要调用其他子程序，也必须遵守这些约定。 子程序 epilog（由子程序在返回前完成）： 4.1. 将返回值放入 $v0-$v1。 4.2. $sp = $fp + space。 4.3. 将 2.3 中保存的寄存器按与入栈时相反的顺序出栈。 4.4. 将调用者的帧指针 $fp 出栈。 4.5. 将 $ra 出栈。 4.6. 使用 ja $ra 指令返回。 从子程序重新获得控制权（由调用者完成）： 5.1. 将 1.1 中保存的寄存器按与入栈时相反的顺序出栈。  进入子程序时栈结构如下图所示：\n","wordCount":"1577","inLanguage":"zh-cn","datePublished":"2020-07-10T00:00:00Z","dateModified":"2020-07-10T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/mips/assembly/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>MIPS 汇编</h1><div class=post-meta>July 10, 2020&nbsp;·&nbsp;8 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%af%84%e5%ad%98%e5%99%a8 aria-label=寄存器>寄存器</a><ul><li><a href=#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8 aria-label=通用寄存器>通用寄存器</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e5%af%84%e5%ad%98%e5%99%a8 aria-label=特殊寄存器>特殊寄存器</a></li><li><a href=#%e6%b5%ae%e7%82%b9%e5%af%84%e5%ad%98%e5%99%a8 aria-label=浮点寄存器>浮点寄存器</a></li></ul></li><li><a href=#%e6%8c%87%e4%bb%a4%e6%a0%bc%e5%bc%8f aria-label=指令格式>指令格式</a><ul><li><a href=#r-%e5%9e%8b%e7%94%a8%e4%ba%8e%e5%af%84%e5%ad%98%e5%99%a8 aria-label="R 型（用于寄存器）">R 型（用于寄存器）</a></li><li><a href=#i-%e5%9e%8b%e7%94%a8%e4%ba%8e%e7%ab%8b%e5%8d%b3%e6%95%b0 aria-label="I 型（用于立即数）">I 型（用于立即数）</a></li><li><a href=#j-%e5%9e%8b%e7%94%a8%e4%ba%8e%e5%88%86%e6%94%af%e5%92%8c%e8%b7%b3%e8%bd%ac aria-label="J 型（用于分支和跳转）">J 型（用于分支和跳转）</a></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%b1%87%e7%bc%96%e6%8c%87%e4%bb%a4 aria-label=基本汇编指令>基本汇编指令</a><ul><li><a href=#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=算术运算指令>算术运算指令</a><ul><li><a href=#%e5%8a%a0%e6%b3%95%e6%8c%87%e4%bb%a4 aria-label=加法指令>加法指令</a></li><li><a href=#%e5%87%8f%e6%b3%95%e6%8c%87%e4%bb%a4 aria-label=减法指令>减法指令</a></li><li><a href=#%e4%b9%98%e6%b3%95%e6%8c%87%e4%bb%a4 aria-label=乘法指令>乘法指令</a></li><li><a href=#%e9%99%a4%e6%b3%95%e6%8c%87%e4%bb%a4 aria-label=除法指令>除法指令</a></li></ul></li><li><a href=#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=逻辑运算指令>逻辑运算指令</a><ul><li><a href=#%e4%bd%8d%e8%bf%90%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=位运算指令>位运算指令</a></li><li><a href=#%e7%a7%bb%e4%bd%8d%e6%8c%87%e4%bb%a4 aria-label=移位指令>移位指令</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e7%94%a8%e6%b3%95 aria-label=特殊用法>特殊用法</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e6%8c%87%e4%bb%a4 aria-label=数据传输指令>数据传输指令</a></li><li><a href=#%e6%97%a0%e6%9d%a1%e4%bb%b6%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4 aria-label=无条件跳转指令>无条件跳转指令</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af%e6%8c%87%e4%bb%a4 aria-label=条件分支指令>条件分支指令</a><ul><li><a href=#%e6%9d%a1%e4%bb%b6%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4 aria-label=条件跳转指令>条件跳转指令</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e7%bd%ae%e4%bd%8d%e6%8c%87%e4%bb%a4 aria-label=条件置位指令>条件置位指令</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e6%8c%87%e4%bb%a4 aria-label=其他指令>其他指令</a></li></ul></li><li><a href=#%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=伪指令>伪指令</a><ul><li><a href=#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=算术运算伪指令>算术运算伪指令</a></li><li><a href=#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=逻辑运算伪指令>逻辑运算伪指令</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=数据传输伪指令>数据传输伪指令</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=条件分支伪指令>条件分支伪指令</a><ul><li><a href=#%e6%9d%a1%e4%bb%b6%e8%b7%b3%e8%bd%ac%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=条件跳转伪指令>条件跳转伪指令</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e7%bd%ae%e4%bd%8d%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=条件置位伪指令>条件置位伪指令</a></li></ul></li><li><a href=#%e6%b5%ae%e7%82%b9%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=浮点伪指令>浮点伪指令</a></li><li><a href=#%e5%85%b6%e4%bb%96%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=其他伪指令>其他伪指令</a></li></ul></li><li><a href=#%e6%b1%87%e7%bc%96%e5%99%a8%e6%8c%87%e4%bb%a4 aria-label=汇编器指令>汇编器指令</a></li><li><a href=#%e6%a0%88 aria-label=栈>栈</a></li><li><a href=#%e5%ad%90%e7%a8%8b%e5%ba%8f%e8%bf%9e%e6%8e%a5 aria-label=子程序连接>子程序连接</a><ul><li><a href=#%e5%9f%ba%e4%ba%8e%e5%a0%86%e6%a0%88%e7%9a%84%e8%bf%9e%e6%8e%a5%e7%ba%a6%e5%ae%9a aria-label=基于堆栈的连接约定>基于堆栈的连接约定</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e6%a0%88%e5%b8%a7%e7%9a%84%e8%bf%9e%e6%8e%a5%e7%ba%a6%e5%ae%9a aria-label=基于栈帧的连接约定>基于栈帧的连接约定</a></li></ul></li></ul></div></details></div><div class=post-content><p>根据 <em><a href=http://programmedlessons.org/AssemblyTutorial/index.html>Programmed Introduction to MIPS Assembly Language</a></em> 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。</p><h2 id=寄存器>寄存器<a hidden class=anchor aria-hidden=true href=#寄存器>#</a></h2><h3 id=通用寄存器>通用寄存器<a hidden class=anchor aria-hidden=true href=#通用寄存器>#</a></h3><p>MIPS 提供 32 个 32 位的通用寄存器。</p><table><thead><tr><th>寄存器</th><th>助记符</th><th>用途</th></tr></thead><tbody><tr><td><code>$0</code></td><td><code>zero</code></td><td>常数零</td></tr><tr><td><code>$1</code></td><td><code>$at</code></td><td>汇编器保留</td></tr><tr><td><code>$2</code>，<code>$3</code></td><td><code>$v0</code>，<code>$v1</code></td><td>子程序返回值</td></tr><tr><td><code>$4</code>-<code>$7</code></td><td><code>$a0</code>-<code>$a3</code></td><td>子程序参数</td></tr><tr><td><code>$8</code>-<code>$15</code></td><td><code>$t0</code>-<code>$t7</code></td><td>临时寄存器（调用者保存）</td></tr><tr><td><code>$16</code>-<code>$23</code></td><td><code>$s0</code>-<code>$s7</code></td><td>保存寄存器（被调用者保存）</td></tr><tr><td><code>$24</code>，<code>$25</code></td><td><code>$t8</code>，<code>$t9</code></td><td>临时寄存器（调用者保存）</td></tr><tr><td><code>$26</code>，<code>$27</code></td><td><code>$k0</code>，<code>$k1</code></td><td>操作系统保留</td></tr><tr><td><code>$28</code></td><td><code>$gp</code></td><td>全局指针</td></tr><tr><td><code>$29</code></td><td><code>$sp</code></td><td>栈指针</td></tr><tr><td><code>$30</code></td><td><code>$fp</code></td><td>帧指针</td></tr><tr><td><code>$31</code></td><td><code>$ra</code></td><td>返回地址</td></tr></tbody></table><h3 id=特殊寄存器>特殊寄存器<a hidden class=anchor aria-hidden=true href=#特殊寄存器>#</a></h3><p>MIPS 提供一对 32 位寄存器 <code>hi</code> 和 <code>lo</code> 来帮助完成乘法、除法运算。</p><h3 id=浮点寄存器>浮点寄存器<a hidden class=anchor aria-hidden=true href=#浮点寄存器>#</a></h3><p>MIPS 有 32 个 32 位的浮点寄存器 <code>$f0</code> – <code>$f31</code>。</p><h2 id=指令格式>指令格式<a hidden class=anchor aria-hidden=true href=#指令格式>#</a></h2><h3 id=r-型用于寄存器>R 型（用于寄存器）<a hidden class=anchor aria-hidden=true href=#r-型用于寄存器>#</a></h3><table><thead><tr><th style=text-align:center>字段名</th><th style=text-align:center><code>op</code></th><th style=text-align:center><code>rs</code></th><th style=text-align:center><code>rt</code></th><th style=text-align:center><code>rd</code></th><th style=text-align:center><code>shamt</code></th><th style=text-align:center><code>funct</code></th></tr></thead><tbody><tr><td style=text-align:center>含义</td><td style=text-align:center>操作码</td><td style=text-align:center>第一个源操作数寄存器</td><td style=text-align:center>第二个源操作数寄存器</td><td style=text-align:center>目的寄存器</td><td style=text-align:center>位移量</td><td style=text-align:center>功能码</td></tr><tr><td style=text-align:center>长度</td><td style=text-align:center>6</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>6</td></tr></tbody></table><p>由于 <code>shamt</code> 用 5 位表示，所以 $0 \le$ <code>shamt</code> $&lt; 2^{5}$。</p><h3 id=i-型用于立即数>I 型（用于立即数）<a hidden class=anchor aria-hidden=true href=#i-型用于立即数>#</a></h3><table><thead><tr><th style=text-align:center>字段名</th><th style=text-align:center><code>op</code></th><th style=text-align:center><code>rs</code></th><th style=text-align:center><code>rt</code></th><th style=text-align:center><code>immediate</code></th></tr></thead><tbody><tr><td style=text-align:center>含义</td><td style=text-align:center>操作码</td><td style=text-align:center>源操作数寄存器</td><td style=text-align:center>目的寄存器</td><td style=text-align:center>立即数</td></tr><tr><td style=text-align:center>长度</td><td style=text-align:center>6</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>16</td></tr></tbody></table><p>由于 <code>immediate</code> 用 16 位表示，所以 $-2^{15} \le$ <code>immediate</code> $&lt; 2^{15}$ 。</p><p>注意，此处 <code>rt</code> 的含义与上面不同，且后面的指令如不注明，<code>immediate</code> 默认被<strong>符号扩展</strong>为 32 位！</p><h3 id=j-型用于分支和跳转>J 型（用于分支和跳转）<a hidden class=anchor aria-hidden=true href=#j-型用于分支和跳转>#</a></h3><table><thead><tr><th style=text-align:center>字段名</th><th style=text-align:center><code>op</code></th><th style=text-align:center><code>address</code></th></tr></thead><tbody><tr><td style=text-align:center>含义</td><td style=text-align:center>操作码</td><td style=text-align:center>地址</td></tr><tr><td style=text-align:center>长度</td><td style=text-align:center>6</td><td style=text-align:center>26</td></tr></tbody></table><p>特别的，对于条件分支指令，地址字段可能又被划分为了多个部分。</p><h2 id=基本汇编指令>基本汇编指令<a hidden class=anchor aria-hidden=true href=#基本汇编指令>#</a></h2><h3 id=算术运算指令>算术运算指令<a hidden class=anchor aria-hidden=true href=#算术运算指令>#</a></h3><h4 id=加法指令>加法指令<a hidden class=anchor aria-hidden=true href=#加法指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>addu rd,rs,rt</code></td><td><code>rd = rs + rt</code>（溢出时不产生异常）</td></tr><tr><td><code>add rd,rs,rt</code></td><td><code>rd = rs + rt</code>（溢出时产生异常）</td></tr><tr><td><code>addiu rt,rs,immediate</code></td><td><code>rt = rs + immediate</code>（溢出时不产生异常）</td></tr><tr><td><code>addi rt,rs,immediate</code></td><td><code>rt = rs + immediate</code>（溢出时产生异常）</td></tr></tbody></table><p>注意，MIPS 只有 32 位算术运算，在高级语言中需要进行 16 位或 8 位算术运算时，编译器可能产生更多的指令来模拟这些运算，这意味这 32 位算术运算的速度往往会快于其他情况，而不是数据长度越短运算越快。</p><h4 id=减法指令>减法指令<a hidden class=anchor aria-hidden=true href=#减法指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>subu rd,rs,rt</code></td><td><code>d = rs-rt</code>（溢出时不产生异常）</td></tr><tr><td><code>sub rd,rs,t</code></td><td><code>d = rs-rt</code>（溢出时产生异常）</td></tr><tr><td><code>subiu rd,rs,immediate</code></td><td><code>d = rs-immediate</code> （溢出时不产生异常）</td></tr><tr><td><code>subi rd,rs,immediate</code></td><td><code>d = rs-immediate</code>（溢出时产生异常）</td></tr></tbody></table><h4 id=乘法指令>乘法指令<a hidden class=anchor aria-hidden=true href=#乘法指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>mult rd,rt</code></td><td><code>hilo = rd * rt</code>（有符号数）</td></tr><tr><td><code>multu rd,rt</code></td><td><code>hilo = rd * rt</code>（无符号数）</td></tr></tbody></table><ul><li><code>hi</code>：结果的高 32 位</li><li><code>lo</code>：结果的低 32 位</li></ul><p>注意，此处指令中带的 <code>u</code> 和加减法指令含义不同。对于<strong>加减法</strong>，有符号和无符号数的运算相同，区别仅在<strong>带 <code>u</code> 的版本溢出时不产生异常</strong>；而对于<strong>乘除法</strong>，有符号和无符号数的运算不同，且无论是否溢出，都不产生异常，区别仅在<strong>带 <code>u</code> 的版本特指无符号数运算</strong>。</p><h4 id=除法指令>除法指令<a hidden class=anchor aria-hidden=true href=#除法指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>div rd,rt</code></td><td><code>lo = rd / rt; hi = rd % rt</code>（有符号数）</td></tr><tr><td><code>divu rd,rt</code></td><td><code>lo = rd / rt; hi = rd % rt</code>（无符号数）</td></tr></tbody></table><ul><li><code>lo</code>：商</li><li><code>hi</code>：余数</li></ul><h3 id=逻辑运算指令>逻辑运算指令<a hidden class=anchor aria-hidden=true href=#逻辑运算指令>#</a></h3><h4 id=位运算指令>位运算指令<a hidden class=anchor aria-hidden=true href=#位运算指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>ori rt,rs,immediate</code></td><td>`rt = rs</td></tr><tr><td><code>andi rt,rs,immediate</code></td><td><code>rt = rs & immediate</code></td></tr><tr><td><code>xori d,s,immediate</code></td><td><code>rt = rs ^ immediate</code></td></tr><tr><td><code>or rd,rs,rt</code></td><td>`rd = rs</td></tr><tr><td><code>and rd,rs,rt</code></td><td><code>rd = rs & rt</code></td></tr><tr><td><code>xor rd,rs,rt</code></td><td><code>rd = rs ^ rt</code></td></tr><tr><td><code>nor rd,rs,rt</code></td><td>`rd = ~(rs</td></tr></tbody></table><h4 id=移位指令>移位指令<a hidden class=anchor aria-hidden=true href=#移位指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>sll rd,rt,shamt</code></td><td><code>rd = rt &lt;&lt; shamt</code></td></tr><tr><td><code>srl rd,rt,shamt</code></td><td><code>rd = rt >> shamt</code>（逻辑右移）</td></tr><tr><td><code>sra rd,rt,shamt</code></td><td><code>rd = rt >> shamt</code>（算术右移）</td></tr></tbody></table><h4 id=特殊用法>特殊用法<a hidden class=anchor aria-hidden=true href=#特殊用法>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>nor rd,rs,$0</code></td><td><code>rd = ~rs</code></td></tr><tr><td><code>or rd,rs,$0</code></td><td><code>rd = rs</code></td></tr><tr><td><code>sll $0,$0,0</code></td><td>空操作</td></tr></tbody></table><p>由于对 <code>$0</code> 的改写无实际意义，所以可以借助 <code>$0</code> 实现空操作。</p><h3 id=数据传输指令>数据传输指令<a hidden class=anchor aria-hidden=true href=#数据传输指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>lw rt,immediate(rs)</code></td><td><code>rt = memory[rs + immediate]</code></td></tr><tr><td><code>sw rt,immediate(rs)</code></td><td><code>memory[rs + immediate] = rt</code></td></tr><tr><td><code>lh rt,immediate(rs)</code></td><td><code>rt = memory[rs + immediate]</code></td></tr><tr><td><code>lhu rt,immediate(rs)</code></td><td><code>rt = memory[rs + immediate]</code>（零扩展）</td></tr><tr><td><code>sh rt,immediate(rs)</code></td><td><code>memory[rs + immediate] = rt</code></td></tr><tr><td><code>lb rt,immediate(rs)</code></td><td><code>rt = memory[rs + immediate]</code></td></tr><tr><td><code>lbu rt,immediate(rs)</code></td><td><code>rt = memory[rs + immediate]</code>（零扩展）</td></tr><tr><td><code>sb rt,immediate(rs)</code></td><td><code>memory[rs + immediate] = rt</code></td></tr><tr><td><code>lui rt,immediate</code></td><td><code>rt = immediate * 2^16</code></td></tr></tbody></table><ul><li><code>w</code>：字，32 位</li><li><code>h</code>：半字，16位</li><li><code>b</code>：字节，8 位</li></ul><p>MIPS 可以使用大端序和小端序，具体由系统设计人员决定。</p><p>若要生成 32 位立即数用于寄存器基址寻址，可以先用 <code>lui</code> 指令加载高位，再用 <code>ori</code> 或者 <code>lw</code> 指令填充低位，以完成 <code>$12 = memory[$13 + 0xC]</code> 为例，有以下两种方式：</p><pre><code># 方式一
lui $13,0x0060
ori $13,0x5000 # 简化版 ori 指令，同 ori $13,$13,0x5000
lw  $12,0xC($13)

# 方式二
lui $13,0x0060
lw  $12,0x500C($13)
</code></pre><h3 id=无条件跳转指令>无条件跳转指令<a hidden class=anchor aria-hidden=true href=#无条件跳转指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>j address</code></td><td><code>goto address * 4</code></td></tr><tr><td><code>jal address</code></td><td><code>$ra = PC + 4; goto address * 4</code></td></tr><tr><td><code>jr register</code></td><td><code>goto register</code></td></tr></tbody></table><p>MIPS 的指令总是 32 位的，因此指令是 4 字节对齐的，32 位地址的低 2 位永远为 0。将 32 位目标地址右移 2 位，然后存储低 26 位，这 26 位的地址实际可以替代 <code>PC</code> 的低 28 位。</p><p>注意，使用 <code>j</code> 指令时，<code>PC</code> 的高 4 位是不变的，这意味着寻址界限为 256 MB，超过该界限时，应该使用寄存器跳转指令 （通常编译器会完成这些操作）。</p><p>可以使用符号地址来简化编程：</p><pre><code>main: 
  ...
  j main
</code></pre><h3 id=条件分支指令>条件分支指令<a hidden class=anchor aria-hidden=true href=#条件分支指令>#</a></h3><h4 id=条件跳转指令>条件跳转指令<a hidden class=anchor aria-hidden=true href=#条件跳转指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>beq register1,register2,address</code></td><td><code>if (register1 == register2) goto PC + 4 + address * 4</code></td></tr><tr><td><code>bne register1,register2,address</code></td><td><code>if (register1 != register2) goto PC + 4 + address * 4</code></td></tr><tr><td><code>bltz register,label</code></td><td><code>if (register &lt; 0) goto PC + 4 + address * 4</code></td></tr><tr><td><code>bgez register,label</code></td><td><code>if (register >= 0) goto PC + 4 + address * 4</code></td></tr></tbody></table><p>条件跳转指令使用 PC 相对寻址。</p><h4 id=条件置位指令>条件置位指令<a hidden class=anchor aria-hidden=true href=#条件置位指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>slt rd,rs,rt</code></td><td><code>if (rs &lt; rt) rd = 1; else rd = 0</code>（有符号数）</td></tr><tr><td><code>sltu rd,rs,rt</code></td><td><code>if (rs &lt; rt) rd = 1; else rd = 0</code>（无符号数）</td></tr><tr><td><code>slti rt,rs,immediate</code></td><td><code>if (rs &lt; immediate) rt = 1; else rt = 0</code>（有符号数）</td></tr><tr><td><code>sltiu rt,rs,immediate</code></td><td><code>if (rs &lt; immediate) rt = 1; else rt = 0</code>（无符号数）</td></tr></tbody></table><p>再次强调，虽然 <code>sltiu</code> 代表无符号版本，但立即数会先被<strong>符号展开</strong>，然后再作为无符号数比较。</p><h3 id=其他指令>其他指令<a hidden class=anchor aria-hidden=true href=#其他指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>mfhi rd</code></td><td><code>rd = hi</code></td></tr><tr><td><code>mflo rd</code></td><td><code>rd = lo</code></td></tr><tr><td><code>syscall</code></td><td>系统调用</td></tr></tbody></table><p>注意，在早期的 MIPS 处理器上，<code>mfhi</code> 和 <code>mflo</code> 指令后的两条指令，不得出现乘法和除法指令，其原因涉及 MIPS 流水线的工作方式。</p><h2 id=伪指令>伪指令<a hidden class=anchor aria-hidden=true href=#伪指令>#</a></h2><h3 id=算术运算伪指令>算术运算伪指令<a hidden class=anchor aria-hidden=true href=#算术运算伪指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>addu d,s,x</code></td><td><code>d = s + x</code></td></tr><tr><td><code>subu d,s,x</code></td><td><code>d = s-x</code></td></tr><tr><td><code>negu d,s</code></td><td><code>d = -s</code></td></tr><tr><td><code>mul d,s,t</code></td><td><code>d = s * t</code>（结果不超过 32 位）</td></tr><tr><td><code>div d,s,t</code></td><td><code>d = s / t</code>（有符号数）</td></tr><tr><td><code>divu d,s,t</code></td><td><code>d = s / t</code>（无符号数）</td></tr><tr><td><code>remu d,s,t</code></td><td><code>d = s % t</code>（无符号数）</td></tr><tr><td><code>abs d,s</code></td><td>`d =</td></tr></tbody></table><p>其中，<code>x</code> 可以是寄存器、 16 位立即数或 32 位立即数，后面的 <code>x</code> 含义相同，不再重复。</p><h3 id=逻辑运算伪指令>逻辑运算伪指令<a hidden class=anchor aria-hidden=true href=#逻辑运算伪指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>not d,s</code></td><td><code>d = ~s</code></td></tr><tr><td><code>or d,s,x</code></td><td>`d = s</td></tr><tr><td><code>and d,s,x</code></td><td><code>d = s & x</code></td></tr><tr><td><code>rol d,s,t</code></td><td><code>d = s &lt;&lt; t</code>（循环左移）</td></tr><tr><td><code>ror d,s,t</code></td><td><code>d = s >> t</code>（循环右移）</td></tr></tbody></table><h3 id=数据传输伪指令>数据传输伪指令<a hidden class=anchor aria-hidden=true href=#数据传输伪指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>move d,s</code></td><td><code>d = s</code></td></tr><tr><td><code>li d,value</code></td><td><code>d = value</code>（<code>value</code> 可以是 16 位或 32 位）</td></tr><tr><td><code>la d,exp</code></td><td><code>d = address(exp)</code>（<code>exp</code> 通常是一个符号地址）</td></tr><tr><td><code>lw d,exp</code></td><td><code>d = memory[exp]</code></td></tr><tr><td><code>sw d,exp</code></td><td><code>memory[exp] = d</code></td></tr></tbody></table><p>伪指令还允许借助符号地址来寻址，示例如下：</p><pre><code>li $t1,2                 # index 2
lb $v0,data($t1)         # $v0 = data[$t1]
...
  
data: .byte  6,34,12,-32, 90
</code></pre><h3 id=条件分支伪指令>条件分支伪指令<a hidden class=anchor aria-hidden=true href=#条件分支伪指令>#</a></h3><h4 id=条件跳转伪指令>条件跳转伪指令<a hidden class=anchor aria-hidden=true href=#条件跳转伪指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>b label</code></td><td><code>goto label</code></td></tr><tr><td><code>beq s,x,label</code></td><td><code>if (s == x) goto label</code></td></tr><tr><td><code>beqz s,label</code></td><td><code>if (s == 0) goto label</code></td></tr><tr><td><code>bge s,x,label</code></td><td><code>if (s >= x) goto label</code> (有符号数)</td></tr><tr><td><code>bgeu s,x,label</code></td><td><code>if (s >= x) goto label</code> (无符号数)</td></tr><tr><td><code>bgez s,label</code></td><td><code>if (s >= 0) goto label</code> (有符号数)</td></tr><tr><td><code>bgt s,x,label</code></td><td><code>if (s > x) goto label</code> (有符号数)</td></tr><tr><td><code>bgtu s,x,label</code></td><td><code>if (s > x) goto label</code> (无符号数)</td></tr><tr><td><code>bgtz s,label</code></td><td><code>if (s > 0) goto label</code> (有符号数)</td></tr><tr><td><code>ble s,x,label</code></td><td><code>if (s &lt;= x) goto label</code> (有符号数)</td></tr><tr><td><code>bleu s,x,label</code></td><td><code>if (s &lt;= x) goto label</code> (无符号数)</td></tr><tr><td><code>blez s,label</code></td><td><code>if (s &lt;= 0) goto label</code> (有符号数)</td></tr><tr><td><code>blt s,x,label</code></td><td><code>if (s &lt; x) goto label</code> (有符号数)</td></tr><tr><td><code>bltu s,x,label</code></td><td><code>if (s &lt; x) goto label</code> (无符号数)</td></tr><tr><td><code>bltz s,label</code></td><td><code>if (s &lt; 0) goto label</code> (有符号数)</td></tr><tr><td><code>bnez s,label</code></td><td><code>if (s != 0) goto label</code></td></tr><tr><td><code>bne s,x,label</code></td><td><code>if (s != x) goto label</code></td></tr></tbody></table><p>注意，所有的分支指令都只能跳转到分支附近的位置，它只使用 16 位来表示地址。</p><h4 id=条件置位伪指令>条件置位伪指令<a hidden class=anchor aria-hidden=true href=#条件置位伪指令>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>slt d,s,x</code></td><td><code>if (s &lt; x) d = 1; else d = 0</code></td></tr><tr><td><code>seq d,s,x</code></td><td><code>if (s == x) d = 1; else d = 0</code></td></tr><tr><td><code>sge d,s,x</code></td><td><code>if (s >= x) d = 1; else d = 0</code> (有符号数)</td></tr><tr><td><code>sgeu d,s,x</code></td><td><code>if (s >= x) d = 1; else d = 0</code> (无符号数)</td></tr><tr><td><code>sgt d,s,x</code></td><td><code>if (s > x) d = 1; else d = 0</code> (有符号数)</td></tr><tr><td><code>sgtu d,s,x</code></td><td><code>if (s > x) d = 1; else d = 0</code> (无符号数)</td></tr><tr><td><code>sle d,s,x</code></td><td><code>if (s &lt;= x) d = 1; else d = 0</code> (有符号数)</td></tr><tr><td><code>sleu d,s,x</code></td><td><code>if (s &lt;= x) d = 1; else d = 0</code> (无符号数)</td></tr><tr><td><code>slt d,s,x</code></td><td><code>if (s &lt; x) d = 1; else d = 0</code> (有符号数)</td></tr><tr><td><code>slti d,s,immediate</code></td><td><code>if (s &lt; immediate) d = 1; else d = 0</code> (有符号数)</td></tr><tr><td><code>sltu d,s,x</code></td><td><code>if (s &lt; x) d = 1; else d = 0</code> (无符号数)</td></tr><tr><td><code>sltiu d,s,immediate</code></td><td><code>if (s &lt; immediate) d = 1; else d = 0</code> (无符号数)</td></tr><tr><td><code>sne d,s,x</code></td><td><code>if (s != x)</code></td></tr></tbody></table><h3 id=浮点伪指令>浮点伪指令<a hidden class=anchor aria-hidden=true href=#浮点伪指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>l.s fd,address</code></td><td><code>fd = memory[address]</code></td></tr><tr><td><code>s.s fd,address</code></td><td><code>memory[address] = fd</code></td></tr><tr><td><code>li.s fd,value</code></td><td><code>fd = value</code></td></tr><tr><td><code>abs.s fd,fs</code></td><td>`$d =</td></tr><tr><td><code>add.s fd,fs,ft</code></td><td><code>fd = fs + ft</code></td></tr><tr><td><code>sub.s fd,fs,ft</code></td><td><code>fd = fs-ft</code></td></tr><tr><td><code>mul.s fd,fs,ft</code></td><td><code>fd = fs * ft</code></td></tr><tr><td><code>div.s fd,fs,ft</code></td><td><code>fd = fs / ft</code></td></tr><tr><td><code>neg.s fd,fs</code></td><td><code>fd = -fs</code></td></tr><tr><td><code>mov.s fd, fs</code></td><td><code>fd = fs</code></td></tr><tr><td><code>mtc1 rs, fd</code></td><td><code>fd = rs</code>（直接赋值，不进行转换，注意此处目标寄存器和源寄存器顺序）</td></tr><tr><td><code>mfc1 rd, fs</code></td><td><code>rd = fs</code>（直接赋值，不进行转换）</td></tr><tr><td><code>c.eq.s fs, ft</code></td><td><code>if (fs == ft) condition bit = 1; else condition bit = 0</code></td></tr><tr><td><code>c.lt.s fs, ft</code></td><td><code>if (fs &lt; ft) condition bit = 1; else condition bit = 0</code></td></tr><tr><td><code>c.le.s fs, ft</code></td><td><code>if (fs &lt;= ft) condition bit = 1; else condition bit = 0</code></td></tr><tr><td><code>bc1t label</code></td><td><code>if (condition bit = 1) goto label</code></td></tr><tr><td><code>bc1f label</code></td><td><code>if (condition bit = 0) goto label</code></td></tr></tbody></table><p>部分 MIPS 处理器只允许在单精度浮点指令中使用 <code>$f0</code>、<code>$f2</code> 、 &mldr; 、 <code>$f30</code> 寄存器。以上 <code>.s</code> 结尾的都是单精度浮点指令，对于双精度，将 <code>s</code> 替换为 <code>d</code> 即可，这样 MIPS 将使用寄存器对来进行运算，寄存器对的名称是 <code>$f0</code>、<code>$f2</code> 、 &mldr; 、 <code>$f30</code>。</p><h3 id=其他伪指令>其他伪指令<a hidden class=anchor aria-hidden=true href=#其他伪指令>#</a></h3><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>nop</code></td><td>空操作</td></tr></tbody></table><h2 id=汇编器指令>汇编器指令<a hidden class=anchor aria-hidden=true href=#汇编器指令>#</a></h2><table><thead><tr><th>语法</th><th>用途</th></tr></thead><tbody><tr><td><code>.text</code></td><td>表明代码段的开始</td></tr><tr><td><code>.globl</code></td><td>表明标识符是一个全局符号</td></tr><tr><td><code>.data</code></td><td>表明数据段的开始</td></tr><tr><td><code>.byte</code></td><td>放置一个 8 位的整数，多个整数用逗号隔开</td></tr><tr><td><code>.word</code></td><td>放置一个 32 位的整数，多个整数用逗号隔开</td></tr><tr><td><code>.space</code></td><td>在内存中保留的字节数</td></tr><tr><td><code>.ascii</code></td><td>放置一个 ASCII 字符串</td></tr><tr><td><code>.asciiz</code></td><td>放置一个 C 风格的字符串 (以 <code>\0</code> 结尾的 ASCII 字符串)</td></tr><tr><td><code>.float</code></td><td>放置一个 32 位的单精度浮点数，多个浮点数用逗号隔开</td></tr></tbody></table><h2 id=栈>栈<a hidden class=anchor aria-hidden=true href=#栈>#</a></h2><p>在 MIPS 中，栈是向下增长的。</p><p>通过以下代码实现 <code>push</code> 操作：</p><pre><code># PUSH the item in $t0:
subu $sp,$sp,4      #   point to the place for the new item,
sw   $t0,($sp)      #   store the contents of $t0 as the new top.
</code></pre><p>通过以下代码实现 <code>pop</code> 操作：</p><pre><code># POP the item into $t0:
lw   $t0,($sp)      #   Copy top item to $t0.
addu $sp,$sp,4      #   Point to the item beneath the old top.
</code></pre><h2 id=子程序连接>子程序连接<a hidden class=anchor aria-hidden=true href=#子程序连接>#</a></h2><h3 id=基于堆栈的连接约定>基于堆栈的连接约定<a hidden class=anchor aria-hidden=true href=#基于堆栈的连接约定>#</a></h3><ol><li>调用子程序（由调用者完成）：
1.1. 将需要保存的 <code>$t0</code>-<code>$t9</code> 寄存器入栈，子程序可能会修改它们。
1.2. 将参数放入 <code>$a0</code>-<code>$a3</code>。
1.3. 使用 <code>jal</code> 指令调用子程序。</li><li>子程序 prolog（由子程序在开头完成）：
2.1. 如果该子程序需要调用其他子程序，将 <code>$ra</code> 入栈。
2.2. 将需要修改的 <code>$s0</code>-<code>$s7</code> 寄存器入栈。</li><li>子程序主体:
3.1. 子程序可以修改 <code>$t0</code>-<code>$t9</code>、<code>$a0</code>-<code>$a3</code> 和 2.2 中保存的寄存器。
3.2. 如果子程序需要调用其他子程序，也必须遵守这些约定。</li><li>子程序 epilog（由子程序在返回前完成）：
4.1. 将返回值放入 <code>$v0</code>-<code>$v1</code>。
4.2. 将 2.2 中保存的寄存器按与入栈时相反的顺序出栈。
4.3. 如果 <code>$ra</code> 在 2.1 中被保存，将它出栈。
4.4. 使用 <code>ja $ra</code> 指令返回。</li><li>从子程序重新获得控制权（由调用者完成）：
5.1. 将 1.1 中保存的寄存器按与入栈时相反的顺序出栈。</li></ol><h3 id=基于栈帧的连接约定>基于栈帧的连接约定<a hidden class=anchor aria-hidden=true href=#基于栈帧的连接约定>#</a></h3><p>以下约定假设栈只存储 32 位的数据。</p><ol><li>调用子程序（由调用者完成）：
1.1. 按数字顺序将需要保存的 <code>$t0</code>-<code>$t9</code> 寄存器入栈。
1.2. 将参数放入 <code>$a0</code>-<code>$a3</code>。
1.3. 使用 <code>jal</code> 指令调用子程序。</li><li>子程序 prolog（由子程序在开头完成）：
2.1. 将 <code>$ra</code> 入栈。
2.2. 将调用者的帧指针 <code>$fp</code> 入栈。
2.3. 将需要修改的 <code>$s0</code>-<code>$s7</code> 寄存器入栈。
2.4. 初始化帧指针： <code>$fp = $sp-space</code>，其中 <code>space</code> 指变量占用空间，此处是变量个数的 4 倍。
2.5. 初始化栈指针： <code>$sp = $fp</code>。</li><li>子程序主体：
3.1. 子程序可以修改 <code>$t0</code>-<code>$t9</code>、<code>$a0</code>-<code>$a3</code> 和 2.3 中保存的寄存器。
3.2. 子程序根据 <code>disp($fp)</code> 的形式寻址来使用局部变量。
3.3. 子程序可以通过修改 <code>$sp</code> 在栈上存储数据。
3.4. 如果子程序需要调用其他子程序，也必须遵守这些约定。</li><li>子程序 epilog（由子程序在返回前完成）：
4.1. 将返回值放入 <code>$v0</code>-<code>$v1</code>。
4.2. <code>$sp = $fp + space</code>。
4.3. 将 2.3 中保存的寄存器按与入栈时相反的顺序出栈。
4.4. 将调用者的帧指针 <code>$fp</code> 出栈。
4.5. 将 <code>$ra</code> 出栈。
4.6. 使用 <code>ja $ra</code> 指令返回。</li><li>从子程序重新获得控制权（由调用者完成）：
5.1. 将 1.1 中保存的寄存器按与入栈时相反的顺序出栈。</li></ol><p>进入子程序时栈结构如下图所示：</p><p><img loading=lazy src=/images/mips/stack.png alt=进入子程序时栈的结构></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/mips/>MIPS</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E6%B1%87%E7%BC%96/>汇编</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/mips/see-mips-run/><span class=title>«</span><br><span>MIPS 体系结构</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>