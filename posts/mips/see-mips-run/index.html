<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MIPS 体系结构 | FreeFlyingSheep 的小站</title><meta name=keywords content="MIPS,体系结构"><meta name=description content="根据 See MIPS Run (Second Edition)（中文版）整理。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/mips/see-mips-run/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="MIPS 体系结构"><meta property="og:description" content="根据 See MIPS Run (Second Edition)（中文版）整理。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/mips/see-mips-run/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-13T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="MIPS 体系结构"><meta name=twitter:description content="根据 See MIPS Run (Second Edition)（中文版）整理。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"MIPS 体系结构","item":"https://freeflyingsheep.github.io/posts/mips/see-mips-run/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIPS 体系结构","name":"MIPS 体系结构","description":"根据 See MIPS Run (Second Edition)（中文版）整理。\n","keywords":["MIPS","体系结构"],"articleBody":"根据 See MIPS Run (Second Edition)（中文版）整理。\n流水线 MIPS 的流水线对程序员不完全透明，由此带来了延迟槽问题：\n 分支延迟槽：紧跟在分支指令后的那条指令将被执行，对于条件分支问题需要特别小心 加载延迟槽：紧跟在加载指令后的那条指令不能使用刚刚加载的数据  利用该特性，可以把其他有用的指令移到在延迟槽运行，但现在这些步骤通常由汇编器完成。\n虚拟地址空间 32 位虚拟地址空间 32 位地址空间如下图所示：\n下面只考虑带 MMU 的机器，其余情况需要查相应机器的手册。\n  kuseg（0x0000 0000-0x7FFF FFFF）：作为用户态可用的地址，这些地址将被 MMU 转换，不能在 MMU 设置好前使用。部分文档也将这部分空间称为 useg，但不建议这么称呼。\n  kseg0（0x8000 0000-0x9FFF FFFF）：映射低 512 MB 物理地址，用于存放操作系统核心。通过把最高位清零转换成物理地址，但会经过高速缓存，因此需要先初始化高速缓存。\n  kseg1（0xA000 0000-0xBFFF FFFF）：重复映射低 512 MB 物理地址，用于存取初始的程序的 ROM以及作为 I/O 寄存器。通过把最高 3 位清零转换成物理地址，不会经过告诉缓存，因此是系统重启时唯一能正常工作的地址空间。复位入口点存放于 0xBFC0 0000，对应物理地址 0x1FC0 0000.\n  kseg2（0xC000 0000-0xFFFF FFFF）：由操作系统内核使用，只能在内核态访问，需要被 MMU 转换，不能在 MMU 设置好前使用。\n  64 位虚拟地址空间 64 位地址空间被包在32 位地址空间中，如下图所示：\n高速缓存的重影问题/别名（alias）问题 MIPS 的一级高速缓存通常采用虚拟地址生成索引，而采用物理地址作为标签，即 VIPT（Virtually Indexed Physically Tagged）。当页面大小 $时，就可能出现重影，如下图所示：\n假设 32 位虚拟地址，使用 4K 的页面大小和 32K 四路组相联的高速缓存（8K 的高速缓存索引范围），且某个物理地址被同时映射到了连续的页——虚拟地址 0 和 4K 处。\n当访问虚拟地址 0（0x0000 0000）处的数据时，该处的数据被加载到高速缓存的某个位置。之后访问虚拟地址 4K（0x0000 1000）处的数据，由于页面大小（4K，占 12 位）$MIPS 的二级缓存开始，通常采用物理地址作为索引和标签，即 PIPT（Physically Indexed Physically Tagged），因而不会产生重影问题。\n异常 精确异常 在具备精确异常特性的 CPU 上，任何异常发生时，EPC 都指向异常受害指令。在该指令之前的指令全部执行完毕，之后的指令就好像没执行过一样（重新执行时要保证和没发生异常时的行为一样）。\n在早期非精确异常的 CPU 上，乘除法运算不可停止（即使在异常发生时），乘除法指令和 mflo/mfhi 指令之间，必须插入两条非乘除法指令，来避免因改写 lo 和 hi 寄存器而得到错误的结果。\n异常处理流程 当 MIPS CPU 决定处理异常时，会执行下列操作：\n 设置 EPC 指向重新开始的地址。 设置 SR(EXL) 位，强制 CPU 进入内核态并禁止中断； 设置 Cause 寄存器、BadVaddr（当地址异常时）、某些 MMU 寄存器（当存储系统异常时）。 从异常入口点取指，转到异常处理程序。  异常处理程序执行以下操作：\n 腾出空间完成引导。 查询 Cause(ExcCode) 分派不同的异常。 分配栈空间并保存相应寄存器来构造异常处理环境（可以在分派不同的异常前完成这项工作）。 处理异常。 恢复保存的寄存器，修改SR寄存器来准备返回。 执行 eret 指令（该指令会清楚 SR(EXL) 位并返回到 EPC 保存的地址）从异常返回。  汇编 分类 指令按功能可以分为 12 类：\n 空操作（No-op） 寄存器/寄存器传输（包括条件传送） 常数加载 算数/逻辑指令 整数乘法、除法和求余数 整数乘加 加载和存储 跳转、子程序调用和分支 断点和自陷 CP0 功能（CPU 控制指令） 浮点 用户态下对底层特性的受限访问（rdhwr 和 synci）  特殊指令及其用途 已经在其他章节介绍过的指令不再介绍，此处只列举部分常用的指令。\n连锁加载/条件存储 指令 ll（load linked）和 sc（store conditional）提供“测试——设置”序列，在运行时不保证原子性，但仅当结果恰好是原子性的时候才能返回成功。\n   指令格式 含义     ll d,o(b) d = memory[o + b]，在 CPU 内设置不可见的连锁状态位，同时把加载地址保存在 LLAddr 寄存器中   sc t,o(b) 检查从上次执行的 ll 指令开始以来的“读——改——写”序列是否能原子性的完成，若能，memory[o + b] = t; t = 1；若不能，t = 0    指令 sc 的失败有两种可能的原因：\n 发生了异常 多处理器下另一个 CPU 写入了附近的位置  以下是用该对指令实现“原子加一”操作的示例，对应 Linux 内核调用 atomic_inc(\u0026mycount)：\natomic_inc: ll v0, 0(a0) # a0 指向 mycount addu v0, 1 sc v0, 0(a0) beq v0, zero, atomic_inc # 当 sc 失败时重试 nop jr ra nop  条件传送    指令格式 含义     movz d,s,t if (!t) d = s    数据存储防护    指令格式 含义     sync 存取防护，所有在该指令前发起的存取操作的结果，在该指令后的任何存取操作中都能“见到”    注意，该指令只保证后续指令能“见到”，但对存取操作和 sync 本身执行的相对时序没有保证，仅仅是把该指令和之后的指令存取操作分开，不能保证解决 CPU 的程序执行和外部写之间的时序关系问题。\n用户态下对底层特性的受限访问    指令格式 含义     rdhwr 读取硬件寄存器   synci 为改写指令的程序做高速缓存管理   ","wordCount":"273","inLanguage":"zh-cn","datePublished":"2020-07-13T00:00:00Z","dateModified":"2020-07-13T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/mips/see-mips-run/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>MIPS 体系结构</h1><div class=post-meta>July 13, 2020&nbsp;·&nbsp;2 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e6%b5%81%e6%b0%b4%e7%ba%bf aria-label=流水线>流水线</a></li><li><a href=#%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label=虚拟地址空间>虚拟地址空间</a><ul><li><a href=#32-%e4%bd%8d%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label="32 位虚拟地址空间">32 位虚拟地址空间</a></li><li><a href=#64-%e4%bd%8d%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label="64 位虚拟地址空间">64 位虚拟地址空间</a></li></ul></li><li><a href=#%e9%ab%98%e9%80%9f%e7%bc%93%e5%ad%98%e7%9a%84%e9%87%8d%e5%bd%b1%e9%97%ae%e9%a2%98%e5%88%ab%e5%90%8dalias%e9%97%ae%e9%a2%98 aria-label=高速缓存的重影问题/别名（alias）问题>高速缓存的重影问题/别名（alias）问题</a></li><li><a href=#%e5%bc%82%e5%b8%b8 aria-label=异常>异常</a><ul><li><a href=#%e7%b2%be%e7%a1%ae%e5%bc%82%e5%b8%b8 aria-label=精确异常>精确异常</a></li><li><a href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b aria-label=异常处理流程>异常处理流程</a></li></ul></li><li><a href=#%e6%b1%87%e7%bc%96 aria-label=汇编>汇编</a><ul><li><a href=#%e5%88%86%e7%b1%bb aria-label=分类>分类</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e6%8c%87%e4%bb%a4%e5%8f%8a%e5%85%b6%e7%94%a8%e9%80%94 aria-label=特殊指令及其用途>特殊指令及其用途</a><ul><li><a href=#%e8%bf%9e%e9%94%81%e5%8a%a0%e8%bd%bd%e6%9d%a1%e4%bb%b6%e5%ad%98%e5%82%a8 aria-label=连锁加载/条件存储>连锁加载/条件存储</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e4%bc%a0%e9%80%81 aria-label=条件传送>条件传送</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e9%98%b2%e6%8a%a4 aria-label=数据存储防护>数据存储防护</a></li><li><a href=#%e7%94%a8%e6%88%b7%e6%80%81%e4%b8%8b%e5%af%b9%e5%ba%95%e5%b1%82%e7%89%b9%e6%80%a7%e7%9a%84%e5%8f%97%e9%99%90%e8%ae%bf%e9%97%ae aria-label=用户态下对底层特性的受限访问>用户态下对底层特性的受限访问</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>根据 <em>See MIPS Run (Second Edition)</em>（中文版）整理。</p><h2 id=流水线>流水线<a hidden class=anchor aria-hidden=true href=#流水线>#</a></h2><p>MIPS 的流水线对程序员不完全透明，由此带来了延迟槽问题：</p><ul><li>分支延迟槽：紧跟在分支指令后的那条指令将被执行，对于条件分支问题需要特别小心</li><li>加载延迟槽：紧跟在加载指令后的那条指令不能使用刚刚加载的数据</li></ul><p>利用该特性，可以把其他有用的指令移到在延迟槽运行，但现在这些步骤通常由汇编器完成。</p><h2 id=虚拟地址空间>虚拟地址空间<a hidden class=anchor aria-hidden=true href=#虚拟地址空间>#</a></h2><h3 id=32-位虚拟地址空间>32 位虚拟地址空间<a hidden class=anchor aria-hidden=true href=#32-位虚拟地址空间>#</a></h3><p>32 位地址空间如下图所示：</p><p><img loading=lazy src=/images/mips/address_space_32.png alt="32 位地址空间"></p><p>下面只考虑带 MMU 的机器，其余情况需要查相应机器的手册。</p><ul><li><p><code>kuseg</code>（<code>0x0000 0000</code>-<code>0x7FFF FFFF</code>）：作为用户态可用的地址，这些地址将被 MMU 转换，不能在 MMU 设置好前使用。部分文档也将这部分空间称为 <code>useg</code>，但不建议这么称呼。</p></li><li><p><code>kseg0</code>（<code>0x8000 0000</code>-<code>0x9FFF FFFF</code>）：映射低 512 MB 物理地址，用于存放操作系统核心。通过把最高位清零转换成物理地址，但会经过高速缓存，因此需要先初始化高速缓存。</p></li><li><p><code>kseg1</code>（<code>0xA000 0000</code>-<code>0xBFFF FFFF</code>）：重复映射低 512 MB 物理地址，用于存取初始的程序的 ROM以及作为 I/O 寄存器。通过把最高 3 位清零转换成物理地址，不会经过告诉缓存，因此是系统重启时唯一能正常工作的地址空间。复位入口点存放于 <code>0xBFC0 0000</code>，对应物理地址 <code>0x1FC0 0000</code>.</p></li><li><p><code>kseg2</code>（<code>0xC000 0000</code>-<code>0xFFFF FFFF</code>）：由操作系统内核使用，只能在内核态访问，需要被 MMU 转换，不能在 MMU 设置好前使用。</p></li></ul><h3 id=64-位虚拟地址空间>64 位虚拟地址空间<a hidden class=anchor aria-hidden=true href=#64-位虚拟地址空间>#</a></h3><p>64 位地址空间被包在32 位地址空间中，如下图所示：</p><p><img loading=lazy src=/images/mips/address_space_64.png alt="64 位地址空间"></p><h2 id=高速缓存的重影问题别名alias问题>高速缓存的重影问题/别名（alias）问题<a hidden class=anchor aria-hidden=true href=#高速缓存的重影问题别名alias问题>#</a></h2><p>MIPS 的一级高速缓存通常采用<strong>虚拟地址</strong>生成<strong>索引</strong>，而采用<strong>物理地址</strong>作为<strong>标签</strong>，即 VIPT（Virtually Indexed Physically Tagged）。当<strong>页面大小 $&lt;$ 高速缓存索引范围</strong>时，就可能出现重影，如下图所示：</p><p><img loading=lazy src=/images/cache_alias.png alt=高速缓存重影></p><p>假设 32 位虚拟地址，使用 4K 的页面大小和 32K 四路组相联的高速缓存（8K 的高速缓存索引范围），且某个物理地址被同时映射到了连续的页——虚拟地址 0 和 4K 处。</p><p>当访问虚拟地址 0（0x0000 0000）处的数据时，该处的数据被加载到高速缓存的某个位置。之后访问虚拟地址 4K（0x0000 1000）处的数据，由于页面大小（4K，占 12 位）$&lt;$ 索引范围（8K，占 13 位），此时生成的索引与访问 0 处生成的索引不同（虚拟地址和物理地址的位 0-11 相同，位 12 不同），因此该数据被认为不在缓存中（未命中），然后被加载到高速缓存的另一个位置。现在在高速缓存中存在数据的两个副本，产生了重影。</p><p>MIPS 的二级缓存开始，通常采用<strong>物理地址</strong>作为<strong>索引</strong>和<strong>标签</strong>，即 PIPT（Physically Indexed Physically Tagged），因而不会产生重影问题。</p><h2 id=异常>异常<a hidden class=anchor aria-hidden=true href=#异常>#</a></h2><h3 id=精确异常>精确异常<a hidden class=anchor aria-hidden=true href=#精确异常>#</a></h3><p>在具备精确异常特性的 CPU 上，任何异常发生时，<code>EPC</code> 都指向异常受害指令。在该指令之前的指令全部执行完毕，之后的指令就好像没执行过一样（重新执行时要保证和没发生异常时的行为一样）。</p><p>在早期非精确异常的 CPU 上，乘除法运算不可停止（即使在异常发生时），乘除法指令和 <code>mflo</code>/<code>mfhi</code> 指令之间，必须插入两条非乘除法指令，来避免因改写 <code>lo</code> 和 <code>hi</code> 寄存器而得到错误的结果。</p><h3 id=异常处理流程>异常处理流程<a hidden class=anchor aria-hidden=true href=#异常处理流程>#</a></h3><p>当 MIPS CPU 决定处理异常时，会执行下列操作：</p><ol><li>设置 <code>EPC</code> 指向重新开始的地址。</li><li>设置 <code>SR(EXL)</code> 位，强制 CPU 进入内核态并禁止中断；</li><li>设置 <code>Cause</code> 寄存器、<code>BadVaddr</code>（当地址异常时）、某些 MMU 寄存器（当存储系统异常时）。</li><li>从异常入口点取指，转到异常处理程序。</li></ol><p>异常处理程序执行以下操作：</p><ol><li>腾出空间完成<strong>引导</strong>。</li><li>查询 <code>Cause(ExcCode)</code> <strong>分派不同的异常</strong>。</li><li>分配栈空间并保存相应寄存器来<strong>构造异常处理环境</strong>（可以在分派不同的异常前完成这项工作）。</li><li><strong>处理异常</strong>。</li><li>恢复保存的寄存器，修改SR寄存器来<strong>准备返回</strong>。</li><li>执行 <code>eret</code> 指令（该指令会清楚 <code>SR(EXL)</code> 位并返回到 <code>EPC</code> 保存的地址）<strong>从异常返回</strong>。</li></ol><h2 id=汇编>汇编<a hidden class=anchor aria-hidden=true href=#汇编>#</a></h2><h3 id=分类>分类<a hidden class=anchor aria-hidden=true href=#分类>#</a></h3><p>指令按功能可以分为 12 类：</p><ul><li>空操作（No-op）</li><li>寄存器/寄存器传输（包括条件传送）</li><li>常数加载</li><li>算数/逻辑指令</li><li>整数乘法、除法和求余数</li><li>整数乘加</li><li>加载和存储</li><li>跳转、子程序调用和分支</li><li>断点和自陷</li><li>CP0 功能（CPU 控制指令）</li><li>浮点</li><li>用户态下对底层特性的受限访问（<code>rdhwr</code> 和 <code>synci</code>）</li></ul><h3 id=特殊指令及其用途>特殊指令及其用途<a hidden class=anchor aria-hidden=true href=#特殊指令及其用途>#</a></h3><p>已经在其他章节介绍过的指令不再介绍，此处只列举部分常用的指令。</p><h4 id=连锁加载条件存储>连锁加载/条件存储<a hidden class=anchor aria-hidden=true href=#连锁加载条件存储>#</a></h4><p>指令 <code>ll</code>（load linked）和 <code>sc</code>（store conditional）提供“测试——设置”序列，在运行时不保证原子性，但仅当结果恰好是原子性的时候才能返回成功。</p><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>ll d,o(b)</code></td><td><code>d = memory[o + b]</code>，在 CPU 内设置不可见的连锁状态位，同时把加载地址保存在 <code>LLAddr</code> 寄存器中</td></tr><tr><td><code>sc t,o(b)</code></td><td>检查从上次执行的 <code>ll</code> 指令开始以来的“读——改——写”序列是否能原子性的完成，若能，<code>memory[o + b] = t; t = 1</code>；若不能，<code>t = 0</code></td></tr></tbody></table><p>指令 <code>sc</code> 的失败有两种可能的原因：</p><ul><li>发生了异常</li><li>多处理器下另一个 CPU 写入了附近的位置</li></ul><p>以下是用该对指令实现“原子加一”操作的示例，对应 Linux 内核调用 <code>atomic_inc(&mycount)</code>：</p><pre><code>atomic_inc:
    ll      v0, 0(a0)               # a0 指向 mycount
    addu    v0, 1
    sc      v0, 0(a0)
    beq     v0, zero, atomic_inc    # 当 sc 失败时重试
    nop
    jr      ra
    nop
</code></pre><h4 id=条件传送>条件传送<a hidden class=anchor aria-hidden=true href=#条件传送>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>movz d,s,t</code></td><td><code>if (!t) d = s</code></td></tr></tbody></table><h4 id=数据存储防护>数据存储防护<a hidden class=anchor aria-hidden=true href=#数据存储防护>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>sync</code></td><td>存取防护，所有在该指令前发起的存取操作的结果，在该指令后的任何存取操作中都能“见到”</td></tr></tbody></table><p>注意，该指令只保证后续指令能“见到”，但对存取操作和 <code>sync</code> 本身执行的相对时序没有保证，仅仅是把该指令和之后的指令存取操作分开，不能保证解决 CPU 的程序执行和外部写之间的时序关系问题。</p><h4 id=用户态下对底层特性的受限访问>用户态下对底层特性的受限访问<a hidden class=anchor aria-hidden=true href=#用户态下对底层特性的受限访问>#</a></h4><table><thead><tr><th>指令格式</th><th>含义</th></tr></thead><tbody><tr><td><code>rdhwr</code></td><td>读取硬件寄存器</td></tr><tr><td><code>synci</code></td><td>为改写指令的程序做高速缓存管理</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/mips/>MIPS</a></li><li><a href=https://freeflyingsheep.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/>体系结构</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/mips/supplement/><span class=title>«</span><br><span>MIPS（补充内容）</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/mips/assembly/><span class=title>»</span><br><span>MIPS 汇编</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>