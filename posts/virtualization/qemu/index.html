<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QEMU 简介 | FreeFlyingSheep 的小站</title><meta name=keywords content="QEMU"><meta name=description content="根据 QEMU 官方文档 和 Qemu Detailed Study 整理。"><meta name=author content="FreeFlyingSheep"><link rel=canonical href=https://freeflyingsheep.github.io/posts/virtualization/qemu/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/avatar.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://freeflyingsheep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://freeflyingsheep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://freeflyingsheep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://freeflyingsheep.github.io/apple-touch-icon.png><link rel=mask-icon href=https://freeflyingsheep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="QEMU 简介"><meta property="og:description" content="根据 QEMU 官方文档 和 Qemu Detailed Study 整理。"><meta property="og:type" content="article"><meta property="og:url" content="https://freeflyingsheep.github.io/posts/virtualization/qemu/"><meta property="og:image" content="https://freeflyingsheep.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-08T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-08T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://freeflyingsheep.github.io/papermod-cover.png"><meta name=twitter:title content="QEMU 简介"><meta name=twitter:description content="根据 QEMU 官方文档 和 Qemu Detailed Study 整理。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://freeflyingsheep.github.io/posts/"},{"@type":"ListItem","position":2,"name":"QEMU 简介","item":"https://freeflyingsheep.github.io/posts/virtualization/qemu/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QEMU 简介","name":"QEMU 简介","description":"根据 QEMU 官方文档 和 Qemu Detailed Study 整理。\n","keywords":["QEMU"],"articleBody":"根据 QEMU 官方文档 和 Qemu Detailed Study 整理。\n相关概念介绍 QEMU QEMU 是一个通用的、开源的机器仿真器和虚拟机。\n在系统模式（System mode）下，QEMU 能运行各种不同架构的操作系统。\n在用户模式（User mode）下，QEMU 能运行为其他架构编写的程序。\n通常情况下，我们把 QEMU 要模拟的机器称为目标（Target）机器，运行 QEMU 的机器被被称为主机（Host）。\nTCG 以下部分内容来自维基百科。\n二进制翻译（Binary Translation）指把一种指令集重新编译成另一种指令集，即把源指令序列翻译为目标指令序列。\n二进制翻译分为静态二进制翻译（Static binary translation）和动态二进制翻译（Dynamic binary translation，简称 DBT）两种。\n前者指在执行程序前就将所有指令翻译好，这是很难正确做到的，因为不是所有的代码都能被翻译器发现（某些程序甚至会在运行过程中生成新的指令）；后者通常是执行时即时（Just in Time，简称 JIT）翻译简短的代码序列，然后将结果缓存起来，代码只在被发现和可能的情况下被翻译，并且分支指令会指向已经翻译和保存的代码。\nTCG 是 QEMU 所采用的一种动态二进制翻译技术，全称是 Tiny Code Generator。\n因为在 TCG 模式下，我们希望把源程序指令序列翻译成能在主机上运行的指令序列，所以 TCG 的 Target 是主机，这点一定要注意。\nTCG 的翻译任务主要由两部分组成：第一部分是将目标代码块（翻译块，TB）转换为中间语言（TCG 操作，TCG ops）；第二部分是将 TB 的 TCG ops 转换为主机代码。\n自然，转换过程中会伴随可选的优化过程。\nKVM 以下部分内容来自维基百科。\nKVM（基于内核的虚拟机）是一个 FreeBSD 和 Linux 内核的模块，它允许用户空间的程序访问各种处理器的硬件虚拟化功能。\n当目标架构与主机架构相同时，QEMU 可以利用 KVM 的特殊功能，如加速功能。\nTCG 执行流程简介 代码基于 QEMU 6.0.0 版本。\n程序入口 喜闻乐见的只有 5 行的 int main(int argc, char **argv, char **envp) 函数，位于 softmmu/main.c。\nvoid qemu_init(int argc, char **argv, char **envp) 函数位于 softmmu/vl.c，该函数负责初始化工作，具体细节目前我并不关心。\n大体概括一下，各个体系结构会用 include/qom/object.h 文件的 DEFINE_TYPES(type_array) 来定义 CPU 相关信息的结构体。\n这个结构体包含了指向 static void xxx_cpu_class_init(ObjectClass *oc, void *data) 函数的函数指针，位于 target/xxx/cpu.c 中，其中 xxx 是具体的体系结构名，如 i386、mips。\nxxx_cpu_class_init() 函数会调用 static void xxx_cpu_realizefn(DeviceState *dev, Error **errp) 函数。\n而 xxx_cpu_realizefn() 函数最终会调用 qemu_init_vcpu() 函数来初始化虚拟 CPU。\n创建虚拟 CPU void qemu_init_vcpu(CPUState *cpu) 函数位于 softmmu/cpus.c，这里着重关心这个调用语句：cpus_accel-create_vcpu_thread(cpu);。\ncreate_vcpu_thread 函数指针在 static void tcg_accel_ops_init(AccelOpsClass *ops) 中被初始化，该函数位于 accel/tcg/tcg-accel-ops.c。\ntcg_accel_ops_init 函数指针在 static void tcg_accel_ops_class_init(ObjectClass *oc, void *data) 中被初始化。\n这个函数指针在 tcg_accel_ops_type 结构体中，最终通过 include/qemu/module.h 中的 type_init(function) 宏来初始化。\n回到 create_vcpu_thread 函数指针，该指针在多线程情况下被初始化为 accel/tcg/tcg-accel-ops-mttcg.c 下的 void mttcg_start_vcpu_thread(CPUState *cpu) 函数，单线程情况下则被初始化为 accel/tcg/tcg-accel-ops-rr.c 下的 void rr_start_vcpu_thread(CPUState *cpu) 函数。\nmttcg_start_vcpu_thread() 函数会创建线程执行 static void *mttcg_cpu_thread_fn(void *arg)；rr_start_vcpu_thread() 函数会创建线程执行 static void *rr_cpu_thread_fn(void *arg) 。\n不论是 mttcg_cpu_thread_fn() 还是 rr_cpu_thread_fn() 函数，最终都会调用 int tcg_cpus_exec(CPUState *cpu) 函数。\n而 tcg_cpus_exec() 函数则会调用 cpu_exec() 函数执行代码。\n动态翻译 int cpu_exec(CPUState *cpu) 函数位于 accel/tcg/cpu-exec.c，是 TCG 执行代码的主循环。\n这里只考虑查找生成动态代码的部分，即调用的 static inline TranslationBlock *tb_find(CPUState *cpu, TranslationBlock *last_tb, int tb_exit, uint32_t cflags) 函数。\ntb_find() 函数会调用 accel/tcg/translate-all.c 文件中的 TranslationBlock *tb_gen_code(CPUState *cpu, target_ulong pc, target_ulong cs_base, uint32_t flags, int cflags) 函数来生成动态代码。\ntb_gen_code() 函数会调用体系结构相关的 target/xxx/translate.c 文件中的 void gen_intermediate_code(CPUState *cpu, TranslationBlock *tb, int max_insns) 函数来为生成中间代码做准备。\ngen_intermediate_code() 函数调用 accel/tcg/translator.c 文件中的 void translator_loop(const TranslatorOps *ops, DisasContextBase *db, CPUState *cpu, TranslationBlock *tb, int max_insns)，该函数主体是体系结构无关的，但它又通过关联的函数指针调用体系结构相关的函数来执行翻译。\n执行代码 完成翻译后，cpu_exec() 函数调用 accel/tcg/cpu-exec.c 文件中的 static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb, TranslationBlock **last_tb, int *tb_exit) 函数，该函数会调用 static inline TranslationBlock * QEMU_DISABLE_CFI cpu_tb_exec(CPUState *cpu, TranslationBlock *itb, int *tb_exit) 函数来执行动态翻译的代码。\n之后的操作我暂时不关心，先看到这里为止。\nKVM 执行流程简介 QEMU KVM 模式下，QEMU 与内核 KVM 模块交互，这里只考虑 QEMU 部分，内核部分见 KVM 简介。\nKVM 的初始化流程大体和 TCG 部分介绍的差不多。\n相关的函数和宏如下：\n int main(int argc, char **argv, char **envp)，位于 softmmu/main.c。 void qemu_init(int argc, char **argv, char **envp)，softmmu/vl.c。 type_init(function)，位于 include/qemu/module.h。 static void kvm_accel_ops_class_init(ObjectClass *oc, void *data)，位于 accel/kvm/kvm-accel-ops.c。 static void kvm_start_vcpu_thread(CPUState *cpu)，位于 accel/kvm/kvm-accel-ops.c。 static void *kvm_vcpu_thread_fn(void *arg)，位于 accel/kvm/kvm-accel-ops.c。 int kvm_init_vcpu(CPUState *cpu, Error **errp)，位于 accel/kvm/kvm-all.c。 int kvm_arch_init_vcpu(CPUState *cs)，位于 target/xxx/cpu.c。 int kvm_cpu_exec(CPUState *cpu)，位于 accel/kvm/kvm-all.c。  其中，kvm_vcpu_thread_fn() 函数先调用体系结构无关的初始化函数 kvm_init_vcpu()，再执行 kvm_cpu_exec() 函数来实际执行代码。\nkvm_init_vcpu() 函数会先调用 static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id) 函数来与内核交互创建虚拟 CPU（通过 int kvm_vcpu_ioctl(CPUState *cpu, int type, ...) 函数与内核交互），然后调用体系结构相关的初始化函数 kvm_arch_init_vcpu()。\n而 kvm_cpu_exec() 函数通过 kvm_vcpu_ioctl() 函数与内核交互，切换到 KVM 来实际执行代码。\n具体细节和后续操作我暂时不关心，先鸽了。\n","wordCount":"399","inLanguage":"zh-cn","datePublished":"2021-06-08T00:00:00Z","dateModified":"2021-06-08T00:00:00Z","author":{"@type":"Person","name":"FreeFlyingSheep"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://freeflyingsheep.github.io/posts/virtualization/qemu/"},"publisher":{"@type":"Organization","name":"FreeFlyingSheep 的小站","logo":{"@type":"ImageObject","url":"https://freeflyingsheep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://freeflyingsheep.github.io/ accesskey=h title="FreeFlyingSheep 的小站 (Alt + H)">FreeFlyingSheep 的小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://freeflyingsheep.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://freeflyingsheep.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://freeflyingsheep.github.io/series title=Series><span>Series</span></a></li><li><a href=https://freeflyingsheep.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://freeflyingsheep.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://freeflyingsheep.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://freeflyingsheep.github.io/posts/>Posts</a></div><h1 class=post-title>QEMU 简介</h1><div class=post-meta>June 8, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;FreeFlyingSheep</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5%e4%bb%8b%e7%bb%8d aria-label=相关概念介绍>相关概念介绍</a><ul><li><a href=#qemu aria-label=QEMU>QEMU</a></li><li><a href=#tcg aria-label=TCG>TCG</a></li><li><a href=#kvm aria-label=KVM>KVM</a></li></ul></li><li><a href=#tcg-%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b%e7%ae%80%e4%bb%8b aria-label="TCG 执行流程简介">TCG 执行流程简介</a><ul><li><a href=#%e7%a8%8b%e5%ba%8f%e5%85%a5%e5%8f%a3 aria-label=程序入口>程序入口</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f-cpu aria-label="创建虚拟 CPU">创建虚拟 CPU</a></li><li><a href=#%e5%8a%a8%e6%80%81%e7%bf%bb%e8%af%91 aria-label=动态翻译>动态翻译</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e4%bb%a3%e7%a0%81 aria-label=执行代码>执行代码</a></li></ul></li><li><a href=#kvm-%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b%e7%ae%80%e4%bb%8b aria-label="KVM 执行流程简介">KVM 执行流程简介</a></li></ul></div></details></div><div class=post-content><p>根据 <a href=https://qemu-project.gitlab.io/qemu/index.html>QEMU 官方文档</a> 和 <a href=https://lists.gnu.org/archive/html/qemu-devel/2011-04/pdfhC5rVdz7U8.pdf>Qemu Detailed Study</a> 整理。</p><h2 id=相关概念介绍>相关概念介绍<a hidden class=anchor aria-hidden=true href=#相关概念介绍>#</a></h2><h3 id=qemu>QEMU<a hidden class=anchor aria-hidden=true href=#qemu>#</a></h3><p>QEMU 是一个通用的、开源的机器仿真器和虚拟机。</p><p>在系统模式（System mode）下，QEMU 能运行各种不同架构的操作系统。</p><p>在用户模式（User mode）下，QEMU 能运行为其他架构编写的程序。</p><p>通常情况下，我们把 QEMU 要模拟的机器称为目标（Target）机器，运行 QEMU 的机器被被称为主机（Host）。</p><h3 id=tcg>TCG<a hidden class=anchor aria-hidden=true href=#tcg>#</a></h3><p>以下部分内容来自<a href=https://en.wikipedia.org/wiki/Binary_translation>维基百科</a>。</p><p>二进制翻译（Binary Translation）指把一种指令集重新编译成另一种指令集，即把源指令序列翻译为目标指令序列。</p><p>二进制翻译分为静态二进制翻译（Static binary translation）和动态二进制翻译（Dynamic binary translation，简称 DBT）两种。</p><p>前者指在执行程序前就将所有指令翻译好，这是很难正确做到的，因为不是所有的代码都能被翻译器发现（某些程序甚至会在运行过程中生成新的指令）；后者通常是执行时即时（Just in Time，简称 JIT）翻译简短的代码序列，然后将结果缓存起来，代码只在被发现和可能的情况下被翻译，并且分支指令会指向已经翻译和保存的代码。</p><p>TCG 是 QEMU 所采用的一种动态二进制翻译技术，全称是 Tiny Code Generator。</p><p>因为在 TCG 模式下，我们希望把源程序指令序列翻译成能在主机上运行的指令序列，所以 TCG 的 Target 是主机，这点一定要注意。</p><p>TCG 的翻译任务主要由两部分组成：第一部分是将目标代码块（翻译块，TB）转换为中间语言（TCG 操作，TCG ops）；第二部分是将 TB 的 TCG ops 转换为主机代码。</p><p>自然，转换过程中会伴随可选的优化过程。</p><h3 id=kvm>KVM<a hidden class=anchor aria-hidden=true href=#kvm>#</a></h3><p>以下部分内容来自<a href=https://en.wikipedia.org/wiki/QEMU>维基百科</a>。</p><p>KVM（基于内核的虚拟机）是一个 FreeBSD 和 Linux 内核的模块，它允许用户空间的程序访问各种处理器的硬件虚拟化功能。</p><p>当目标架构与主机架构相同时，QEMU 可以利用 KVM 的特殊功能，如加速功能。</p><h2 id=tcg-执行流程简介>TCG 执行流程简介<a hidden class=anchor aria-hidden=true href=#tcg-执行流程简介>#</a></h2><p>代码基于 QEMU 6.0.0 版本。</p><h3 id=程序入口>程序入口<a hidden class=anchor aria-hidden=true href=#程序入口>#</a></h3><p>喜闻乐见的只有 5 行的 <code>int main(int argc, char **argv, char **envp)</code> 函数，位于 <code>softmmu/main.c</code>。</p><p><code>void qemu_init(int argc, char **argv, char **envp)</code> 函数位于 <code>softmmu/vl.c</code>，该函数负责初始化工作，具体细节目前我并不关心。</p><p>大体概括一下，各个体系结构会用 <code>include/qom/object.h</code> 文件的 <code>DEFINE_TYPES(type_array)</code> 来定义 CPU 相关信息的结构体。</p><p>这个结构体包含了指向 <code>static void xxx_cpu_class_init(ObjectClass *oc, void *data)</code> 函数的函数指针，位于 <code>target/xxx/cpu.c</code> 中，其中 <code>xxx</code> 是具体的体系结构名，如 <code>i386</code>、<code>mips</code>。</p><p><code>xxx_cpu_class_init()</code> 函数会调用 <code>static void xxx_cpu_realizefn(DeviceState *dev, Error **errp)</code> 函数。</p><p>而 <code>xxx_cpu_realizefn()</code> 函数最终会调用 <code>qemu_init_vcpu()</code> 函数来初始化虚拟 CPU。</p><h3 id=创建虚拟-cpu>创建虚拟 CPU<a hidden class=anchor aria-hidden=true href=#创建虚拟-cpu>#</a></h3><p><code>void qemu_init_vcpu(CPUState *cpu)</code> 函数位于 <code>softmmu/cpus.c</code>，这里着重关心这个调用语句：<code>cpus_accel->create_vcpu_thread(cpu);</code>。</p><p><code>create_vcpu_thread</code> 函数指针在 <code>static void tcg_accel_ops_init(AccelOpsClass *ops)</code> 中被初始化，该函数位于 <code>accel/tcg/tcg-accel-ops.c</code>。</p><p><code>tcg_accel_ops_init</code> 函数指针在 <code>static void tcg_accel_ops_class_init(ObjectClass *oc, void *data)</code> 中被初始化。</p><p>这个函数指针在 <code>tcg_accel_ops_type</code> 结构体中，最终通过 <code>include/qemu/module.h</code> 中的 <code>type_init(function)</code> 宏来初始化。</p><p>回到 <code>create_vcpu_thread</code> 函数指针，该指针在多线程情况下被初始化为 <code>accel/tcg/tcg-accel-ops-mttcg.c</code> 下的 <code>void mttcg_start_vcpu_thread(CPUState *cpu)</code> 函数，单线程情况下则被初始化为 <code>accel/tcg/tcg-accel-ops-rr.c</code> 下的 <code>void rr_start_vcpu_thread(CPUState *cpu)</code> 函数。</p><p><code>mttcg_start_vcpu_thread()</code> 函数会创建线程执行 <code>static void *mttcg_cpu_thread_fn(void *arg)</code>；<code>rr_start_vcpu_thread()</code> 函数会创建线程执行 <code>static void *rr_cpu_thread_fn(void *arg)</code> 。</p><p>不论是 <code>mttcg_cpu_thread_fn()</code> 还是 <code>rr_cpu_thread_fn()</code> 函数，最终都会调用 <code>int tcg_cpus_exec(CPUState *cpu)</code> 函数。</p><p>而 <code>tcg_cpus_exec()</code> 函数则会调用 <code>cpu_exec()</code> 函数执行代码。</p><h3 id=动态翻译>动态翻译<a hidden class=anchor aria-hidden=true href=#动态翻译>#</a></h3><p><code>int cpu_exec(CPUState *cpu)</code> 函数位于 <code>accel/tcg/cpu-exec.c</code>，是 TCG 执行代码的主循环。</p><p>这里只考虑查找生成动态代码的部分，即调用的 <code>static inline TranslationBlock *tb_find(CPUState *cpu, TranslationBlock *last_tb, int tb_exit, uint32_t cflags)</code> 函数。</p><p><code>tb_find()</code> 函数会调用 <code>accel/tcg/translate-all.c</code> 文件中的 <code>TranslationBlock *tb_gen_code(CPUState *cpu, target_ulong pc, target_ulong cs_base, uint32_t flags, int cflags)</code> 函数来生成动态代码。</p><p><code>tb_gen_code()</code> 函数会调用体系结构相关的 <code>target/xxx/translate.c</code> 文件中的 <code>void gen_intermediate_code(CPUState *cpu, TranslationBlock *tb, int max_insns)</code> 函数来为生成中间代码做准备。</p><p><code>gen_intermediate_code()</code> 函数调用 <code>accel/tcg/translator.c</code> 文件中的 <code>void translator_loop(const TranslatorOps *ops, DisasContextBase *db, CPUState *cpu, TranslationBlock *tb, int max_insns)</code>，该函数主体是体系结构无关的，但它又通过关联的函数指针调用体系结构相关的函数来执行翻译。</p><h3 id=执行代码>执行代码<a hidden class=anchor aria-hidden=true href=#执行代码>#</a></h3><p>完成翻译后，<code>cpu_exec()</code> 函数调用 <code>accel/tcg/cpu-exec.c</code> 文件中的 <code>static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb, TranslationBlock **last_tb, int *tb_exit)</code> 函数，该函数会调用 <code>static inline TranslationBlock * QEMU_DISABLE_CFI cpu_tb_exec(CPUState *cpu, TranslationBlock *itb, int *tb_exit)</code> 函数来执行动态翻译的代码。</p><p>之后的操作我暂时不关心，先看到这里为止。</p><h2 id=kvm-执行流程简介>KVM 执行流程简介<a hidden class=anchor aria-hidden=true href=#kvm-执行流程简介>#</a></h2><p>QEMU KVM 模式下，QEMU 与内核 KVM 模块交互，这里只考虑 QEMU 部分，内核部分见 <a href=/posts/virtualization/kvm>KVM 简介</a>。</p><p>KVM 的初始化流程大体和 TCG 部分介绍的差不多。</p><p>相关的函数和宏如下：</p><ul><li><code>int main(int argc, char **argv, char **envp)</code>，位于 <code>softmmu/main.c</code>。</li><li><code>void qemu_init(int argc, char **argv, char **envp)</code>，<code>softmmu/vl.c</code>。</li><li><code>type_init(function)</code>，位于 <code>include/qemu/module.h</code>。</li><li><code>static void kvm_accel_ops_class_init(ObjectClass *oc, void *data)</code>，位于 <code>accel/kvm/kvm-accel-ops.c</code>。</li><li><code>static void kvm_start_vcpu_thread(CPUState *cpu)</code>，位于 <code>accel/kvm/kvm-accel-ops.c</code>。</li><li><code>static void *kvm_vcpu_thread_fn(void *arg)</code>，位于 <code>accel/kvm/kvm-accel-ops.c</code>。</li><li><code>int kvm_init_vcpu(CPUState *cpu, Error **errp)</code>，位于 <code>accel/kvm/kvm-all.c</code>。</li><li><code>int kvm_arch_init_vcpu(CPUState *cs)</code>，位于 <code>target/xxx/cpu.c</code>。</li><li><code>int kvm_cpu_exec(CPUState *cpu)</code>，位于 <code>accel/kvm/kvm-all.c</code>。</li></ul><p>其中，<code>kvm_vcpu_thread_fn()</code> 函数先调用体系结构无关的初始化函数 <code>kvm_init_vcpu()</code>，再执行 <code>kvm_cpu_exec()</code> 函数来实际执行代码。</p><p><code>kvm_init_vcpu()</code> 函数会先调用 <code>static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)</code> 函数来与内核交互创建虚拟 CPU（通过 <code>int kvm_vcpu_ioctl(CPUState *cpu, int type, ...)</code> 函数与内核交互），然后调用体系结构相关的初始化函数 <code>kvm_arch_init_vcpu()</code>。</p><p>而 <code>kvm_cpu_exec()</code> 函数通过 <code>kvm_vcpu_ioctl()</code> 函数与内核交互，切换到 KVM 来实际执行代码。</p><p>具体细节和后续操作我暂时不关心，先鸽了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://freeflyingsheep.github.io/tags/qemu/>QEMU</a></li></ul><nav class=paginav><a class=prev href=https://freeflyingsheep.github.io/posts/virtualization/kvm/><span class=title>«</span><br><span>KVM 简介</span></a>
<a class=next href=https://freeflyingsheep.github.io/posts/kernel/memory/bootmem/><span class=title>»</span><br><span>bootmem 分配器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://freeflyingsheep.github.io/>FreeFlyingSheep 的小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>