[{"content":"简单介绍 Linux 内核的 KVM 模块，以 MIPS 体系结构为例，内核源码版本为 5.10.42。\nKVM (Kernel-based Virtual Machine) KVM 是一个完整的虚拟化解决方案，允许用户在特定机器上用虚拟机直接运行未经修改的 Linux 内核。\nKVM 通常和 QEMU 结合使用，见 QEMU 简介。\nKVM 的 API 接口可以参考内核文档。\nKVM 模块有体系结构相关和无关的两部分，简单起见，体系结构相关的部分只考虑 MIPS 的代码，选用内核源码版本为 5.10.42。\n模块初始化 arch/mips/kvm/mips.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  static int __init kvm_mips_init(void) { int ret; if (cpu_has_mmid) { pr_warn(\u0026#34;KVM does not yet support MMIDs. KVM Disabled\\n\u0026#34;); return -EOPNOTSUPP; } ret = kvm_mips_entry_setup(); if (ret) return ret; ret = kvm_init(NULL, sizeof(struct kvm_vcpu), 0, THIS_MODULE); if (ret) return ret; if (boot_cpu_type() == CPU_LOONGSON64) kvm_priority_to_irq = kvm_loongson3_priority_to_irq; register_die_notifier(\u0026amp;kvm_mips_csr_die_notifier); return 0; } module_init(kvm_mips_init);   kvm_mips_init() 函数会调用体系结构无关的初始化函数 kvm_init()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align, struct module *module) { struct kvm_cpu_compat_check c; int r; int cpu; r = kvm_arch_init(opaque); if (r) goto out_fail; /* * kvm_arch_init makes sure there\u0026#39;s at most one caller * for architectures that support multiple implementations, * like intel and amd on x86. * kvm_arch_init must be called before kvm_irqfd_init to avoid creating * conflicts in case kvm is already setup for another implementation. */ r = kvm_irqfd_init(); if (r) goto out_irqfd; if (!zalloc_cpumask_var(\u0026amp;cpus_hardware_enabled, GFP_KERNEL)) { r = -ENOMEM; goto out_free_0; } r = kvm_arch_hardware_setup(opaque); if (r \u0026lt; 0) goto out_free_1; c.ret = \u0026amp;r; c.opaque = opaque; for_each_online_cpu(cpu) { smp_call_function_single(cpu, check_processor_compat, \u0026amp;c, 1); if (r \u0026lt; 0) goto out_free_2; } r = cpuhp_setup_state_nocalls(CPUHP_AP_KVM_STARTING, \u0026#34;kvm/cpu:starting\u0026#34;, kvm_starting_cpu, kvm_dying_cpu); if (r) goto out_free_2; register_reboot_notifier(\u0026amp;kvm_reboot_notifier); /* A kmem cache lets us meet the alignment requirements of fx_save. */ if (!vcpu_align) vcpu_align = __alignof__(struct kvm_vcpu); kvm_vcpu_cache = kmem_cache_create_usercopy(\u0026#34;kvm_vcpu\u0026#34;, vcpu_size, vcpu_align, SLAB_ACCOUNT, offsetof(struct kvm_vcpu, arch), sizeof_field(struct kvm_vcpu, arch), NULL); if (!kvm_vcpu_cache) { r = -ENOMEM; goto out_free_3; } r = kvm_async_pf_init(); if (r) goto out_free; kvm_chardev_ops.owner = module; kvm_vm_fops.owner = module; kvm_vcpu_fops.owner = module; r = misc_register(\u0026amp;kvm_dev); if (r) { pr_err(\u0026#34;kvm: misc device register failed\\n\u0026#34;); goto out_unreg; } register_syscore_ops(\u0026amp;kvm_syscore_ops); kvm_preempt_ops.sched_in = kvm_sched_in; kvm_preempt_ops.sched_out = kvm_sched_out; kvm_init_debug(); r = kvm_vfio_ops_init(); WARN_ON(r); return 0; out_unreg: kvm_async_pf_deinit(); out_free: kmem_cache_destroy(kvm_vcpu_cache); out_free_3: unregister_reboot_notifier(\u0026amp;kvm_reboot_notifier); cpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING); out_free_2: kvm_arch_hardware_unsetup(); out_free_1: free_cpumask_var(cpus_hardware_enabled); out_free_0: kvm_irqfd_exit(); out_irqfd: kvm_arch_exit(); out_fail: return r; } EXPORT_SYMBOL_GPL(kvm_init);   可以看到，kvm_init() 会调用 misc_register() 函数来注册块设备 /dev/kvm。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  static long kvm_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg) { long r = -EINVAL; switch (ioctl) { case KVM_GET_API_VERSION: if (arg) goto out; r = KVM_API_VERSION; break; case KVM_CREATE_VM: r = kvm_dev_ioctl_create_vm(arg); break; case KVM_CHECK_EXTENSION: r = kvm_vm_ioctl_check_extension_generic(NULL, arg); break; case KVM_GET_VCPU_MMAP_SIZE: if (arg) goto out; r = PAGE_SIZE; /* struct kvm_run */ #ifdef CONFIG_X86  r += PAGE_SIZE; /* pio data page */ #endif #ifdef CONFIG_KVM_MMIO  r += PAGE_SIZE; /* coalesced mmio ring page */ #endif  break; case KVM_TRACE_ENABLE: case KVM_TRACE_PAUSE: case KVM_TRACE_DISABLE: r = -EOPNOTSUPP; break; default: return kvm_arch_dev_ioctl(filp, ioctl, arg); } out: return r; } static struct file_operations kvm_chardev_ops = { .unlocked_ioctl = kvm_dev_ioctl, .llseek = noop_llseek, KVM_COMPAT(kvm_dev_ioctl), }; static struct miscdevice kvm_dev = { KVM_MINOR, \u0026#34;kvm\u0026#34;, \u0026amp;kvm_chardev_ops, };   创建虚拟机 TODO\n","permalink":"https://freeflyingsheep.github.io/posts/virtualization/kvm/","summary":"\u003cp\u003e简单介绍 Linux 内核的 KVM 模块，以 MIPS 体系结构为例，内核源码版本为 5.10.42。\u003c/p\u003e","title":"KVM 简介"},{"content":"根据 QEMU 官方文档 和 Qemu Detailed Study 整理。\n相关概念介绍 QEMU QEMU 是一个通用的、开源的机器仿真器和虚拟机。\n在系统模式（System mode）下，QEMU 能运行各种不同架构的操作系统。\n在用户模式（User mode）下，QEMU 能运行为其他架构编写的程序。\n通常情况下，我们把 QEMU 要模拟的机器称为目标（Target）机器，运行 QEMU 的机器被被称为主机（Host）。\nTCG 以下部分内容来自维基百科。\n二进制翻译（Binary Translation）指把一种指令集重新编译成另一种指令集，即把源指令序列翻译为目标指令序列。\n二进制翻译分为静态二进制翻译（Static binary translation）和动态二进制翻译（Dynamic binary translation，简称 DBT）两种。\n前者指在执行程序前就将所有指令翻译好，这是很难正确做到的，因为不是所有的代码都能被翻译器发现（某些程序甚至会在运行过程中生成新的指令）；后者通常是执行时即时（Just in Time，简称 JIT）翻译简短的代码序列，然后将结果缓存起来，代码只在被发现和可能的情况下被翻译，并且分支指令会指向已经翻译和保存的代码。\nTCG 是 QEMU 所采用的一种动态二进制翻译技术，全称是 Tiny Code Generator。\n因为在 TCG 模式下，我们希望把源程序指令序列翻译成能在主机上运行的指令序列，所以 TCG 的 Target 是主机，这点一定要注意。\nTCG 的翻译任务主要由两部分组成：第一部分是将目标代码块（翻译块，TB）转换为中间语言（TCG 操作，TCG ops）；第二部分是将 TB 的 TCG ops 转换为主机代码。\n自然，转换过程中会伴随可选的优化过程。\nKVM 以下部分内容来自维基百科。\nKVM（基于内核的虚拟机）是一个 FreeBSD 和 Linux 内核的模块，它允许用户空间的程序访问各种处理器的硬件虚拟化功能。\n当目标架构与主机架构相同时，QEMU 可以利用 KVM 的特殊功能，如加速功能。\nTCG 执行流程简介 代码基于 QEMU 6.0.0 版本。\n程序入口 喜闻乐见的只有 5 行的 int main(int argc, char **argv, char **envp) 函数，位于 softmmu/main.c。\nvoid qemu_init(int argc, char **argv, char **envp) 函数位于 softmmu/vl.c，该函数负责初始化工作，具体细节目前我并不关心。\n大体概括一下，各个体系结构会用 include/qom/object.h 文件的 DEFINE_TYPES(type_array) 来定义 CPU 相关信息的结构体。\n这个结构体包含了指向 static void xxx_cpu_class_init(ObjectClass *oc, void *data) 函数的函数指针，位于 target/xxx/cpu.c 中，其中 xxx 是具体的体系结构名，如 i386、mips。\nxxx_cpu_class_init() 函数会调用 static void xxx_cpu_realizefn(DeviceState *dev, Error **errp) 函数。\n而 xxx_cpu_realizefn() 函数最终会调用 qemu_init_vcpu() 函数来初始化虚拟 CPU。\n创建虚拟 CPU void qemu_init_vcpu(CPUState *cpu) 函数位于 softmmu/cpus.c，这里着重关心这个调用语句：cpus_accel-\u0026gt;create_vcpu_thread(cpu);。\ncreate_vcpu_thread 函数指针在 static void tcg_accel_ops_init(AccelOpsClass *ops) 中被初始化，该函数位于 accel/tcg/tcg-accel-ops.c。\ntcg_accel_ops_init 函数指针在 static void tcg_accel_ops_class_init(ObjectClass *oc, void *data) 中被初始化。\n这个函数指针在 tcg_accel_ops_type 结构体中，最终通过 include/qemu/module.h 中的 type_init(function) 宏来初始化。\n回到 create_vcpu_thread 函数指针，该指针在多线程情况下被初始化为 accel/tcg/tcg-accel-ops-mttcg.c 下的 void mttcg_start_vcpu_thread(CPUState *cpu) 函数，单线程情况下则被初始化为 accel/tcg/tcg-accel-ops-rr.c 下的 void rr_start_vcpu_thread(CPUState *cpu) 函数。\nmttcg_start_vcpu_thread() 函数会创建线程执行 static void *mttcg_cpu_thread_fn(void *arg)；rr_start_vcpu_thread() 函数会创建线程执行 static void *rr_cpu_thread_fn(void *arg) 。\n不论是 mttcg_cpu_thread_fn() 还是 rr_cpu_thread_fn() 函数，最终都会调用 int tcg_cpus_exec(CPUState *cpu) 函数。\n而 tcg_cpus_exec() 函数则会调用 cpu_exec() 函数执行代码。\n动态翻译 int cpu_exec(CPUState *cpu) 函数位于 accel/tcg/cpu-exec.c，是 TCG 执行代码的主循环。\n这里只考虑查找生成动态代码的部分，即调用的 static inline TranslationBlock *tb_find(CPUState *cpu, TranslationBlock *last_tb, int tb_exit, uint32_t cflags) 函数。\ntb_find() 函数会调用 accel/tcg/translate-all.c 文件中的 TranslationBlock *tb_gen_code(CPUState *cpu, target_ulong pc, target_ulong cs_base, uint32_t flags, int cflags) 函数来生成动态代码。\ntb_gen_code() 函数会调用体系结构相关的 target/xxx/translate.c 文件中的 void gen_intermediate_code(CPUState *cpu, TranslationBlock *tb, int max_insns) 函数来为生成中间代码做准备。\ngen_intermediate_code() 函数调用 accel/tcg/translator.c 文件中的 void translator_loop(const TranslatorOps *ops, DisasContextBase *db, CPUState *cpu, TranslationBlock *tb, int max_insns)，该函数主体是体系结构无关的，但它又通过关联的函数指针调用体系结构相关的函数来执行翻译。\n执行代码 完成翻译后，cpu_exec() 函数调用 accel/tcg/cpu-exec.c 文件中的 static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb, TranslationBlock **last_tb, int *tb_exit) 函数，该函数会调用 static inline TranslationBlock * QEMU_DISABLE_CFI cpu_tb_exec(CPUState *cpu, TranslationBlock *itb, int *tb_exit) 函数来执行动态翻译的代码。\n之后的操作我暂时不关心，先看到这里为止。\nKVM 执行流程简介 QEMU KVM 模式下，QEMU 与内核 KVM 模块交互，这里只考虑 QEMU 部分，内核部分见 KVM 简介。\nKVM 的初始化流程大体和 TCG 部分介绍的差不多。\n相关的函数和宏如下：\n int main(int argc, char **argv, char **envp)，位于 softmmu/main.c。 void qemu_init(int argc, char **argv, char **envp)，softmmu/vl.c。 type_init(function)，位于 include/qemu/module.h。 static void kvm_accel_ops_class_init(ObjectClass *oc, void *data)，位于 accel/kvm/kvm-accel-ops.c。 static void kvm_start_vcpu_thread(CPUState *cpu)，位于 accel/kvm/kvm-accel-ops.c。 static void *kvm_vcpu_thread_fn(void *arg)，位于 accel/kvm/kvm-accel-ops.c。 int kvm_init_vcpu(CPUState *cpu, Error **errp)，位于 accel/kvm/kvm-all.c。 int kvm_arch_init_vcpu(CPUState *cs)，位于 target/xxx/cpu.c。 int kvm_cpu_exec(CPUState *cpu)，位于 accel/kvm/kvm-all.c。  其中，kvm_vcpu_thread_fn() 函数先调用体系结构无关的初始化函数 kvm_init_vcpu()，再执行 kvm_cpu_exec() 函数来实际执行代码。\nkvm_init_vcpu() 函数会先调用 static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id) 函数来与内核交互创建虚拟 CPU（通过 int kvm_vcpu_ioctl(CPUState *cpu, int type, ...) 函数与内核交互），然后调用体系结构相关的初始化函数 kvm_arch_init_vcpu()。\n而 kvm_cpu_exec() 函数通过 kvm_vcpu_ioctl() 函数与内核交互，切换到 KVM 来实际执行代码。\n具体细节和后续操作我暂时不关心，先鸽了。\n","permalink":"https://freeflyingsheep.github.io/posts/virtualization/qemu/","summary":"\u003cp\u003e根据 \u003ca href=\"https://qemu-project.gitlab.io/qemu/index.html\"\u003eQEMU 官方文档\u003c/a\u003e 和 \u003ca href=\"https://lists.gnu.org/archive/html/qemu-devel/2011-04/pdfhC5rVdz7U8.pdf\"\u003eQemu Detailed Study\u003c/a\u003e 整理。\u003c/p\u003e","title":"QEMU 简介"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍 bootmem 分配器。\n数据结构 TODO\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/bootmem/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍 bootmem 分配器。\u003c/p\u003e","title":"bootmem 分配器"},{"content":"根据 Github Issue \u0026amp; PR templates 相关文档整理。\nGithub 模板 仓库的维护者可以添加模板，来帮助贡献者创建高质量的 Issue 和 Pull request。\nIssue 模板 Issue 模板介绍 Issue 模板放置于 .github/ISSUE_TEMPLATE 文件夹，里面可以创建 config.yml 来配置模板选择器。\nconfig.yml 的官方示例如下：\n1 2 3 4 5 6 7 8  blank_issues_enabled: false contact_links: - name: GitHub Community Support url: https://github.community/ about: Please ask and answer questions here. - name: GitHub Security Bug Bounty url: https://bounty.github.com/ about: Please report security vulnerabilities here.   blank_issues_enabled 选项用于配置是否允许发起空 Issue。\ncontact_links 用于指定一些额外的链接，比如有些问题不属于该项目，而是相关工具的问题，可以让用户去那些工具的官网提 Issue。\nIssue 模板实例 Pro Git, Second Edition 项目的 .github/ISSUE_TEMPLATE/config.yml 文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  contact_links: - name: Translation bug url: https://github.com/progit/progit2/blob/master/TRANSLATING.md about: Refer to this table to find out where to report translation bugs. - name: Report bugs for git-scm.com site url: https://github.com/git/git-scm.com/issues/ about: Please report problems with the git-scm.com site here. - name: Bug is about Git program itself url: https://git-scm.com/community about: Please report problems with the Git program here. - name: Bug is about Git for Windows url: https://github.com/git-for-windows/git/issues about: Please report problems with Git for Windows here.   该项目新建 Issue 的页面如下：\n其中，只有第一个 Bug report 是项目里添加的模板，位于 .github/ISSUE_TEMPLATE/bug_report.md，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  --- name: Bug report about: Create a report to help us improve title: \u0026#39;\u0026#39; labels: \u0026#39;\u0026#39; assignees: \u0026#39;\u0026#39; --- \u0026lt;!-- Before filing a bug please check the following: --\u0026gt; \u0026lt;!-- * There\u0026#39;s no existing/similar bug report. --\u0026gt; \u0026lt;!-- * This bug report is about a single actionable bug. --\u0026gt; \u0026lt;!-- * This bug is about the Pro Git book, version 2, English language. --\u0026gt; \u0026lt;!-- * This bug is about the book as found on the [website](https://www.git-scm.com/book/en/v2)or the pdf. --\u0026gt; \u0026lt;!-- * If you found an issue in the pdf/epub/mobi files, you\u0026#39;ve checked if the problem is also present in the Pro Git book on the [website](https://www.git-scm.com/book/en/v2). --\u0026gt; **Which version of the book is affected?** \u0026lt;!-- It\u0026#39;s important for us to know if the problem is in the source or in the tooling for the pdf/epub/mobi files. --\u0026gt; \u0026lt;!-- Therefore, please write whether the problem is with the files, the online book, or both. --\u0026gt; **Describe the bug:** \u0026lt;!-- A clear and concise description of what the bug is. --\u0026gt; **Steps to reproduce:** \u0026lt;!-- Please write the steps needed to reproduce the bug here. --\u0026gt; \u0026lt;!-- 1. Go to \u0026#39;...\u0026#39; --\u0026gt; \u0026lt;!-- 2. Click on \u0026#39;....\u0026#39; --\u0026gt; \u0026lt;!-- 3. Scroll down to \u0026#39;....\u0026#39; --\u0026gt; \u0026lt;!-- 4. See error --\u0026gt; **Expected behavior:** \u0026lt;!-- A clear and concise description of what you expected to happen. --\u0026gt; **Screenshots:** \u0026lt;!-- If applicable, add screenshots to help explain your problem. --\u0026gt; **Additional context:** \u0026lt;!-- Add any other context about the problem here. --\u0026gt; \u0026lt;!-- You can also put references to similar bugs here. --\u0026gt; **Desktop:** \u0026lt;!-- If you\u0026#39;ve used a desktop/laptop to access the content, please fill in this form. --\u0026gt; \u0026lt;!-- Example: Windows 10 Home Edition, Firefox, version 66.0.2 --\u0026gt; - Operating system: - Browser/application: - Browser/application version: **Smartphone:** \u0026lt;!-- If you\u0026#39;ve used a smartphone to access the content, please fill in this form. --\u0026gt; \u0026lt;!-- Example: iPhone 6, iOS 12.2, Safari, version 22 --\u0026gt; - Device: - OS: - Browser/application: - Browser/application version: **E-book reader:** \u0026lt;!-- If you\u0026#39;ve used an e-book reader to access the content, please fill in this form. --\u0026gt; \u0026lt;!-- Example: Amazon Kindle Paperwhite 10th generation, software update 5.11.1 --\u0026gt; - Device: - Software Update:   Pull request 模板 Pull request 模板介绍 Pull request 模板可以放置于 docs 目录或者 .github 目录。\n如果只需要单一的模板，创建 docs/pull_request_template.md 或者 .github/pull_request_template.md 文件即可。\n如果需要多个模板，将模板集中放置于 docs/PULL_REQUEST_TEMPLATE 或者 .github/PULL_REQUEST_TEMPLATE 文件夹。\nPull request 模板实例 Pro Git, Second Edition 项目的 Pull request 模板位于 .github/pull_request_template.md，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;!-- Thanks for contributing! --\u0026gt; \u0026lt;!-- Before you start on a large rewrite or other major change: open a new issue first, to discuss the proposed changes. --\u0026gt; \u0026lt;!-- Should your changes appear in a printed edition, you\u0026#39;ll be included in the contributors list. --\u0026gt; \u0026lt;!-- Mark the checkbox [X] or [x] if you agree with the item. --\u0026gt; - [ ] I provide my work under the [project license](https://github.com/progit/progit2/blob/master/LICENSE.asc). - [ ] I grant such license of my work as is required for the purposes of future print editions to [Ben Straub](https://github.com/ben) and [Scott Chacon](https://github.com/schacon). ## Changes  - ## Context \u0026lt;!-- List related issues. Provide the necessary context to understand the changes you made. Are you fixing an issue with this pull-request? Use the \u0026#34;Fixes\u0026#34; keyword, to close the issue automatically after your work is merged. Fixes #123Fixes #456--\u0026gt;   ","permalink":"https://freeflyingsheep.github.io/posts/tips/github/","summary":"\u003cp\u003e根据 \u003ca href=\"https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests\"\u003eGithub Issue \u0026amp; PR templates\u003c/a\u003e 相关文档整理。\u003c/p\u003e","title":"Github 模板"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。\n基数树简介 前缀树（字典树） 该部分内容来源于维基百科。\n 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。\n键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。\ntrie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串比特，可以用于表示整数或者内存地址。\n 基数树 该部分内容来源于维基百科。\n 在计算机科学中，基数树（也叫基数特里树或压缩前缀树）是一种数据结构，是一种更节省空间的Trie（前缀树），其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。因此每个内部节点的子节点数最多为基数树的基数r ，其中r为正整数，x为2的幂，x≥1，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。\n  基数树支持插入、删除、查找操作。查找包括完全匹配、前缀匹配、前驱查找、后继查找。所有这些操作都是O(k)复杂度，其中k是所有字符串中最大的长度。\n 内核基数树的使用 内核红黑树的实现称为 radix_tree，头文件为 include/linux/radix-tree.h。下面只介绍几个基本的 API 和相关实现。\n基数树的创建 最简单的方式，直接使用宏创建：\n1  RADIX_TREE(name, gfp_mask);   或者，也可以手工创建：\n1 2  struct radix_tree_root tree; INIT_RADIX_TREE(\u0026amp;tree, gfp_mask);   基数树的查找 1  void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index);   该函数在以 root 为根的基数树中查找索引为 index 的内容，返回查找的内容的地址（没找到要查找的内容则返回 NULL）。\n1  unsigned int radix_tree_gang_lookup(struct radix_tree_root *root, void **results, unsigned long first_index, unsigned int max_items);   该函数在以 root 为根的基数树中查找非空内容，从索引为 first_index 的结点开始，最多查找 max_items 个非空内容，查找结果放 results 中，返回找到的个数。\n基数树的插入 1  int radix_tree_insert(struct radix_tree_root *root, unsigned long index, void *item);   该函数将内容 item 插入到以 root 为根的基数树中索引为 index 的地方，插入成功返回 0，失败返回错误值。\n基数树的删除 1  void *radix_tree_delete(struct radix_tree_root *root, unsigned long index);   该函数将索引为 index 的内容从以 root 为根的基数树中删除，返回删除的内容的地址（要删除的内容不存在则返回 NULL）。\n内核基数树的的实现 内核基数树的实现均位于 lib/radix-tree.c 和 include/linux/radix-tree.h。我只求会用 API，具体实现的原理要参考数据结构书籍，下面也只贴出部分核心代码。\n基数树的定义 根的定义如下：\n1 2 3 4 5 6  /* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */ struct radix_tree_root { unsigned int height; gfp_t gfp_mask; struct radix_tree_node *rnode; };   结点的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define RADIX_TREE_MAX_TAGS 2  #ifdef __KERNEL__ #define RADIX_TREE_MAP_SHIFT (CONFIG_BASE_SMALL ? 4 : 6) #else #define RADIX_TREE_MAP_SHIFT 3 /* For more stressful testing */#endif  #define RADIX_TREE_MAP_SIZE (1UL \u0026lt;\u0026lt; RADIX_TREE_MAP_SHIFT)  #define RADIX_TREE_TAG_LONGS \\ ((RADIX_TREE_MAP_SIZE + BITS_PER_LONG - 1) / BITS_PER_LONG)  struct radix_tree_node { unsigned int height; /* Height from the bottom */ unsigned int count; struct rcu_head rcu_head; void *slots[RADIX_TREE_MAP_SIZE]; unsigned long tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS]; };   其中，BITS_PER_LONG 是体系结构相关的，指该体系结构下 long 占多少位，该宏在 32 位系统下通常是 32，64 位系统下通常是 64。\n基数树创建的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #define RADIX_TREE_INIT(mask) { \\ .height = 0, \\ .gfp_mask = (mask), \\ .rnode = NULL, \\ }  #define RADIX_TREE(name, mask) \\ struct radix_tree_root name = RADIX_TREE_INIT(mask)  #define INIT_RADIX_TREE(root, mask) \\ do { \\ (root)-\u0026gt;height = 0; \\ (root)-\u0026gt;gfp_mask = (mask); \\ (root)-\u0026gt;rnode = NULL; \\ } while (0)   辅助函数/宏的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define RADIX_TREE_INDIRECT_PTR 1  static inline void *radix_tree_indirect_to_ptr(void *ptr) { return (void *)((unsigned long)ptr \u0026amp; ~RADIX_TREE_INDIRECT_PTR); } static inline int radix_tree_is_indirect_ptr(void *ptr) { return (int)((unsigned long)ptr \u0026amp; RADIX_TREE_INDIRECT_PTR); } /* * Return the maximum key which can be store into a * radix tree with height HEIGHT. */ static inline unsigned long radix_tree_maxindex(unsigned int height) { return height_to_maxindex[height]; }   对于前两个函数，由于地址总是对齐的，不管哪种体系结构，地址的最后一位总是 0。所以可以利用这一位，存储该结点是直接结点（指针直接指向内容）还是间接结点（指针指向其他树的结点）。\n基数树的查找的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  #define RADIX_TREE_MAP_MASK (RADIX_TREE_MAP_SIZE-1)  /* * is_slot == 1 : search for the slot. * is_slot == 0 : search for the node. */ static void *radix_tree_lookup_element(struct radix_tree_root *root, unsigned long index, int is_slot) { unsigned int height, shift; struct radix_tree_node *node, **slot; node = rcu_dereference_raw(root-\u0026gt;rnode); if (node == NULL) return NULL; if (!radix_tree_is_indirect_ptr(node)) { if (index \u0026gt; 0) return NULL; return is_slot ? (void *)\u0026amp;root-\u0026gt;rnode : node; } node = radix_tree_indirect_to_ptr(node); height = node-\u0026gt;height; if (index \u0026gt; radix_tree_maxindex(height)) return NULL; shift = (height-1) * RADIX_TREE_MAP_SHIFT; do { slot = (struct radix_tree_node **) (node-\u0026gt;slots + ((index\u0026gt;\u0026gt;shift) \u0026amp; RADIX_TREE_MAP_MASK)); node = rcu_dereference_raw(*slot); if (node == NULL) return NULL; shift -= RADIX_TREE_MAP_SHIFT; height--; } while (height \u0026gt; 0); return is_slot ? (void *)slot:node; } /** * radix_tree_lookup - perform lookup operation on a radix tree * @root: radix tree root * @index: index key * * Lookup the item at the position @index in the radix tree @root. * * This function can be called under rcu_read_lock, however the caller * must manage lifetimes of leaf nodes (eg. RCU may also be used to free * them safely). No RCU barriers are required to access or modify the * returned item, however. */ void *radix_tree_lookup(struct radix_tree_root *root, unsigned long index) { return radix_tree_lookup_element(root, index, 0); } EXPORT_SYMBOL(radix_tree_lookup);   radix_tree_lookup() 用于查找单个内容，RCU 相关的内容还没看，这里先无视（见 TODO 列表）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  static unsigned int __lookup(struct radix_tree_node *slot, void ***results, unsigned long index, unsigned int max_items, unsigned long *next_index) { unsigned int nr_found = 0; unsigned int shift, height; unsigned long i; height = slot-\u0026gt;height; if (height == 0) goto out; shift = (height-1) * RADIX_TREE_MAP_SHIFT; for ( ; height \u0026gt; 1; height--) { i = (index \u0026gt;\u0026gt; shift) \u0026amp; RADIX_TREE_MAP_MASK; for (;;) { if (slot-\u0026gt;slots[i] != NULL) break; index \u0026amp;= ~((1UL \u0026lt;\u0026lt; shift) - 1); index += 1UL \u0026lt;\u0026lt; shift; if (index == 0) goto out; /* 32-bit wraparound */ i++; if (i == RADIX_TREE_MAP_SIZE) goto out; } shift -= RADIX_TREE_MAP_SHIFT; slot = rcu_dereference_raw(slot-\u0026gt;slots[i]); if (slot == NULL) goto out; } /* Bottom level: grab some items */ for (i = index \u0026amp; RADIX_TREE_MAP_MASK; i \u0026lt; RADIX_TREE_MAP_SIZE; i++) { index++; if (slot-\u0026gt;slots[i]) { results[nr_found++] = \u0026amp;(slot-\u0026gt;slots[i]); if (nr_found == max_items) goto out; } } out: *next_index = index; return nr_found; } /** * radix_tree_gang_lookup - perform multiple lookup on a radix tree * @root: radix tree root * @results: where the results of the lookup are placed * @first_index: start the lookup from this key * @max_items: place up to this many items at *results * * Performs an index-ascending scan of the tree for present items. Places * them at *@results and returns the number of items which were placed at * *@results. * * The implementation is naive. * * Like radix_tree_lookup, radix_tree_gang_lookup may be called under * rcu_read_lock. In this case, rather than the returned results being * an atomic snapshot of the tree at a single point in time, the semantics * of an RCU protected gang lookup are as though multiple radix_tree_lookups * have been issued in individual locks, and results stored in \u0026#39;results\u0026#39;. */ unsigned int radix_tree_gang_lookup(struct radix_tree_root *root, void **results, unsigned long first_index, unsigned int max_items) { unsigned long max_index; struct radix_tree_node *node; unsigned long cur_index = first_index; unsigned int ret; node = rcu_dereference_raw(root-\u0026gt;rnode); if (!node) return 0; if (!radix_tree_is_indirect_ptr(node)) { if (first_index \u0026gt; 0) return 0; results[0] = node; return 1; } node = radix_tree_indirect_to_ptr(node); max_index = radix_tree_maxindex(node-\u0026gt;height); ret = 0; while (ret \u0026lt; max_items) { unsigned int nr_found, slots_found, i; unsigned long next_index; /* Index of next search */ if (cur_index \u0026gt; max_index) break; slots_found = __lookup(node, (void ***)results + ret, cur_index, max_items - ret, \u0026amp;next_index); nr_found = 0; for (i = 0; i \u0026lt; slots_found; i++) { struct radix_tree_node *slot; slot = *(((void ***)results)[ret + i]); if (!slot) continue; results[ret + nr_found] = rcu_dereference_raw(slot); nr_found++; } ret += nr_found; if (next_index == 0) break; cur_index = next_index; } return ret; } EXPORT_SYMBOL(radix_tree_gang_lookup);   radix_tree_gang_lookup() 用于查找多个内容。\n其他查找函数都是同理，只是查找的东西，比如查找 slot 和 tag 等。\n基数树的插入的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  static inline gfp_t root_gfp_mask(struct radix_tree_root *root) { return root-\u0026gt;gfp_mask \u0026amp; __GFP_BITS_MASK; } /* * This assumes that the caller has performed appropriate preallocation, and * that the caller has pinned this thread of control to the current CPU. */ static struct radix_tree_node * radix_tree_node_alloc(struct radix_tree_root *root) { struct radix_tree_node *ret = NULL; gfp_t gfp_mask = root_gfp_mask(root); if (!(gfp_mask \u0026amp; __GFP_WAIT)) { struct radix_tree_preload *rtp; /* * Provided the caller has preloaded here, we will always * succeed in getting a node here (and never reach * kmem_cache_alloc) */ rtp = \u0026amp;__get_cpu_var(radix_tree_preloads); if (rtp-\u0026gt;nr) { ret = rtp-\u0026gt;nodes[rtp-\u0026gt;nr - 1]; rtp-\u0026gt;nodes[rtp-\u0026gt;nr - 1] = NULL; rtp-\u0026gt;nr--; } } if (ret == NULL) ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask); BUG_ON(radix_tree_is_indirect_ptr(ret)); return ret; } /* * Extend a radix tree so it can store key @index. */ static int radix_tree_extend(struct radix_tree_root *root, unsigned long index) { struct radix_tree_node *node; unsigned int height; int tag; /* Figure out what the height should be. */ height = root-\u0026gt;height + 1; while (index \u0026gt; radix_tree_maxindex(height)) height++; if (root-\u0026gt;rnode == NULL) { root-\u0026gt;height = height; goto out; } do { unsigned int newheight; if (!(node = radix_tree_node_alloc(root))) return -ENOMEM; /* Increase the height. */ node-\u0026gt;slots[0] = radix_tree_indirect_to_ptr(root-\u0026gt;rnode); /* Propagate the aggregated tag info into the new root */ for (tag = 0; tag \u0026lt; RADIX_TREE_MAX_TAGS; tag++) { if (root_tag_get(root, tag)) tag_set(node, tag, 0); } newheight = root-\u0026gt;height+1; node-\u0026gt;height = newheight; node-\u0026gt;count = 1; node = radix_tree_ptr_to_indirect(node); rcu_assign_pointer(root-\u0026gt;rnode, node); root-\u0026gt;height = newheight; } while (height \u0026gt; root-\u0026gt;height); out: return 0; } /** * radix_tree_insert - insert into a radix tree * @root: radix tree root * @index: index key * @item: item to insert * * Insert an item into the radix tree at position @index. */ int radix_tree_insert(struct radix_tree_root *root, unsigned long index, void *item) { struct radix_tree_node *node = NULL, *slot; unsigned int height, shift; int offset; int error; BUG_ON(radix_tree_is_indirect_ptr(item)); /* Make sure the tree is high enough. */ if (index \u0026gt; radix_tree_maxindex(root-\u0026gt;height)) { error = radix_tree_extend(root, index); if (error) return error; } slot = radix_tree_indirect_to_ptr(root-\u0026gt;rnode); height = root-\u0026gt;height; shift = (height-1) * RADIX_TREE_MAP_SHIFT; offset = 0; /* uninitialised var warning */ while (height \u0026gt; 0) { if (slot == NULL) { /* Have to add a child node. */ if (!(slot = radix_tree_node_alloc(root))) return -ENOMEM; slot-\u0026gt;height = height; if (node) { rcu_assign_pointer(node-\u0026gt;slots[offset], slot); node-\u0026gt;count++; } else rcu_assign_pointer(root-\u0026gt;rnode, radix_tree_ptr_to_indirect(slot)); } /* Go a level down */ offset = (index \u0026gt;\u0026gt; shift) \u0026amp; RADIX_TREE_MAP_MASK; node = slot; slot = node-\u0026gt;slots[offset]; shift -= RADIX_TREE_MAP_SHIFT; height--; } if (slot != NULL) return -EEXIST; if (node) { node-\u0026gt;count++; rcu_assign_pointer(node-\u0026gt;slots[offset], item); BUG_ON(tag_get(node, 0, offset)); BUG_ON(tag_get(node, 1, offset)); } else { rcu_assign_pointer(root-\u0026gt;rnode, item); BUG_ON(root_tag_get(root, 0)); BUG_ON(root_tag_get(root, 1)); } return 0; } EXPORT_SYMBOL(radix_tree_insert);   基数树的删除的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  /** * radix_tree_shrink - shrink height of a radix tree to minimal * @root radix tree root */ static inline void radix_tree_shrink(struct radix_tree_root *root) { /* try to shrink tree height */ while (root-\u0026gt;height \u0026gt; 0) { struct radix_tree_node *to_free = root-\u0026gt;rnode; void *newptr; BUG_ON(!radix_tree_is_indirect_ptr(to_free)); to_free = radix_tree_indirect_to_ptr(to_free); /* * The candidate node has more than one child, or its child * is not at the leftmost slot, we cannot shrink. */ if (to_free-\u0026gt;count != 1) break; if (!to_free-\u0026gt;slots[0]) break; /* * We don\u0026#39;t need rcu_assign_pointer(), since we are simply * moving the node from one part of the tree to another. If * it was safe to dereference the old pointer to it * (to_free-\u0026gt;slots[0]), it will be safe to dereference the new * one (root-\u0026gt;rnode). */ newptr = to_free-\u0026gt;slots[0]; if (root-\u0026gt;height \u0026gt; 1) newptr = radix_tree_ptr_to_indirect(newptr); root-\u0026gt;rnode = newptr; root-\u0026gt;height--; radix_tree_node_free(to_free); } } static inline void radix_tree_node_free(struct radix_tree_node *node) { call_rcu(\u0026amp;node-\u0026gt;rcu_head, radix_tree_node_rcu_free); } /** * radix_tree_delete - delete an item from a radix tree * @root: radix tree root * @index: index key * * Remove the item at @index from the radix tree rooted at @root. * * Returns the address of the deleted item, or NULL if it was not present. */ void *radix_tree_delete(struct radix_tree_root *root, unsigned long index) { /* * The radix tree path needs to be one longer than the maximum path * since the \u0026#34;list\u0026#34; is null terminated. */ struct radix_tree_path path[RADIX_TREE_MAX_PATH + 1], *pathp = path; struct radix_tree_node *slot = NULL; struct radix_tree_node *to_free; unsigned int height, shift; int tag; int offset; height = root-\u0026gt;height; if (index \u0026gt; radix_tree_maxindex(height)) goto out; slot = root-\u0026gt;rnode; if (height == 0) { root_tag_clear_all(root); root-\u0026gt;rnode = NULL; goto out; } slot = radix_tree_indirect_to_ptr(slot); shift = (height - 1) * RADIX_TREE_MAP_SHIFT; pathp-\u0026gt;node = NULL; do { if (slot == NULL) goto out; pathp++; offset = (index \u0026gt;\u0026gt; shift) \u0026amp; RADIX_TREE_MAP_MASK; pathp-\u0026gt;offset = offset; pathp-\u0026gt;node = slot; slot = slot-\u0026gt;slots[offset]; shift -= RADIX_TREE_MAP_SHIFT; height--; } while (height \u0026gt; 0); if (slot == NULL) goto out; /* * Clear all tags associated with the just-deleted item */ for (tag = 0; tag \u0026lt; RADIX_TREE_MAX_TAGS; tag++) { if (tag_get(pathp-\u0026gt;node, tag, pathp-\u0026gt;offset)) radix_tree_tag_clear(root, index, tag); } to_free = NULL; /* Now free the nodes we do not need anymore */ while (pathp-\u0026gt;node) { pathp-\u0026gt;node-\u0026gt;slots[pathp-\u0026gt;offset] = NULL; pathp-\u0026gt;node-\u0026gt;count--; /* * Queue the node for deferred freeing after the * last reference to it disappears (set NULL, above). */ if (to_free) radix_tree_node_free(to_free); if (pathp-\u0026gt;node-\u0026gt;count) { if (pathp-\u0026gt;node == radix_tree_indirect_to_ptr(root-\u0026gt;rnode)) radix_tree_shrink(root); goto out; } /* Node with zero slots in use so free it */ to_free = pathp-\u0026gt;node; pathp--; } root_tag_clear_all(root); root-\u0026gt;height = 0; root-\u0026gt;rnode = NULL; if (to_free) radix_tree_node_free(to_free); out: return slot; } EXPORT_SYMBOL(radix_tree_delete);   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/radix-tree/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核基数树。\u003c/p\u003e","title":"内核基数树"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存映射。\n高端内存页框的内存映射简介 内核可以采用三种不同的机制讲页框映射到高端内存：永久内核映射、临时内核映射和非连续内存分配。其中，非连续内存分配的部分见非连续内存分配。\n永久内核映射 永久内核映射允许内核建立高端页框到内核地址空间的长期映射。当空闲页表项不存在（高端内存上没有页表项可以用作页框的窗口）时，可能会阻塞当前进程。因此，它不能用于中断处理程序和可延迟函数。\n页表 永久映射使用主内核页表中的一个专门页表。\nmm/highmem.c：\n1  pte_t * pkmap_page_table;   页表的表项数由 LAST_PKMAP 宏决定，该宏是体系结构相关的。\narch/x86/include/asm/pgtable_32_types.h：\n1 2 3 4 5  #ifdef CONFIG_X86_PAE #define LAST_PKMAP 512 #else #define LAST_PKMAP 1024 #endif   页表映射的线性地址从 PKMAP_BASE（该宏的实现与 vsyscall 有关，不属于本系列学习笔记的范畴）开始，每个表项都有一个计数器，存放于数组 pkmap_count 中。\nmm/highmem.c：\n1  static int pkmap_count[LAST_PKMAP];   为了页框与映射的线性地址之间的联系，内核使用了 page_address_htable 散列表。\nmm/highmem.c：\n1 2 3 4 5 6 7 8 9  static struct page_address_slot { struct list_head lh; /* List of page_address_maps */ spinlock_t lock; /* Protect this bucket\u0026#39;s list */ } ____cacheline_aligned_in_smp page_address_htable[1\u0026lt;\u0026lt;PA_HASH_ORDER]; static struct page_address_slot *page_slot(struct page *page) { return \u0026amp;page_address_htable[hash_ptr(page, PA_HASH_ORDER)]; }   kmap() 函数 kmap() 函数用于建立永久内核映射，该函数是体系结构相关的。\narch/x86/mm/highmem_32.c：\n1 2 3 4 5 6 7  void *kmap(struct page *page) { might_sleep(); if (!PageHighMem(page)) return page_address(page); return kmap_high(page); }   PageHighMem() 宏定义于 include/linux/page-flags.h，该宏会根据内存管理区（Zone）来判断页框是否在高端内存。\n如果不在高端内存，则线性地址一定存在，调用 page_address() 函数根据物理地址计算出对应的线性地址。\ninclude/linux/mm.h：\n1 2 3 4  static __always_inline void *lowmem_page_address(struct page *page) { return __va(page_to_pfn(page) \u0026lt;\u0026lt; PAGE_SHIFT); }   mm/highmem.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /** * page_address - get the mapped virtual address of a page * @page: \u0026amp;struct page to get the virtual address of * * Returns the page\u0026#39;s virtual address. */ void *page_address(struct page *page) { unsigned long flags; void *ret; struct page_address_slot *pas; if (!PageHighMem(page)) return lowmem_page_address(page); pas = page_slot(page); ret = NULL; spin_lock_irqsave(\u0026amp;pas-\u0026gt;lock, flags); if (!list_empty(\u0026amp;pas-\u0026gt;lh)) { struct page_address_map *pam; list_for_each_entry(pam, \u0026amp;pas-\u0026gt;lh, list) { if (pam-\u0026gt;page == page) { ret = pam-\u0026gt;virtual; goto done; } } } done: spin_unlock_irqrestore(\u0026amp;pas-\u0026gt;lock, flags); return ret; } EXPORT_SYMBOL(page_address);   如果页框在高端内存，则调用 kmap_high() 函数。\nmm/highmem.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * kmap_high - map a highmem page into memory * @page: \u0026amp;struct page to map * * Returns the page\u0026#39;s virtual memory address. * * We cannot call this from interrupts, as it may block. */ void *kmap_high(struct page *page) { unsigned long vaddr; /* * For highmem pages, we can\u0026#39;t trust \u0026#34;virtual\u0026#34; until * after we have the lock. */ lock_kmap(); vaddr = (unsigned long)page_address(page); if (!vaddr) vaddr = map_new_virtual(page); pkmap_count[PKMAP_NR(vaddr)]++; BUG_ON(pkmap_count[PKMAP_NR(vaddr)] \u0026lt; 2); unlock_kmap(); return (void*) vaddr; } EXPORT_SYMBOL(kmap_high);   kmap_high() 函数首先获取 lock_kmap 自旋锁（因为中断处理程序和可延迟函数不能调用 kmap()，所以不需要关中断）。\n然后通过 page_address() 函数来获取页框的线性地址。如果地址不存在，说明未被映射，此时通过 map_new_virtual() 函数把页框的物理地址插入到页表项，并在散列表中增加相应的元素。\n其次，使页框对应的计数器加一。\n最后，释放自旋锁并返回页框映射的线性地址。\nmap_new_virtual() 的实现比较复杂。\nmm/highmem.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  static inline unsigned long map_new_virtual(struct page *page) { unsigned long vaddr; int count; start: count = LAST_PKMAP; /* Find an empty entry */ for (;;) { last_pkmap_nr = (last_pkmap_nr + 1) \u0026amp; LAST_PKMAP_MASK; if (!last_pkmap_nr) { flush_all_zero_pkmaps(); count = LAST_PKMAP; } if (!pkmap_count[last_pkmap_nr]) break; /* Found a usable entry */ if (--count) continue; /* * Sleep for somebody else to unmap their entries */ { DECLARE_WAITQUEUE(wait, current); __set_current_state(TASK_UNINTERRUPTIBLE); add_wait_queue(\u0026amp;pkmap_map_wait, \u0026amp;wait); unlock_kmap(); schedule(); remove_wait_queue(\u0026amp;pkmap_map_wait, \u0026amp;wait); lock_kmap(); /* Somebody else might have mapped it while we slept */ if (page_address(page)) return (unsigned long)page_address(page); /* Re-start */ goto start; } } vaddr = PKMAP_ADDR(last_pkmap_nr); set_pte_at(\u0026amp;init_mm, vaddr, \u0026amp;(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot)); pkmap_count[last_pkmap_nr] = 1; set_page_address(page, (void *)vaddr); return vaddr; }   不得不说这个循环的写法有些独特，但大体意思就是遍历 LAST_PKMAP 个表项，如果没有找到能用的，阻塞当前进程，等待其他进程释放了一个表项（见kunmap() 函数）。当前进错被唤醒后，先检查其他进程是否已经映射了该页，是的话直接返回，反之重新开始循环。\n下面来看一下具体的遍历过程，通过用 last_pkmap_nr 记录上次停止的位置，函数总是从上次停止的地方继续遍历。\n找到能用的表项时，跳出循环，将其计数器置 1，并把该项插入散列表。\nmm/highmem.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /** * set_page_address - set a page\u0026#39;s virtual address * @page: \u0026amp;struct page to set * @virtual: virtual address to use */ void set_page_address(struct page *page, void *virtual) { unsigned long flags; struct page_address_slot *pas; struct page_address_map *pam; BUG_ON(!PageHighMem(page)); pas = page_slot(page); if (virtual) { /* Add */ BUG_ON(list_empty(\u0026amp;page_address_pool)); spin_lock_irqsave(\u0026amp;pool_lock, flags); pam = list_entry(page_address_pool.next, struct page_address_map, list); list_del(\u0026amp;pam-\u0026gt;list); spin_unlock_irqrestore(\u0026amp;pool_lock, flags); pam-\u0026gt;page = page; pam-\u0026gt;virtual = virtual; spin_lock_irqsave(\u0026amp;pas-\u0026gt;lock, flags); list_add_tail(\u0026amp;pam-\u0026gt;list, \u0026amp;pas-\u0026gt;lh); spin_unlock_irqrestore(\u0026amp;pas-\u0026gt;lock, flags); } else { /* Remove */ spin_lock_irqsave(\u0026amp;pas-\u0026gt;lock, flags); list_for_each_entry(pam, \u0026amp;pas-\u0026gt;lh, list) { if (pam-\u0026gt;page == page) { list_del(\u0026amp;pam-\u0026gt;list); spin_unlock_irqrestore(\u0026amp;pas-\u0026gt;lock, flags); spin_lock_irqsave(\u0026amp;pool_lock, flags); list_add_tail(\u0026amp;pam-\u0026gt;list, \u0026amp;page_address_pool); spin_unlock_irqrestore(\u0026amp;pool_lock, flags); goto done; } } spin_unlock_irqrestore(\u0026amp;pas-\u0026gt;lock, flags); } done: return; }   当 last_pkmap_nr 回到最开始的 0 时，调用 flush_all_zero_pkmaps() 函数来重置计数器，删除散列表中对应的元素，并且刷新 TLB。\nmm/highmem.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  static void flush_all_zero_pkmaps(void) { int i; int need_flush = 0; flush_cache_kmaps(); for (i = 0; i \u0026lt; LAST_PKMAP; i++) { struct page *page; /* * zero means we don\u0026#39;t have anything to do, * \u0026gt;1 means that it is still in use. Only * a count of 1 means that it is free but * needs to be unmapped */ if (pkmap_count[i] != 1) continue; pkmap_count[i] = 0; /* sanity check */ BUG_ON(pte_none(pkmap_page_table[i])); /* * Don\u0026#39;t need an atomic fetch-and-clear op here; * no-one has the page mapped, and cannot get at * its virtual address (and hence PTE) without first * getting the kmap_lock (which is held here). * So no dangers, even with speculative execution. */ page = pte_page(pkmap_page_table[i]); pte_clear(\u0026amp;init_mm, (unsigned long)page_address(page), \u0026amp;pkmap_page_table[i]); set_page_address(page, NULL); need_flush = 1; } if (need_flush) flush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP)); }   对于计数器，值为 1 代表表项空闲，但相应的 TLB 表项还未刷新，因此不能使用；大于 1 才表示在被使用。\n个人理解这么做的好处是，刷新 TLB 的操作被延迟到没有直接能使用的表项时才进行，而不是每次有不使用的表项就刷新，后者效率太低了。\nkunmap() 函数 kmap() 函数用于撤销 kmap() 建立的永久内核映射，该函数是体系结构相关的。\narch/x86/mm/highmem_32.c：\n1 2 3 4 5 6 7 8  void kunmap(struct page *page) { if (in_interrupt()) BUG(); if (!PageHighMem(page)) return; kunmap_high(page); }   如果该页框不在高端内存中，直接返回；反之调用 kunmap_high() 函数。\nmm/highmem.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  /** * kunmap_high - map a highmem page into memory * @page: \u0026amp;struct page to unmap * * If ARCH_NEEDS_KMAP_HIGH_GET is not defined then this may be called * only from user context. */ void kunmap_high(struct page *page) { unsigned long vaddr; unsigned long nr; unsigned long flags; int need_wakeup; lock_kmap_any(flags); vaddr = (unsigned long)page_address(page); BUG_ON(!vaddr); nr = PKMAP_NR(vaddr); /* * A count must never go down to zero * without a TLB flush! */ need_wakeup = 0; switch (--pkmap_count[nr]) { case 0: BUG(); case 1: /* * Avoid an unnecessary wake_up() function call. * The common case is pkmap_count[] == 1, but * no waiters. * The tasks queued in the wait-queue are guarded * by both the lock in the wait-queue-head and by * the kmap_lock. As the kmap_lock is held here, * no need for the wait-queue-head\u0026#39;s lock. Simply * test if the queue is empty. */ need_wakeup = waitqueue_active(\u0026amp;pkmap_map_wait); } unlock_kmap_any(flags); /* do wake-up, if needed, race-free outside of the spin lock */ if (need_wakeup) wake_up(\u0026amp;pkmap_map_wait); } EXPORT_SYMBOL(kunmap_high);   kunmap_high() 函数把页框相应的计数器减一。如果该计数器的值为 1，那么说明没有进程在使用该页了，此时可以唤醒由 map_new_virtual() 阻塞的进程。当然，如果队列为空，这一步唤醒就不需要了（need_wakeup = waitqueue_active(\u0026amp;pkmap_map_wait)）。\n临时内核映射 临时内核映射比永久内核映射的实现要简单。它不会阻塞当前进程，可以用于中断处理程序和可延迟函数。但它必须保证当前没有其他的内核控制路径在使用相同的映射，为了确保同一窗口不会被两个不同的路径同时使用，每个内核成分只能使用专门提供给它的窗口。留给临时映射的窗口很少，因此只能同时建立很少的临时内核映射。\n窗口 这部分内容是体系结构相关的，每个 CPU 都包含多个窗口的集合。\ninclude/asm-generic/kmap_types.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #ifdef __WITH_KM_FENCE # define KMAP_D(n) __KM_FENCE_##n , #else # define KMAP_D(n) #endif  enum km_type { KMAP_D(0) KM_BOUNCE_READ, KMAP_D(1) KM_SKB_SUNRPC_DATA, KMAP_D(2) KM_SKB_DATA_SOFTIRQ, KMAP_D(3) KM_USER0, KMAP_D(4) KM_USER1, KMAP_D(5) KM_BIO_SRC_IRQ, KMAP_D(6) KM_BIO_DST_IRQ, KMAP_D(7) KM_PTE0, KMAP_D(8) KM_PTE1, KMAP_D(9) KM_IRQ0, KMAP_D(10) KM_IRQ1, KMAP_D(11) KM_SOFTIRQ0, KMAP_D(12) KM_SOFTIRQ1, KMAP_D(13) KM_SYNC_ICACHE, KMAP_D(14) KM_SYNC_DCACHE, /* UML specific, for copy_*_user - used in do_op_one_page */ KMAP_D(15) KM_UML_USERCOPY, KMAP_D(16) KM_IRQ_PTE, KMAP_D(17) KM_NMI, KMAP_D(18) KM_NMI_PTE, KMAP_D(19) KM_TYPE_NR };   因为同一窗口不能被两个不同的控制路径同时使用，所以这里的每个符号都以允许使用它的内核成分来命名。KM_TYPE_NR 用于记录总共的窗口个数。\n临时内核映射用 kmap_atomic() 函数建立，用 kunmap_atomic() 函数撤销，这两个函数又涉及一大堆其他函数的调用，具体细节我暂时不想去了解了。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/map/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍内存映射。\u003c/p\u003e","title":"内存映射"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存管理初始化。\n内存管理初始化简介 体系结构相关的部分只考虑 x86-32 架构。\n初始化相关的操作总是从 start_kernel() 开始看起，与内存管理初始化相关的流程如下（图片来源于 PLKA）：\nstart_kernel() 函数位于 init/main.c。\nsetup_arch() setup_arch() 的流程如下（图片来源于 PLKA）：\nsetup_arch() 函数位于 arch/x86/kernel/setup.c。\n这部分内容在内核中经常被重构，导致不同内核版本间差异较大。事实上，我所查看的源码版本虽然与 PLKA 指示的内核版本很接近，但图中的很多函数已经重构了。\nmachine_specific_memory_setup() 直接搜索找不到 machine_specific_memory_setup() 函数，该函数应该已经被重构，推测功能接近的函数为 setup_memory_map()。\nx86-32 架构使用 BIOS 的 e820 功能来探测物理内存。\n在 arch/x86/kernel/e820.c 中，定义了 char *__init default_machine_specific_memory_setup(void) 函数，这个函数在 arch/x86/kernel/x86_init.c 中被赋值给了 resources.memory_setup：\n1 2 3 4 5 6 7 8 9 10 11 12  /* * The platform setup functions are preset with the default functions * for standard PC hardware. */ struct x86_init_ops x86_init __initdata = { .resources = { .probe_roms = x86_init_noop, .reserve_resources = reserve_standard_io_resources, .memory_setup = default_machine_specific_memory_setup, }, ...   之后在 setup_memory_map() 函数中被调用，而 setup_memory_map() 函数在 setup_arch() 中被调用。\narch/x86/kernel/e820.c：\n1 2 3 4 5 6 7 8 9  void __init setup_memory_map(void) { char *who; who = x86_init.resources.memory_setup(); memcpy(\u0026amp;e820_saved, \u0026amp;e820, sizeof(struct e820map)); printk(KERN_INFO \u0026#34;BIOS-provided physical RAM map:\\n\u0026#34;); e820_print_map(who); }   parse_early_param() 内核的命令行参数可能有与内存管理相关的选项，因此把 parse_early_param() 也视为内存管理初始化的一部分。\nparse_early_param() 函数首先在 setup_arch() 函数中调用，虽然之后 start_kernel() 也会调用它。该函数的定义位于 init/main.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* Arch code calls this early on, or if not, just before other parsing. */ void __init parse_early_param(void) { static __initdata int done = 0; static __initdata char tmp_cmdline[COMMAND_LINE_SIZE]; if (done) return; /* All fall through to do_early_param. */ strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE); parse_early_options(tmp_cmdline); done = 1; }   该函数调用 init/main.c 中的 parse_early_options()，通过 parse_args() 函数处理（parse_args() 细节不展开了）：\n1 2 3 4  void __init parse_early_options(char *cmdline) { parse_args(\u0026#34;early options\u0026#34;, cmdline, NULL, 0, do_early_param); }   setup_memory() 该函数在当前版本内核源码里已经找不到了，推测改名为了 initmem_init() 和 ，UMA 和 NUMA 版本分别放置于 arch/x86/mm/init_32.c 和 arch/x86/mm/numa_32.c。\narch/x86/mm/init_32.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #ifndef CONFIG_NEED_MULTIPLE_NODES void __init initmem_init(unsigned long start_pfn, unsigned long end_pfn, int acpi, int k8) { #ifdef CONFIG_HIGHMEM  highstart_pfn = highend_pfn = max_pfn; if (max_pfn \u0026gt; max_low_pfn) highstart_pfn = max_low_pfn; e820_register_active_regions(0, 0, highend_pfn); sparse_memory_present_with_active_regions(0); printk(KERN_NOTICE \u0026#34;%ldMB HIGHMEM available.\\n\u0026#34;, pages_to_mb(highend_pfn - highstart_pfn)); num_physpages = highend_pfn; high_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1; #else  e820_register_active_regions(0, 0, max_low_pfn); sparse_memory_present_with_active_regions(0); num_physpages = max_low_pfn; high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1; #endif #ifdef CONFIG_FLATMEM  max_mapnr = num_physpages; #endif  __vmalloc_start_set = true; printk(KERN_NOTICE \u0026#34;%ldMB LOWMEM available.\\n\u0026#34;, pages_to_mb(max_low_pfn)); setup_bootmem_allocator(); } #endif /* !CONFIG_NEED_MULTIPLE_NODES */  arch/x86/mm/numa_32.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  void __init initmem_init(unsigned long start_pfn, unsigned long end_pfn, int acpi, int k8) { int nid; long kva_target_pfn; /* * When mapping a NUMA machine we allocate the node_mem_map arrays * from node local memory. They are then mapped directly into KVA * between zone normal and vmalloc space. Calculate the size of * this space and use it to adjust the boundary between ZONE_NORMAL * and ZONE_HIGHMEM. */ get_memcfg_numa(); kva_pages = roundup(calculate_numa_remap_pages(), PTRS_PER_PTE); kva_target_pfn = round_down(max_low_pfn - kva_pages, PTRS_PER_PTE); do { kva_start_pfn = find_e820_area(kva_target_pfn\u0026lt;\u0026lt;PAGE_SHIFT, max_low_pfn\u0026lt;\u0026lt;PAGE_SHIFT, kva_pages\u0026lt;\u0026lt;PAGE_SHIFT, PTRS_PER_PTE\u0026lt;\u0026lt;PAGE_SHIFT) \u0026gt;\u0026gt; PAGE_SHIFT; kva_target_pfn -= PTRS_PER_PTE; } while (kva_start_pfn == -1UL \u0026amp;\u0026amp; kva_target_pfn \u0026gt; min_low_pfn); if (kva_start_pfn == -1UL) panic(\u0026#34;Can not get kva space\\n\u0026#34;); printk(KERN_INFO \u0026#34;kva_start_pfn ~ %lx max_low_pfn ~ %lx\\n\u0026#34;, kva_start_pfn, max_low_pfn); printk(KERN_INFO \u0026#34;max_pfn = %lx\\n\u0026#34;, max_pfn); /* avoid clash with initrd */ reserve_early(kva_start_pfn\u0026lt;\u0026lt;PAGE_SHIFT, (kva_start_pfn + kva_pages)\u0026lt;\u0026lt;PAGE_SHIFT, \u0026#34;KVA PG\u0026#34;); #ifdef CONFIG_HIGHMEM  highstart_pfn = highend_pfn = max_pfn; if (max_pfn \u0026gt; max_low_pfn) highstart_pfn = max_low_pfn; printk(KERN_NOTICE \u0026#34;%ldMB HIGHMEM available.\\n\u0026#34;, pages_to_mb(highend_pfn - highstart_pfn)); num_physpages = highend_pfn; high_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1; #else  num_physpages = max_low_pfn; high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1; #endif  printk(KERN_NOTICE \u0026#34;%ldMB LOWMEM available.\\n\u0026#34;, pages_to_mb(max_low_pfn)); printk(KERN_DEBUG \u0026#34;max_low_pfn = %lx, highstart_pfn = %lx\\n\u0026#34;, max_low_pfn, highstart_pfn); printk(KERN_DEBUG \u0026#34;Low memory ends at vaddr %08lx\\n\u0026#34;, (ulong) pfn_to_kaddr(max_low_pfn)); for_each_online_node(nid) { init_remap_allocator(nid); allocate_pgdat(nid); } remap_numa_kva(); printk(KERN_DEBUG \u0026#34;High memory starts at vaddr %08lx\\n\u0026#34;, (ulong) pfn_to_kaddr(highstart_pfn)); for_each_online_node(nid) propagate_e820_map_node(nid); for_each_online_node(nid) { memset(NODE_DATA(nid), 0, sizeof(struct pglist_data)); NODE_DATA(nid)-\u0026gt;node_id = nid; #ifndef CONFIG_NO_BOOTMEM  NODE_DATA(nid)-\u0026gt;bdata = \u0026amp;bootmem_node_data[nid]; #endif  } setup_bootmem_allocator(); }   该函数主要用于确定物理页的数目，然后初始化 bootmem 分配器，bootmem 分配器的具体细节见 bootmem 分配器。\npaging_init() paging_init() 函数位于 arch/x86/mm/init_32.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /* * paging_init() sets up the page tables - note that the first 8MB are * already mapped by head.S. * * This routines also unmaps the page at virtual kernel address 0, so * that we can trap those pesky NULL-reference errors in the kernel. */ void __init paging_init(void) { pagetable_init(); __flush_tlb_all(); kmap_init(); /* * NOTE: at this point the bootmem allocator is fully available. */ sparse_init(); zone_sizes_init(); }   该函数会调用 pagetable_init 来确保直接映射的地址空间的物理内存被初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #ifdef CONFIG_HIGHMEM static void __init permanent_kmaps_init(pgd_t *pgd_base) { unsigned long vaddr; pgd_t *pgd; pud_t *pud; pmd_t *pmd; pte_t *pte; vaddr = PKMAP_BASE; page_table_range_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base); pgd = swapper_pg_dir + pgd_index(vaddr); pud = pud_offset(pgd, vaddr); pmd = pmd_offset(pud, vaddr); pte = pte_offset_kernel(pmd, vaddr); pkmap_page_table = pte; } #else static inline void permanent_kmaps_init(pgd_t *pgd_base) { } #endif /* CONFIG_HIGHMEM */ static void __init pagetable_init(void) { pgd_t *pgd_base = swapper_pg_dir; permanent_kmaps_init(pgd_base); }   这部分的细节太多，我不打算深入看了。\nzone_sizes_init() 可以看到，在当前版本，该函数的调用者变成了 paging_init() 函数，而非 setup_arch() 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13  static void __init zone_sizes_init(void) { unsigned long max_zone_pfns[MAX_NR_ZONES]; memset(max_zone_pfns, 0, sizeof(max_zone_pfns)); max_zone_pfns[ZONE_DMA] = virt_to_phys((char *)MAX_DMA_ADDRESS) \u0026gt;\u0026gt; PAGE_SHIFT; max_zone_pfns[ZONE_NORMAL] = max_low_pfn; #ifdef CONFIG_HIGHMEM  max_zone_pfns[ZONE_HIGHMEM] = highend_pfn; #endif  free_area_init_nodes(max_zone_pfns); }   add_active_range() 对可用的物理内存建立一个相对简单的列表。但该函数已经不在 zone_sizes_init() 中被调用了，搜索后发现该函数在 initmem_init() 中已经被调用了，函数调用链是 initmem_init() -\u0026gt; e820_register_active_regions() -\u0026gt; add_active_range()。\nfree_area_init_nodes() 它使用之前建立的列表来建立完备的内核数据结构。该函数是体系结构无关的，定义于 mm/page_alloc.c，这里不展开。\nsetup_per_cpu_areas() setup_per_cpu_areas() 函数位于 arch/x86/kernel/setup_percpu.c，用于初始化 per-CPU 高速缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  void __init setup_per_cpu_areas(void) { unsigned int cpu; unsigned long delta; int rc; pr_info(\u0026#34;NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d\\n\u0026#34;, NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids); /* * Allocate percpu area. Embedding allocator is our favorite; * however, on NUMA configurations, it can result in very * sparse unit mapping and vmalloc area isn\u0026#39;t spacious enough * on 32bit. Use page in that case. */ #ifdef CONFIG_X86_32  if (pcpu_chosen_fc == PCPU_FC_AUTO \u0026amp;\u0026amp; pcpu_need_numa()) pcpu_chosen_fc = PCPU_FC_PAGE; #endif  rc = -EINVAL; if (pcpu_chosen_fc != PCPU_FC_PAGE) { const size_t atom_size = cpu_has_pse ? PMD_SIZE : PAGE_SIZE; const size_t dyn_size = PERCPU_MODULE_RESERVE + PERCPU_DYNAMIC_RESERVE - PERCPU_FIRST_CHUNK_RESERVE; rc = pcpu_embed_first_chunk(PERCPU_FIRST_CHUNK_RESERVE, dyn_size, atom_size, pcpu_cpu_distance, pcpu_fc_alloc, pcpu_fc_free); if (rc \u0026lt; 0) pr_warning(\u0026#34;%s allocator failed (%d), falling back to page size\\n\u0026#34;, pcpu_fc_names[pcpu_chosen_fc], rc); } if (rc \u0026lt; 0) rc = pcpu_page_first_chunk(PERCPU_FIRST_CHUNK_RESERVE, pcpu_fc_alloc, pcpu_fc_free, pcpup_populate_pte); if (rc \u0026lt; 0) panic(\u0026#34;cannot initialize percpu area (err=%d)\u0026#34;, rc); /* alrighty, percpu areas up and running */ delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start; for_each_possible_cpu(cpu) { per_cpu_offset(cpu) = delta + pcpu_unit_offsets[cpu]; per_cpu(this_cpu_off, cpu) = per_cpu_offset(cpu); per_cpu(cpu_number, cpu) = cpu; setup_percpu_segment(cpu); setup_stack_canary_segment(cpu); /* * Copy data used in early init routines from the * initial arrays to the per cpu data areas. These * arrays then become expendable and the *_early_ptr\u0026#39;s * are zeroed indicating that the static arrays are * gone. */ #ifdef CONFIG_X86_LOCAL_APIC  per_cpu(x86_cpu_to_apicid, cpu) = early_per_cpu_map(x86_cpu_to_apicid, cpu); per_cpu(x86_bios_cpu_apicid, cpu) = early_per_cpu_map(x86_bios_cpu_apicid, cpu); #endif #ifdef CONFIG_X86_64  per_cpu(irq_stack_ptr, cpu) = per_cpu(irq_stack_union.irq_stack, cpu) + IRQ_STACK_SIZE - 64; #ifdef CONFIG_NUMA  per_cpu(x86_cpu_to_node_map, cpu) = early_per_cpu_map(x86_cpu_to_node_map, cpu); #endif #endif  /* * Up to this point, the boot CPU has been using .data.init * area. Reload any changed state for the boot CPU. */ if (cpu == boot_cpu_id) switch_to_new_gdt(cpu); } /* indicate the early static arrays will soon be gone */ #ifdef CONFIG_X86_LOCAL_APIC  early_per_cpu_ptr(x86_cpu_to_apicid) = NULL; early_per_cpu_ptr(x86_bios_cpu_apicid) = NULL; #endif #if defined(CONFIG_X86_64) \u0026amp;\u0026amp; defined(CONFIG_NUMA)  early_per_cpu_ptr(x86_cpu_to_node_map) = NULL; #endif  #if defined(CONFIG_X86_64) \u0026amp;\u0026amp; defined(CONFIG_NUMA)  /* * make sure boot cpu node_number is right, when boot cpu is on the * node that doesn\u0026#39;t have mem installed */ per_cpu(node_number, boot_cpu_id) = cpu_to_node(boot_cpu_id); #endif  /* Setup node to cpumask map */ setup_node_to_cpumask_map(); /* Setup cpu initialized, callin, callout masks */ setup_cpu_local_masks(); }   build_all_zonelists() build_all_zonelists() 函数位于 mm/page_alloc.c，用于初始化结点和内存区域。\n该函数和其调用的相关函数定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131  static void build_zonelists(pg_data_t *pgdat) { int j, node, load; enum zone_type i; nodemask_t used_mask; int local_node, prev_node; struct zonelist *zonelist; int order = current_zonelist_order; /* initialize zonelists */ for (i = 0; i \u0026lt; MAX_ZONELISTS; i++) { zonelist = pgdat-\u0026gt;node_zonelists + i; zonelist-\u0026gt;_zonerefs[0].zone = NULL; zonelist-\u0026gt;_zonerefs[0].zone_idx = 0; } /* NUMA-aware ordering of nodes */ local_node = pgdat-\u0026gt;node_id; load = nr_online_nodes; prev_node = local_node; nodes_clear(used_mask); memset(node_order, 0, sizeof(node_order)); j = 0; while ((node = find_next_best_node(local_node, \u0026amp;used_mask)) \u0026gt;= 0) { int distance = node_distance(local_node, node); /* * If another node is sufficiently far away then it is better * to reclaim pages in a zone before going off node. */ if (distance \u0026gt; RECLAIM_DISTANCE) zone_reclaim_mode = 1; /* * We don\u0026#39;t want to pressure a particular node. * So adding penalty to the first node in same * distance group to make it round-robin. */ if (distance != node_distance(local_node, prev_node)) node_load[node] = load; prev_node = node; load--; if (order == ZONELIST_ORDER_NODE) build_zonelists_in_node_order(pgdat, node); else node_order[j++] = node; /* remember order */ } if (order == ZONELIST_ORDER_ZONE) { /* calculate node order -- i.e., DMA last! */ build_zonelists_in_zone_order(pgdat, j); } build_thisnode_zonelists(pgdat); } /* return values int ....just for stop_machine() */ static int __build_all_zonelists(void *dummy) { int nid; int cpu; #ifdef CONFIG_NUMA  memset(node_load, 0, sizeof(node_load)); #endif  for_each_online_node(nid) { pg_data_t *pgdat = NODE_DATA(nid); build_zonelists(pgdat); build_zonelist_cache(pgdat); } /* * Initialize the boot_pagesets that are going to be used * for bootstrapping processors. The real pagesets for * each zone will be allocated later when the per cpu * allocator is available. * * boot_pagesets are used also for bootstrapping offline * cpus if the system is already booted because the pagesets * are needed to initialize allocators on a specific cpu too. * F.e. the percpu allocator needs the page allocator which * needs the percpu allocator in order to allocate its pagesets * (a chicken-egg dilemma). */ for_each_possible_cpu(cpu) setup_pageset(\u0026amp;per_cpu(boot_pageset, cpu), 0); return 0; } void build_all_zonelists(void) { set_zonelist_order(); if (system_state == SYSTEM_BOOTING) { __build_all_zonelists(NULL); mminit_verify_zonelist(); cpuset_init_current_mems_allowed(); } else { /* we have to stop all cpus to guarantee there is no user of zonelist */ stop_machine(__build_all_zonelists, NULL, NULL); /* cpuset refresh routine should be here */ } vm_total_pages = nr_free_pagecache_pages(); /* * Disable grouping by mobility if the number of pages in the * system is too low to allow the mechanism to work. It would be * more accurate, but expensive to check per-zone. This check is * made on memory-hotadd so a system can start with mobility * disabled and enable it later */ if (vm_total_pages \u0026lt; (pageblock_nr_pages * MIGRATE_TYPES)) page_group_by_mobility_disabled = 1; else page_group_by_mobility_disabled = 0; printk(\u0026#34;Built %i zonelists in %s order, mobility grouping %s. \u0026#34; \u0026#34;Total pages: %ld\\n\u0026#34;, nr_online_nodes, zonelist_order_name[current_zonelist_order], page_group_by_mobility_disabled ? \u0026#34;off\u0026#34; : \u0026#34;on\u0026#34;, vm_total_pages); #ifdef CONFIG_NUMA  printk(\u0026#34;Policy zone: %s\\n\u0026#34;, zone_names[policy_zone]); #endif }   mm_init() mm_init() 函数位于 init/main.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /* * Set up kernel memory allocators */ static void __init mm_init(void) { /* * page_cgroup requires countinous pages as memmap * and it\u0026#39;s bigger than MAX_ORDER unless SPARSEMEM. */ page_cgroup_init_flatmem(); mem_init(); kmem_cache_init(); pgtable_cache_init(); vmalloc_init(); }   mem_init() 函数用于停用 bootmem 分配器并迁移到实际的内存管理函数（见 bootmem 分配器），kmem_cache_init() 函数用于初始化 slab/slob/slub 分配器。\nsetup_per_cpu_pageset() setup_per_cpu_pageset() 函数位于 mm/page_alloc.c，用于分配并初始化 pageset：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* * Allocate per cpu pagesets and initialize them. * Before this call only boot pagesets were available. * Boot pagesets will no longer be used by this processorr * after setup_per_cpu_pageset(). */ void __init setup_per_cpu_pageset(void) { struct zone *zone; int cpu; for_each_populated_zone(zone) { zone-\u0026gt;pageset = alloc_percpu(struct per_cpu_pageset); for_each_possible_cpu(cpu) { struct per_cpu_pageset *pcp = per_cpu_ptr(zone-\u0026gt;pageset, cpu); setup_pageset(pcp, zone_batchsize(zone)); if (percpu_pagelist_fraction) setup_pagelist_highmark(pcp, (zone-\u0026gt;present_pages / percpu_pagelist_fraction)); } } }   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/initialization/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍内存管理初始化。\u003c/p\u003e","title":"内存管理初始化"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍非连续页框的管理。\n非连续内存区的线性地址空间 非连续内存区的线性地址空间的线性地址空间从 VMALLOC_START 开始，到 VMALLOC_END 结束，这个宏显然是体系结构相关的，下面以 32 位的 x86 为例。\narch/x86/include/asm/pgtable_32_types.h：\n1 2 3 4 5  #define VMALLOC_OFFSET (8 * 1024 * 1024)  #define VMALLOC_START ((unsigned long)high_memory + VMALLOC_OFFSET)  # define VMALLOC_END (PKMAP_BASE - 2 * PAGE_SIZE)   high_memory 对应直接映射的物理内存的末尾，VMALLOC_OFFSET 是一个 8MB 的安全空间，用于与直接映射的物理内存区域隔开。PKMAP_BASE 开始是永久内核映射的线性地址，VMALLOC_END 与之隔了个 8KB 的安全空间（默认页大小是 4KB）。\n高端内存的布局大致如下（arch/x86/include/asm/highmem.h 中的注释）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /* * Right now we initialize only a single pte table. It can be extended * easily, subsequent pte tables have to be allocated in one physical * chunk of RAM. */ /* * Ordering is: * * FIXADDR_TOP * fixed_addresses * FIXADDR_START * temp fixed addresses * FIXADDR_BOOT_START * Persistent kmap area * PKMAP_BASE * VMALLOC_END * Vmalloc area * VMALLOC_START * high_memory */   非连续内存区的描述符 每个非连续内存区对应一个 vm_struct 描述符。\ninclude/linux/vmalloc.h：\n1 2 3 4 5 6 7 8 9 10  struct vm_struct { struct vm_struct *next; void *addr; unsigned long size; unsigned long flags; struct page **pages; unsigned int nr_pages; unsigned long phys_addr; void *caller; };    next：指向下一个 vm_struct 的指针。 addr：内存区内第一个内存单元的线性地址。 size：内存区的大小加上 4096 （安全区间为页大小）。 flags：映射的内存类型。 pages：指向页框描述符指针数组的指针（页框描述符是 struct page）。 nr_pages：页框描述符指针数组中填充的页的个数。 phys_addr：映射硬件设备的 I/O 共享内存（没映射则为 0） caller：调用者的返回地址（__vmalloc_node() 的注释是这么写的，具体用途没研究，这几本书都没介绍，所以我也准备跳过了）  其中，映射的内存类型定义如下。\ninclude/linux/vmalloc.h：\n1 2 3 4 5 6 7  /* bits in flags of vmalloc\u0026#39;s vm_struct below */ #define VM_IOREMAP 0x00000001 /* ioremap() and friends */#define VM_ALLOC 0x00000002 /* vmalloc() */#define VM_MAP 0x00000004 /* vmap()ed pages */#define VM_USERMAP 0x00000008 /* suitable for remap_vmalloc_range */#define VM_VPAGES 0x00000010 /* buffer for pages was vmalloc\u0026#39;ed *//* bits [20..32] reserved for arch specific ioremap internals */   分配非连续内存区 分配非连续内存区使用 vmalloc() 函数。\nmm/vmalloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  /** * __vmalloc_node - allocate virtually contiguous memory * @size: allocation size * @align: desired alignment * @gfp_mask: flags for the page level allocator * @prot: protection mask for the allocated pages * @node: node to use for allocation or -1 * @caller: caller\u0026#39;s return address * * Allocate enough pages to cover @size from the page level * allocator with @gfp_mask flags. Map them into contiguous * kernel virtual space, using a pagetable protection of @prot. */ static void *__vmalloc_node(unsigned long size, unsigned long align, gfp_t gfp_mask, pgprot_t prot, int node, void *caller) { struct vm_struct *area; void *addr; unsigned long real_size = size; size = PAGE_ALIGN(size); if (!size || (size \u0026gt;\u0026gt; PAGE_SHIFT) \u0026gt; totalram_pages) return NULL; area = __get_vm_area_node(size, align, VM_ALLOC, VMALLOC_START, VMALLOC_END, node, gfp_mask, caller); if (!area) return NULL; addr = __vmalloc_area_node(area, gfp_mask, prot, node, caller); /* * A ref_count = 3 is needed because the vm_struct and vmap_area * structures allocated in the __get_vm_area_node() function contain * references to the virtual address of the vmalloc\u0026#39;ed block. */ kmemleak_alloc(addr, real_size, 3, gfp_mask); return addr; } /** * vmalloc - allocate virtually contiguous memory * @size: allocation size * Allocate enough pages to cover @size from the page level * allocator and map them into contiguous kernel virtual space. * * For tight control over page level allocator and protection flags * use __vmalloc() instead. */ void *vmalloc(unsigned long size) { return __vmalloc_node(size, 1, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL, -1, __builtin_return_address(0)); } EXPORT_SYMBOL(vmalloc);   __vmalloc_node() 主要进行如下操作：\n 通过 PAGE_ALIGN() 宏将 size 对齐到页大小。 通过 __get_vm_area_node() 创建新的描述符。 通过 __vmalloc_area_node() 分配内存空间。 通过 kmemleak_alloc() 通报内存分配。  PAGE_ALIGN() PAGE_ALIGN() 的原理比较简单，挨个宏找下去就行了。\ninclude/linux/mm.h：\n1 2  /* to align the pointer to the (next) page boundary */ #define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)   include/linux/kernel.h：\n1 2  #define ALIGN(x,a) __ALIGN_MASK(x,(typeof(x))(a)-1) #define __ALIGN_MASK(x,mask) (((x)+(mask))\u0026amp;~(mask))   __get_vm_area_node() mm/vmalloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  static struct vm_struct *__get_vm_area_node(unsigned long size, unsigned long align, unsigned long flags, unsigned long start, unsigned long end, int node, gfp_t gfp_mask, void *caller) { static struct vmap_area *va; struct vm_struct *area; BUG_ON(in_interrupt()); if (flags \u0026amp; VM_IOREMAP) { int bit = fls(size); if (bit \u0026gt; IOREMAP_MAX_ORDER) bit = IOREMAP_MAX_ORDER; else if (bit \u0026lt; PAGE_SHIFT) bit = PAGE_SHIFT; align = 1ul \u0026lt;\u0026lt; bit; } size = PAGE_ALIGN(size); if (unlikely(!size)) return NULL; area = kzalloc_node(sizeof(*area), gfp_mask \u0026amp; GFP_RECLAIM_MASK, node); if (unlikely(!area)) return NULL; /* * We always allocate a guard page. */ size += PAGE_SIZE; va = alloc_vmap_area(size, align, start, end, node, gfp_mask); if (IS_ERR(va)) { kfree(area); return NULL; } insert_vmalloc_vm(area, va, flags, caller); return area; }   __get_vm_area_node() 主要用于创建新的描述符，并把该描述符插入到相关的内核数据结构中，具体细节比较复杂，我不准备看了。\n__vmalloc_area_node() mm/vmalloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask, pgprot_t prot, int node, void *caller) { struct page **pages; unsigned int nr_pages, array_size, i; gfp_t nested_gfp = (gfp_mask \u0026amp; GFP_RECLAIM_MASK) | __GFP_ZERO; nr_pages = (area-\u0026gt;size - PAGE_SIZE) \u0026gt;\u0026gt; PAGE_SHIFT; array_size = (nr_pages * sizeof(struct page *)); area-\u0026gt;nr_pages = nr_pages; /* Please note that the recursion is strictly bounded. */ if (array_size \u0026gt; PAGE_SIZE) { pages = __vmalloc_node(array_size, 1, nested_gfp|__GFP_HIGHMEM, PAGE_KERNEL, node, caller); area-\u0026gt;flags |= VM_VPAGES; } else { pages = kmalloc_node(array_size, nested_gfp, node); } area-\u0026gt;pages = pages; area-\u0026gt;caller = caller; if (!area-\u0026gt;pages) { remove_vm_area(area-\u0026gt;addr); kfree(area); return NULL; } for (i = 0; i \u0026lt; area-\u0026gt;nr_pages; i++) { struct page *page; if (node \u0026lt; 0) page = alloc_page(gfp_mask); else page = alloc_pages_node(node, gfp_mask, 0); if (unlikely(!page)) { /* Successfully allocated i pages, free them in __vunmap() */ area-\u0026gt;nr_pages = i; goto fail; } area-\u0026gt;pages[i] = page; } if (map_vm_area(area, prot, \u0026amp;pages)) goto fail; return area-\u0026gt;addr; fail: vfree(area-\u0026gt;addr); return NULL; }   __vmalloc_area_node() 和 __vmalloc_node() 互相递归，当分配的页描述符指针数组小于一页时，__vmalloc_area_node() 调用 kmalloc_node() 来分配（kmalloc_node() 会通过 kmalloc() 分配内存），结束递归。\n页描述符指针数组的元素指向 alloc_pages_node() 分配的页（alloc_page() 最终也会调用 alloc_pages_node()，见请求页框），完成填充。\n完成分配后，通过 map_vm_area() 来修改页表项，这个函数的细节比较复杂，暂时不准备去看了。\nkmemleak_alloc() kmemleak_alloc() 是 kmemleak 的 API，kmemleak 主要用于检测内存泄漏，相关内容不属于本系列学习笔记的范畴。\n释放非连续内存区 释放非连续内存区使用 vfree() 函数。\nmm/vmalloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  static void __vunmap(const void *addr, int deallocate_pages) { struct vm_struct *area; if (!addr) return; if ((PAGE_SIZE-1) \u0026amp; (unsigned long)addr) { WARN(1, KERN_ERR \u0026#34;Trying to vfree() bad address (%p)\\n\u0026#34;, addr); return; } area = remove_vm_area(addr); if (unlikely(!area)) { WARN(1, KERN_ERR \u0026#34;Trying to vfree() nonexistent vm area (%p)\\n\u0026#34;, addr); return; } debug_check_no_locks_freed(addr, area-\u0026gt;size); debug_check_no_obj_freed(addr, area-\u0026gt;size); if (deallocate_pages) { int i; for (i = 0; i \u0026lt; area-\u0026gt;nr_pages; i++) { struct page *page = area-\u0026gt;pages[i]; BUG_ON(!page); __free_page(page); } if (area-\u0026gt;flags \u0026amp; VM_VPAGES) vfree(area-\u0026gt;pages); else kfree(area-\u0026gt;pages); } kfree(area); return; } /** * vfree - release memory allocated by vmalloc() * @addr: memory base address * * Free the virtually continuous memory area starting at @addr, as * obtained from vmalloc(), vmalloc_32() or __vmalloc(). If @addr is * NULL, no operation is performed. * * Must not be called in interrupt context. */ void vfree(const void *addr) { BUG_ON(in_interrupt()); kmemleak_free(addr); __vunmap(addr, 1); } EXPORT_SYMBOL(vfree);   __vunmap() 主要进行如下操作（进行和分配顺序相反的操作）：\n 通过 remove_vm_area() 清楚相应的页表项。 通过 __free_page() 释放分配的页。 通过 kfree() 释放描述符。  但这里面的细节比较复杂，我暂时不准备看了。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/uncontinuous/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍非连续页框的管理。\u003c/p\u003e","title":"非连续页框的管理"},{"content":"LeetCode 刷题笔记系列，一个新坑，记录刷过的 LeetCode 题目。\n简介 数据结构和算法是非常重要的，为了逃离舒适区，开个新坑，记录 LeetCode 刷题笔记。\n每日一题 坚持每日刷一题，不是 LeetCode 的“每日 1 题”，而是按照推荐和自己的喜好随意刷的。\n暂时决定以 200 天为一个阶段，做满 200 题开始总结各种题型。\n此处只记录做过的题目的链接，打卡用。\n 163. Missing Ranges 138. Copy List with Random Pointer 2. Add Two Numbers 200. Number of Islands 151. Reverse Words in a String 54. Spiral Matrix 1. Two Sum 146. LRU Cache 42. Trapping Rain Water 5. Longest Palindromic Substring 253. Meeting Rooms II 273. Integer to English Words 8. String to Integer (atoi/) 4. Median of Two Sorted Arrays 10. Regular Expression Matching 1448. Count Good Nodes in Binary Tree 297. Serialize and Deserialize Binary Tree 23. Merge k Sorted Lists 48. Rotate Image 21. Merge Two Sorted Lists 53. Maximum Subarray 17. Letter Combinations of a Phone Number 121. Best Time to Buy and Sell Stock 240. Search a 2D Matrix II 88. Merge Sorted Array 33. Search in Rotated Sorted Array 103. Binary Tree Zigzag Level Order Traversal 206. Reverse Linked List 3. Longest Substring Without Repeating Characters 56. Merge Intervals 116. Populating Next Right Pointers in Each Node 49. Group Anagrams 98. Validate Binary Search Tree 348. Design Tic-Tac-Toe 20. Valid Parentheses 105. Construct Binary Tree from Preorder and Inorder Traversal 41. First Missing Positive 277. Find the Celebrity 25. Reverse Nodes in k-Group 295. Find Median from Data Stream 236. Lowest Common Ancestor of a Binary Tree 79. Word Search 445. Add Two Numbers II 238. Product of Array Except Self 73. Set Matrix Zeroes 344. Reverse String 212. Word Search II 218. The Skyline Problem 43. Multiply Strings 127. Word Ladder 443. String Compression 139. Word Break 22. Generate Parentheses 15. 3Sum 24. Swap Nodes in Pairs 7. Reverse Integer 76. Minimum Window Substring 75. Sort Colors 171. Excel Sheet Column Number 173. Binary Search Tree Iterator 165. Compare Version Numbers 117. Populating Next Right Pointers in Each Node II 1239. Maximum Length of a Concatenated String with Unique Characters 557. Reverse Words in a String III 12. Integer to Roman 13. Roman to Integer 44. Wildcard Matching 102. Binary Tree Level Order Traversal 155. Min Stack 46. Permutations 235. Lowest Common Ancestor of a Binary Search Tree 36. Valid Sudoku 234. Palindrome Linked List 168. Excel Sheet Column Title 287. Find the Duplicate Number 402. Remove K Digits 72. Edit Distance ","permalink":"https://freeflyingsheep.github.io/posts/leetcode/leetcode/","summary":"\u003cp\u003e\u003ca href=\"/posts/leetcode/leetcode\"\u003eLeetCode 刷题笔记系列\u003c/a\u003e，一个新坑，记录刷过的 \u003ca href=\"https://leetcode-cn.com/\"\u003eLeetCode\u003c/a\u003e 题目。\u003c/p\u003e","title":"LeetCode 刷题笔记"},{"content":"整理工作中移植 OpenStack Victoria 版本核心组件到龙芯 lemote Fedora 28 系统上的过程。\n工作需求 现在需要移植 OpenStack 核心组件到 lemote Fedora 28 系统上，索性选取了当前最新的稳定分支 Victoria 版本。\n移植所有组件并测试是不现实的，目前只考虑几个核心组件，包括 Nova、Cinder、Neutron、Horizo​​n、Keystone、Glance 和 Placement。\n考虑到 OpenStack 是用 Python 编写的，而 Python 环境和大部分系统工具 lemote Fedora 28 系统上已经存在，而且接口是与 x86 一致的，所以不少组件应该是能直接运行的。龙芯平台的 libvirt 和 QEMU/LVM 是修改过的，因此最有可能需要修改的是 OpenStack Nova 组件的代码（事实证明，确实只需要修改这一个组件）。\n为了方便部署测试，直接选择使用官方的 DevStack 自动部署脚本。\n移植 DevStack 显然，DevStack 不经过修改是无法在龙芯平台上跑通的。修改过的 DevStack 代码见 https://github.com/FreeFlyingSheep/devstack。\n探测版本信息 该部分代码位于 functions-common。\n为了能在多个发行版上运行，DevStack 首先借助 lsb_release 命令探测发行版信息。而 lemote 系统上并没有提供 lsb_release 软件包，为此，通过检查 /proc/version 中的信息，发现是 lemote 系统直接返回，来绕过安装 lsb_release。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Make a *best effort* attempt to install lsb_release packages for the # user if not available. Note can\u0026#39;t use generic install_package* # because they depend on this! function _ensure_lsb_release { if [[ -x $(command -v lsb_release 2\u0026gt;/dev/null) ]]; then return fi # lemote if grep -q \u0026#34;lemote\u0026#34; /proc/version; then return fi if [[ -x $(command -v apt-get 2\u0026gt;/dev/null) ]]; then sudo apt-get install -y lsb-release elif [[ -x $(command -v zypper 2\u0026gt;/dev/null) ]]; then sudo zypper -n install lsb-release elif [[ -x $(command -v dnf 2\u0026gt;/dev/null) ]]; then sudo dnf install -y redhat-lsb-core else die $LINENO \u0026#34;Unable to find or auto-install lsb_release\u0026#34; fi }   只是绕过安装并没解决问题，还需要手动指定 lemote 系统的发行版系统，为了和其他发行版统一，借助 /etc/os-release 文件来获取相关信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  # GetOSVersion # Set the following variables: # - os_RELEASE # - os_CODENAME # - os_VENDOR # - os_PACKAGE function GetOSVersion { # We only support distros that provide a sane lsb_release _ensure_lsb_release if ! grep -q \u0026#34;lemote\u0026#34; /proc/version; then os_RELEASE=$(lsb_release -r -s) os_CODENAME=$(lsb_release -c -s) os_VENDOR=$(lsb_release -i -s) else # lemote os_RELEASE=$(grep \u0026#34;^VERSION_ID=\u0026#34; /etc/os-release | cut -d \u0026#39;=\u0026#39; -f 2) os_CODENAME=$(grep \u0026#34;^VERSION=\u0026#34; /etc/os-release | cut -d \u0026#39;(\u0026#39; -f 2 | cut -d \u0026#39;)\u0026#39; -f 1) os_VENDOR=$(grep \u0026#34;^NAME=\u0026#34; /etc/os-release | cut -d \u0026#39;=\u0026#39; -f 2) fi if [[ $os_VENDOR =~ (Debian|Ubuntu|LinuxMint) ]]; then os_PACKAGE=\u0026#34;deb\u0026#34; else os_PACKAGE=\u0026#34;rpm\u0026#34; fi typeset -xr os_VENDOR typeset -xr os_RELEASE typeset -xr os_PACKAGE typeset -xr os_CODENAME }   同时，为了方便后续判断系统信息，参考脚本提供的 is_suse 函数，加上 is_lemote 函数：\n1 2 3  function is_lemote { is_fedora \u0026amp;\u0026amp; grep -q \u0026#34;lemote\u0026#34; /proc/version }   由于而脚本已经放弃了对 Fedora 28 系统的支持，所以运行时需要加上 FORCE=yes，索性将其添加到 local.conf 中。\n编译 ETCD 脚本会自动根据系统版本信息来从官方下载 ETCD 包，而官方并未提供 MIPS 版本的 ETCD，所以需要手动编译。\nETCD 的编译比较简单，直接从官方仓库克隆，切换到相应版本（为了与脚本统一，选择了 3.3.12 版本），编译并参考其他体系结构的压缩文件打包为 etcd-v3.3.12-linux-mips64.tar.gz，之后在脚本中添加 MIPS 体系结构的信息。\n该部分代码位于 stackrc。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  # etcd3 defaults ETCD_VERSION=${ETCD_VERSION:-v3.3.12} ETCD_SHA256_AMD64=${ETCD_SHA256_AMD64:-\u0026#34;dc5d82df095dae0a2970e4d870b6929590689dd707ae3d33e7b86da0f7f211b6\u0026#34;} ETCD_SHA256_ARM64=${ETCD_SHA256_ARM64:-\u0026#34;170b848ac1a071fe7d495d404a868a2c0090750b2944f8a260ef1c6125b2b4f4\u0026#34;} ETCD_SHA256_PPC64=${ETCD_SHA256_PPC64:-\u0026#34;77f807b1b51abbf51e020bb05bdb8ce088cb58260fcd22749ea32eee710463d3\u0026#34;} # etcd v3.2.x doesn\u0026#39;t have anything for s390x ETCD_SHA256_S390X=${ETCD_SHA256_S390X:-\u0026#34;\u0026#34;} # etcd v3.2.x doesn\u0026#39;t have anything for mips64 ETCD_SHA256_MIPS64=${ETCD_SHA256_MIPS64:-\u0026#34;5632a3ce5d376701f87887ff5caac5d41a74ec6c1e691a661dc6ce1f1d2effab\u0026#34;} # Make sure etcd3 downloads the correct architecture if is_arch \u0026#34;x86_64\u0026#34;; then ETCD_ARCH=\u0026#34;amd64\u0026#34; ETCD_SHA256=${ETCD_SHA256:-$ETCD_SHA256_AMD64} elif is_arch \u0026#34;aarch64\u0026#34;; then ETCD_ARCH=\u0026#34;arm64\u0026#34; ETCD_SHA256=${ETCD_SHA256:-$ETCD_SHA256_ARM64} elif is_arch \u0026#34;ppc64le\u0026#34;; then ETCD_ARCH=\u0026#34;ppc64le\u0026#34; ETCD_SHA256=${ETCD_SHA256:-$ETCD_SHA256_PPC64} elif is_arch \u0026#34;s390x\u0026#34;; then # An etcd3 binary for s390x is not available on github like it is # for other arches. Only continue if a custom download URL was # provided. if [[ -n \u0026#34;${ETCD_DOWNLOAD_URL}\u0026#34; ]]; then ETCD_ARCH=\u0026#34;s390x\u0026#34; ETCD_SHA256=${ETCD_SHA256:-$ETCD_SHA256_S390X} else exit_distro_not_supported \u0026#34;etcd3. No custom ETCD_DOWNLOAD_URL provided.\u0026#34; fi elif is_arch \u0026#34;mips64\u0026#34;; then # An etcd3 binary for mips64 is not available on github like it is # for other arches. Only continue if a custom download URL was # provided. if [[ -n \u0026#34;${ETCD_DOWNLOAD_URL}\u0026#34; ]]; then ETCD_ARCH=\u0026#34;mips64\u0026#34; ETCD_SHA256=${ETCD_SHA256:-$ETCD_SHA256_MIPS64} else exit_distro_not_supported \u0026#34;etcd3. No custom ETCD_DOWNLOAD_URL provided.\u0026#34; fi else exit_distro_not_supported \u0026#34;invalid hardware type - $ETCD_ARCH\u0026#34; fi   脚本的下载辅助函数会判断文件是否已经存在，若存在则不下载，因此拷贝 etcd-v3.3.12-linux-mips64.tar.gz 到 files 目录即可，同时在 local.conf 中添加 ETCD_DOWNLOAD_URL=https://fake-url。\n编译好的 ETCD 无法直接运行，因为官方没在 MIPS 上测试过，所以需要添加环境变量 ETCD_UNSUPPORTED_ARCH=mips64le。参考脚本 aarch64 体系结构部分的代码，直接把该环境变量添加到 .service 文件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # start_etcd3() - Starts to run the etcd process function start_etcd3 { ... local unitfile=\u0026#34;$SYSTEMD_DIR/$ETCD_SYSTEMD_SERVICE\u0026#34; write_user_unit_file $ETCD_SYSTEMD_SERVICE \u0026#34;$cmd\u0026#34; \u0026#34;\u0026#34; \u0026#34;root\u0026#34; iniset -sudo $unitfile \u0026#34;Unit\u0026#34; \u0026#34;After\u0026#34; \u0026#34;network.target\u0026#34; iniset -sudo $unitfile \u0026#34;Service\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;notify\u0026#34; iniset -sudo $unitfile \u0026#34;Service\u0026#34; \u0026#34;Restart\u0026#34; \u0026#34;on-failure\u0026#34; iniset -sudo $unitfile \u0026#34;Service\u0026#34; \u0026#34;LimitNOFILE\u0026#34; \u0026#34;65536\u0026#34; if is_arch \u0026#34;aarch64\u0026#34;; then iniset -sudo $unitfile \u0026#34;Service\u0026#34; \u0026#34;Environment\u0026#34; \u0026#34;ETCD_UNSUPPORTED_ARCH=arm64\u0026#34; fi if is_arch \u0026#34;mips64\u0026#34;; then iniset -sudo $unitfile \u0026#34;Service\u0026#34; \u0026#34;Environment\u0026#34; \u0026#34;ETCD_UNSUPPORTED_ARCH=mips64le\u0026#34; fi $SYSTEMCTL daemon-reload $SYSTEMCTL enable $ETCD_SYSTEMD_SERVICE $SYSTEMCTL start $ETCD_SYSTEMD_SERVICE }   修复已知问题 已知 lemote Fedora 28 系统上存在以下问题：\n 缺少 dstat 软件包，且该包并不会在脚本运行中自动安装，使用 dnf 安装即可。 系统自带的 virtualenv 版本过低，使用 pip 升级。 缺少 uwsgi 软件包，dnf 源中不存在该软件包，使用 pip 安装。 系统自带的 wrapt 会阻碍脚本自动升级该软件包，提前把它强制升级。  参考 fixup_fedora 函数，添加 fixup_lemote 函数，并在 fixup_fedora 函数中调用它。该部分代码位于 tools/fixup_stuff.sh。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function fixup_lemote { if ! is_lemote; then return fi # Install missing tools install_package dstat pip_install -U virtualenv pip_install -U uwsgi pip_install -UI wrapt } function fixup_fedora { ... fixup_lemote }   创建虚拟环境 系统下的 Python3 不认识 python3 -m venv 命令，将其改为 python3 -m virtualenv。该部分代码位于 stackrc。\n1 2 3 4 5 6 7  # Create a virtualenv with this # Use the built-in venv to avoid more dependencies if ! is_lemote; then export VIRTUALENV_CMD=\u0026#34;python3 -m venv\u0026#34; else # lemote export VIRTUALENV_CMD=\u0026#34;python3 -m virtualenv\u0026#34; fi   设置服务自启 系统重启后，DevStack 无法正常运行，检查日志和服务信息发现 httpd 和 memcached 服务没有设置自启。\n检查脚本发现没有设置服务自启的封装函数（可能是我没找仔细？），参考 start_service 函数定义 _enable_service 函数 （注意已经存在 enable_service 函数了）。该部分代码位于 functions-common。\n1 2 3 4 5 6 7 8 9 10  # Service wrapper to enable services # Note that we already have enable_service above # _enable_service service-name function _enable_service { if [ -x /bin/systemctl ]; then sudo /bin/systemctl enable $1 else sudo service $1 enable fi }   之后，在对应的服务处加上自启。对于 httpd，脚本对 apache 服务又进行了一层封装，添加相应内容。代码位于 lib/apache。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # lib/apache exports the following functions: # ... # - enable_apache_server # install_apache_wsgi() - Install Apache server and wsgi module function install_apache_wsgi { ... enable_apache_server } # enable_apache_server() - Enabling apache server function enable_apache_server { _enable_service $APACHE_NAME }   对于 memcached，在安装处添加自启即可。代码位于 lib/keystone。\n1 2 3 4 5  # start_keystone() - Start running processes function start_keystone { ... _enable_service memcached }   虚拟化 对于 lemote Fedora 28 系统，必须确保 libvirt-python 和 python3-libvirt 软件包的版本一致，且高于 6.6.0，索性直接在代码中写死。该部分代码位于 lib/nova_plugins/functions-libvirt。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  # Installs required distro-specific libvirt packages. function install_libvirt { if is_ubuntu; then install_package qemu-system libvirt-clients libvirt-daemon-system libvirt-dev if is_arch \u0026#34;aarch64\u0026#34;; then install_package qemu-efi fi # uninstall in case the libvirt version changed pip_uninstall libvirt-python pip_install_gr libvirt-python #pip_install_gr \u0026lt;there-si-no-guestfs-in-pypi\u0026gt; elif is_fedora || is_suse; then # Optionally enable the virt-preview repo when on Fedora if [[ $DISTRO =~ f[0-9][0-9] ]] \u0026amp;\u0026amp; [[ ${ENABLE_FEDORA_VIRT_PREVIEW_REPO} == \u0026#34;True\u0026#34; ]]; then # https://copr.fedorainfracloud.org/coprs/g/virtmaint-sig/virt-preview/ sudo dnf copr enable -y @virtmaint-sig/virt-preview fi # Note that in CentOS/RHEL this needs to come from the RDO # repositories (qemu-kvm-ev ... which provides this package) # as the base system version is too old. We should have # pre-installed these install_package qemu-kvm install_package libvirt libvirt-devel if is_arch \u0026#34;aarch64\u0026#34;; then install_package edk2.git-aarch64 fi if ! is_lemote; then pip_uninstall libvirt-python pip_install_gr libvirt-python else # lemote install_package libvirt-6.6.0 install_package python3-libvirt-6.6.0 fi fi if [[ $DEBUG_LIBVIRT_COREDUMPS == True ]]; then _enable_coredump fi }   同时，系统只支持 custom 模式，模拟 Loongson-3A4000（见修改 CPU 模式部分）。默认的脚本只提供 none、host-model 和 host-passthrough 模式，参考 aarch64 体系结构，添加相关代码。该部分代码位于 lib/nova_plugins/hypervisor-libvirt。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # configure_nova_hypervisor - Set config files, create data dirs, etc function configure_nova_hypervisor { ... # arm64-specific configuration if is_arch \u0026#34;aarch64\u0026#34;; then iniset $NOVA_CONF libvirt cpu_mode \u0026#34;host-passthrough\u0026#34; fi # mips64-specific configuration if is_arch \u0026#34;mips64\u0026#34;; then iniset $NOVA_CONF libvirt cpu_mode \u0026#34;custom\u0026#34; iniset $NOVA_CONF libvirt cpu_models \u0026#34;Loongson-3A4000\u0026#34; fi ... }   移植 Nova 由于龙芯平台的 libvirt 和 QEMU/KVM 的实现还不完全，nova-compute 不经过修改无法在龙芯平台上正常运行。修改过的 Nova 代码见 https://github.com/FreeFlyingSheep/Nova。\n修改 CPU 模式 在未修改 CPU 模式时，运行 DevStack，尝试创建虚拟机时报错，查看日志显示 libvirt 内部错误，未知 CPU 类型 qemu64。\n查看 nova-compute 配置文件发现 DevStack 默认 CPU 模式设置为 none，尝试改为 host-model 和 host-passthrough，依然报 libvirt 内部错误，但错误内容变为不支持这两种模式。\n查看 libvirt 源码，定位报错的位置，发现龙芯平台上的 libvirt 实现并不完全，去把这些接口都实现了显然不现实。考虑到龙芯平台通过修改过的 virt-manager 是能正常创建虚拟机的，就想到比较龙芯平台的 virt-manager 创建虚拟机的参数和 nova-compute 默认创建的参数（主要比较生成的给 libvirt 使用的 xml 文件）。\n对比发现，virt-manager 生成的 xml 文件中，使用的是 custom 模式，模拟 Loongson-3A4000。修改 nova-compute 的配置文件，设置这两个参数，错误变为了没有使用 PCIe。\n修改 PCIe 配置 查看 Nova 源码，直接强制检查 PCIe 的函数对于 mips64el 架构返回 True。该部分代码位于 virt/libvirt/driver.py。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def _guest_needs_pcie(self, guest, caps): \u0026#34;\u0026#34;\u0026#34;Check for prerequisites for adding PCIe root port controllers \u0026#34;\u0026#34;\u0026#34; ... if caps.host.cpu.arch == fields.Architecture.MIPS64EL: return True if not CONF.libvirt.num_pcie_ports: return False if (caps.host.cpu.arch == fields.Architecture.AARCH64 and guest.os_mach_type.startswith(\u0026#39;virt\u0026#39;)): return True if (caps.host.cpu.arch == fields.Architecture.X86_64 and guest.os_mach_type is not None and \u0026#39;q35\u0026#39; in guest.os_mach_type): return True return False   重启 Nova 服务，发现虚拟机创建成功，但无法运行，错误变为了没法加载 BIOS。\n添加其他参数 继续比较 xml 文件，发现 virt-manager 生成的 xml 会指定 BIOS 文件和其他相关参数，查看 Nova 源码，将这部分内容写到对应位置。代码位于 virt/libvirt/driver.py。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def _configure_guest_by_virt_type(self, guest, virt_type, caps, instance, image_meta, flavor, root_device_name, sev_enabled): if virt_type == \u0026#34;xen\u0026#34;: ... elif virt_type in (\u0026#34;kvm\u0026#34;, \u0026#34;qemu\u0026#34;): if caps.host.cpu.arch in (fields.Architecture.I686, fields.Architecture.X86_64): guest.sysinfo = self._get_guest_config_sysinfo(instance) guest.os_smbios = vconfig.LibvirtConfigGuestSMBIOS() hw_firmware_type = image_meta.properties.get(\u0026#39;hw_firmware_type\u0026#39;) ... if image_meta.properties.get(\u0026#39;hw_boot_menu\u0026#39;) is None: guest.os_bootmenu = strutils.bool_from_string( flavor.extra_specs.get(\u0026#39;hw:boot_menu\u0026#39;, \u0026#39;no\u0026#39;)) else: guest.os_bootmenu = image_meta.properties.hw_boot_menu if caps.host.cpu.arch == fields.Architecture.MIPS64EL: guest.os_loader = \u0026#34;/usr/share/qemu/bios_loongson3.bin\u0026#34; guest.os_loader_type = \u0026#34;rom\u0026#34; guest.os_mach_type = \u0026#34;loongson3-virt\u0026#34; elif virt_type == \u0026#34;lxc\u0026#34;: ...   重启 Nova 服务，发现虚拟机成功创建，并运行，但控制台界面卡在了加载内核。\n修改显示模式（后来又改回去了） 查看日志，发现并没有任何报错。思考了一会，推测是内核其实已经成功启动，但没正常显示。\n继续对比 xml 文件，发现 nova-compute 默认使用的显卡设备模型为 cirrus，而 virt-manager 使用的显卡设备模型为 qxl。在 virt-manager 的选项中，没有找到 cirrus 显卡设备模型，怀疑不支持。\n于是修改 nova-compute 相关代码，使它在 mips64 架构下默认使用 qxl。该部分代码位于 virt/libvirt/driver.py。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  def _add_video_driver(self, guest, image_meta, flavor): ... if guest.os_type == fields.VMMode.XEN: video.type = \u0026#39;xen\u0026#39; elif CONF.libvirt.virt_type == \u0026#39;parallels\u0026#39;: video.type = \u0026#39;vga\u0026#39; elif guestarch in (fields.Architecture.PPC, fields.Architecture.PPC64, fields.Architecture.PPC64LE): # NOTE(ldbragst): PowerKVM doesn\u0026#39;t support \u0026#39;cirrus\u0026#39; be default # so use \u0026#39;vga\u0026#39; instead when running on Power hardware. video.type = \u0026#39;vga\u0026#39; elif guestarch == fields.Architecture.AARCH64: # NOTE(kevinz): Only virtio device type is supported by AARCH64 # so use \u0026#39;virtio\u0026#39; instead when running on AArch64 hardware. video.type = \u0026#39;virtio\u0026#39; elif (CONF.spice.enabled) or (guestarch == fields.Architecture.MIPS64): video.type = \u0026#39;qxl\u0026#39; if image_meta.properties.get(\u0026#39;hw_video_model\u0026#39;): video.type = image_meta.properties.hw_video_model if not self._video_model_supported(video.type): raise exception.InvalidVideoMode(model=video.type) ...   重启 Nova 服务，这次控制台界面显示出了开机动画，但发现键盘没有反应。\n添加键盘设备 鼠标能动但键盘没有反应，推测使没添加键盘，查看 xml 发现果然如此。\n在 Nova 中添加键盘。该部分代码位于 virt/libvirt/driver.py。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  def _get_guest_config(self, instance, network_info, image_meta, disk_info, rescue=None, block_device_info=None, context=None, mdevs=None, accel_info=None): \u0026#34;\u0026#34;\u0026#34;Get config data for parameters. :param rescue: optional dictionary that should contain the key \u0026#39;ramdisk_id\u0026#39; if a ramdisk is needed for the rescue image and \u0026#39;kernel_id\u0026#39; if a kernel is needed for the rescue image. :param mdevs: optional list of mediated devices to assign to the guest. :param accel_info: optional list of accelerator requests (ARQs) \u0026#34;\u0026#34;\u0026#34; ... self._guest_add_spice_channel(guest) if self._guest_add_video_device(guest): self._add_video_driver(guest, image_meta, flavor) # We want video == we want graphical console. Some architectures # do not have input devices attached in default configuration. # Let then add USB Host controller and USB keyboard. # x86(-64) and ppc64 have usb host controller and keyboard # s390x does not support USB if caps.host.cpu.arch in (fields.Architecture.AARCH64, fields.Architecture.MIPS64EL): self._guest_add_usb_host_keyboard(guest) # Some features are only supported \u0026#39;qemu\u0026#39; and \u0026#39;kvm\u0026#39; hypervisor if virt_type in (\u0026#39;qemu\u0026#39;, \u0026#39;kvm\u0026#39;): self._set_qemu_guest_agent(guest, flavor, instance, image_meta) self._add_rng_device(guest, flavor, image_meta) self._add_vtpm_device(guest, flavor, instance, image_meta) ...   重启 Nova 服务，键盘能正常使用了，但鼠标能移动却无法点击。\n改用 spice 听取同事建议后，索性改用 spice 协议，而不是 vnc 协议。这样可以移除 Nova 中显示模式部分的修改，鼠标也能正常使用了。\n对于 DevStack，只需要修改配置文件 local.conf 即可，添加两行内容：\n1 2  enable_service n-spice n-sproxy disable_service n-novnc n-xvnc   其他问题 创建虚拟机的过程中，一旦涉及 Cinder 服务，就会报错，因此暂时使用了 Nova 自带的创建卷功能。\n成功把 Nova 跑通后，开始解决 Cinder 无法映射块设备的问题。查看日志报错信息，发现是创建 LVM 卷的时候出错了。\n根据网上资料手动创建 LVM 卷，复现了报错信息，只要是使用 thin 模式，创建卷就会报错，这应该是系统中相关的软件包存在问题，暂时将 cinder 的 LVM 模式更换为 default，绕过了这个问题，成功创建了卷。\n还有一些问题，但暂时没想到解决办法。比如内核没有输出日志信息，检查 xml 确定已经重定向到了 console.log，内核启动也添加了相关参数。还有从 ISO 文件创建虚拟机时会报找不到设备等问题（由于系统的 QEMU/KVM 只支持龙芯的镜像，所以必须使用提前准备好的镜像）。\n对于 DevStack，最终的 local.conf 配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  [[local|localrc]] FORCE=yes ADMIN_PASSWORD=123456 DATABASE_PASSWORD=$ADMIN_PASSWORD RABBIT_PASSWORD=$ADMIN_PASSWORD SERVICE_PASSWORD=$ADMIN_PASSWORD GIT_BASE=https://github.com NOVA_REPO=https://github.com/FreeFlyingSheep/nova.git ETCD_DOWNLOAD_URL=https://fake-url DOWNLOAD_DEFAULT_IMAGES=False IMAGE_URLS=https://fake-url/fedora28.qcow2 CINDER_LVM_TYPE=default enable_service n-spice n-sproxy disable_service n-novnc n-xvnc   至此，OpenStack 的移植初步完成了，到了勉强能用的地步。因为暂时没有后续的需求，所以先到此为止了。\n","permalink":"https://freeflyingsheep.github.io/posts/openstack/lemote/","summary":"\u003cp\u003e整理工作中移植 OpenStack Victoria 版本核心组件到龙芯 lemote Fedora 28 系统上的过程。\u003c/p\u003e","title":"在龙芯上移植 OpenStack"},{"content":"根据相关资料整理 OpenStack 的相关概念。\nOpenStack 的定义 以下内容翻译自 Openstack 官网。\nOpenStack 是一个开源的云操作系统，可以通过具有通用身份验证机制的 API 进行管理和配置，来控制整个数据中心的大量计算、存储和网络资源池。\nOpenStack 提供了一个仪表板，可以让管理员进行控制，同时授权其用户通过 Web 界面配置资源。\nOpenStack 还提供了编排、故障管理和服务管理等等其他服务，以确保用户应用程序的高可用性。\nOpenStack 组件概览 图片来源于官网：\n下面只关注部分组件的功能，大部分内容翻译自 OpenStack Tutorial：\n Nova：基本计算引擎，管理着大量处理计算任务的虚拟机和其他实例。 Swift：提供对象存储的组件。 Cinder：提供块存储的组件。 Neutron：提供网络功能的组件，确保每个组件都与其他组件良好连接，从而在它们之间建立通信。 Horizo​​n：仪表板，为系统管理员提供了访问和管理云的所有可能性。 Keystone：提供身份验证的组件。 Glance：提供映像服务的组件。 Placement：实现统一的资源管理。 Tempest：提供自动化测试的组件。  OpenStack 的部署 OpenStack 的部署相对比较复杂，可以根据官网的教程。如果只是希望部署一个开发环境来学习 OpenStack，也可以使用官方的自动部署脚本 DevStack。\n以部署 DevStack 为例，建议运行脚本前进行以下修改：\n 添加 pypi 镜像：比如设置清华源。 在 local.conf 中指定 Git 镜像：比如设置 GIT_BASE 为 https://github.com。 添加 stack 用户后修改目录访问权限：比如 sudo chmod 755 /opt/stack。  如果中途因为网络问题而失败，直接通过 ./unstack.sh \u0026amp;\u0026amp; ./stack.sh 再次运行脚本即可。\n相关概念的补充说明 云计算模式 云计算的模式主要有三种：IaaS、PaaS 和 SaaS。其中，OpenStack 主要部署为 IaaS 模式。\n云计算模式的比较可以用一张图片概括（图片来源于阿里云）：\n更多资料可以参考 SaaS vs PaaS vs IaaS: What’s The Difference \u0026amp; How To Choose。\nAMQP AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是为 MOM（Message-oriented middleware，面向消息中间件）设计的开放标准应用层协议。\n更多内容可以参考 RabbitMQ（一）：RabbitMQ快速入门。\nREST REST（Representational State Transfer，表述性状态传递）是一种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性。\n更多内容可以参考 rest api 介绍。\nRPC RPC（Remote Procedure Call，远程过程调用）是相对于本地过程调用而言的，能像调用本地函数一样调用远程函数的协议。\n更多内容可以参考谁能用通俗的语言解释一下什么是 RPC 框架？ - 洪春涛的回答。\nETCD ETCD 是一个高可用的 Key/Value 存储系统，主要用于分享配置和服务发现。\n更多内容可以参考 ETCD 简介 + 使用。\nDjango Django 是一个 Python Web 框架，采用了 MVT 的软件设计模式，即模型（Model），视图（View）和模板（Template），被 Horizon 组件所使用。\n更多内容可以参考 Django 教程。\n个人理解 OpenStack 是由 Python 编写的一系列工具的集合，它是由若干个项目组成的。OpenStack 社区也是仅次于 Linux 的第二大开源社区。\nOpenStack 的各个组件并不是直接操控计算机系统的，而是借助于各种系统工具、函数库来管理计算机系统。相当于在现有操作系统上再进行了一层封装，来实现对多个计算机系统的管理。\nOpenStack 对内使用 AMQP 进行调用，对外则提供 REST API。\n","permalink":"https://freeflyingsheep.github.io/posts/openstack/introduction/","summary":"\u003cp\u003e根据相关资料整理 OpenStack 的相关概念。\u003c/p\u003e","title":"OpenStack 简介"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核红黑树。\n红黑树简介 红黑树是一种着色的自平衡的二叉搜索树，Linux 主要的平衡二叉树数据结构就是红黑树。\n红黑树满足以下几个条件：\n 每一个结点或者着成红色，或者着成黑色。 根结点和叶结点是黑色的。 如果一个结点是红色的，那么它的子结点必须是黑色的。 从一个结点到一个叶结点的每一条路径必须包含相同数目的黑色结点。  以上条件保证了红黑树最深的叶结点深度不会大于两倍的最浅叶结点深度（最长路径不会超过最短路径的两倍）。注意，叶结点不存储数据，都是 NULL 指针。\n红黑树的优点是插入、删除、搜索元素都可以在对数时间内完成，缺点是实现复杂。\n显然，红黑树完整的定义和性质的证明，不属于本系列学习笔记的范畴，可以参考数据结构书。\n内核红黑树的使用 内核红黑树的实现称为 rbtree，头文件为 include/linux/rbtree.h。内核红黑树的搜索和插入操作是没有给出完整实现的，一方面是出于 C 语言不方便泛型编程，另一方面是内核开发者相信最有效的搜索和插入方法需要由用户自行实现。用户可以使用提供的辅助函数，但需要自行实现比较操作算子。\n红黑树的创建 创建一个红黑树，需要为其分配一个根结点，并将其初始化为 RB_ROOT：\n1  struct rb_root root = RB_ROOT;   红黑树的搜索 下面是一个搜索的例子，rb_search_page_cache 函数实现了在页高速缓存中搜索一个文件区（由一个 i 结点和一个偏移量共同描述）。每个 i 结点都有自己的 rbtree，以关联在文件中的页偏移。该函数将搜索给定 i 结点的 rbtree，以寻找匹配的偏移值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  static inline struct page *rb_search_page_cache(struct inode * inode, unsigned long offset) { struct rb_node *n = inode-\u0026gt;i_rb_page_cache.rb_node; struct page *page; while (n) { page = rb_entry(n, struct page, rb_page_cache); if (offset \u0026lt; page-\u0026gt;offset) n = n-\u0026gt;rb_left; else if (offset \u0026gt; page-\u0026gt;offset) n = n-\u0026gt;rb_right; else return page; } return NULL; }   辅助宏 rb_entry 和内核链表的 list_entry 相似，获取包含结点的数据结构。\n查找特定的（前一个/后一个/第一个/最后一个）结点可以使用如下函数：\n1 2 3 4  struct rb_node *rb_next(const struct rb_node *node); struct rb_node *rb_prev(const struct rb_node *node); struct rb_node *rb_first(const struct rb_root *root); struct rb_node *rb_last(const struct rb_root *root);   红黑树的插入 插入函数需要实现搜索和插入逻辑。还是以上面的情景，对应的插入函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  static inline struct page *__rb_insert_page_cache(struct inode *inode, unsigned long offset, struct rb_node *node) { struct rb_node **p = \u0026amp;inode-\u0026gt;i_rb_page_cache.rb_node; struct rb_node *parent = NULL; struct page *page; while (*p) { parent = *p; page = rb_entry(parent, struct page, rb_page_cache); if (offset \u0026lt; page-\u0026gt;offset) p = \u0026amp;(*p)-\u0026gt;rb_left; else if (offset \u0026gt; page-\u0026gt;offset) p = \u0026amp;(*p)-\u0026gt;rb_right; else return page; } rb_link_node(node, parent, p); return NULL; } static inline struct page *rb_insert_page_cache(struct inode *inode, unsigned long offset, struct rb_node *node) { struct page *ret; if ((ret = __rb_insert_page_cache(inode, offset, node))) goto out; rb_insert_color(node, \u0026amp;inode-\u0026gt;i_rb_page_cache); out: return ret; }   辅助函数 rb_link_node() 负责在给定位置插入新结点，rb_insert_color() 负责执行复杂的再平衡操作。\n红黑树的删除 删除结点只需要调用以下函数：\n1  void rb_erase(struct rb_node *node, struct rb_root *root);   替换单个结点 替换单个结点只需要调用以下函数，该函数不会进行再平衡操作：\n1  void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);   内核红黑树的实现 内核红黑树的实现均位于 lib/rbtree.c 和 include/linux/rbtree.h。本系列学习笔记的重点不在数据结构，下面给出的代码的原理可以参考数据结构书，此处不做详细介绍。个人认为通常情况下，了解红黑树基本概念和如何使用提供的函数就足够了。\n红黑树的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14  struct rb_node { unsigned long rb_parent_color; #define RB_RED 0 #define RB_BLACK 1  struct rb_node *rb_right; struct rb_node *rb_left; } __attribute__((aligned(sizeof(long)))); /* The alignment might seem pointless, but allegedly CRIS needs it */ struct rb_root { struct rb_node *rb_node; };   其中，rb_parent_color 包含了两部分，一个是指向父结点的指针，另一个是当前结点的颜色，它是 rb_parent_color 的低 2 位。因为在所有体系结构上，指针都是至少 4 字节对齐的，所以这么做是可行的。\n正如注释所吐槽的，对齐到 sizeof(long) 似乎是多余的，或许这也是个历史遗留问题。\n辅助函数/宏的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #define rb_parent(r) ((struct rb_node *)((r)-\u0026gt;rb_parent_color \u0026amp; ~3)) #define rb_color(r) ((r)-\u0026gt;rb_parent_color \u0026amp; 1) #define rb_is_red(r) (!rb_color(r)) #define rb_is_black(r) rb_color(r) #define rb_set_red(r) do { (r)-\u0026gt;rb_parent_color \u0026amp;= ~1; } while (0) #define rb_set_black(r) do { (r)-\u0026gt;rb_parent_color |= 1; } while (0)  static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) { rb-\u0026gt;rb_parent_color = (rb-\u0026gt;rb_parent_color \u0026amp; 3) | (unsigned long)p; } static inline void rb_set_color(struct rb_node *rb, int color) { rb-\u0026gt;rb_parent_color = (rb-\u0026gt;rb_parent_color \u0026amp; ~1) | color; } #define RB_ROOT (struct rb_root) { NULL, } #define rb_entry(ptr, type, member) container_of(ptr, type, member)  #define RB_EMPTY_ROOT(root) ((root)-\u0026gt;rb_node == NULL) #define RB_EMPTY_NODE(node) (rb_parent(node) == node) #define RB_CLEAR_NODE(node) (rb_set_parent(node, node))   根据字面意思就可以理解这些辅助函数/宏的用途。\n红黑树的旋转的实现 左旋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static void __rb_rotate_left(struct rb_node *node, struct rb_root *root) { struct rb_node *right = node-\u0026gt;rb_right; struct rb_node *parent = rb_parent(node); if ((node-\u0026gt;rb_right = right-\u0026gt;rb_left)) rb_set_parent(right-\u0026gt;rb_left, node); right-\u0026gt;rb_left = node; rb_set_parent(right, parent); if (parent) { if (node == parent-\u0026gt;rb_left) parent-\u0026gt;rb_left = right; else parent-\u0026gt;rb_right = right; } else root-\u0026gt;rb_node = right; rb_set_parent(node, right); }   右旋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static void __rb_rotate_right(struct rb_node *node, struct rb_root *root) { struct rb_node *left = node-\u0026gt;rb_left; struct rb_node *parent = rb_parent(node); if ((node-\u0026gt;rb_left = left-\u0026gt;rb_right)) rb_set_parent(left-\u0026gt;rb_right, node); left-\u0026gt;rb_right = node; rb_set_parent(left, parent); if (parent) { if (node == parent-\u0026gt;rb_right) parent-\u0026gt;rb_right = left; else parent-\u0026gt;rb_left = left; } else root-\u0026gt;rb_node = left; rb_set_parent(node, left); }   红黑树的插入的实现 下面给出插入的辅助函数的实现。\n插入结点的实现 1 2 3 4 5 6 7 8  static inline void rb_link_node(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link) { node-\u0026gt;rb_parent_color = (unsigned long )parent; node-\u0026gt;rb_left = node-\u0026gt;rb_right = NULL; *rb_link = node; }   再平衡的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  void rb_insert_color(struct rb_node *node, struct rb_root *root) { struct rb_node *parent, *gparent; while ((parent = rb_parent(node)) \u0026amp;\u0026amp; rb_is_red(parent)) { gparent = rb_parent(parent); if (parent == gparent-\u0026gt;rb_left) { { register struct rb_node *uncle = gparent-\u0026gt;rb_right; if (uncle \u0026amp;\u0026amp; rb_is_red(uncle)) { rb_set_black(uncle); rb_set_black(parent); rb_set_red(gparent); node = gparent; continue; } } if (parent-\u0026gt;rb_right == node) { register struct rb_node *tmp; __rb_rotate_left(parent, root); tmp = parent; parent = node; node = tmp; } rb_set_black(parent); rb_set_red(gparent); __rb_rotate_right(gparent, root); } else { { register struct rb_node *uncle = gparent-\u0026gt;rb_left; if (uncle \u0026amp;\u0026amp; rb_is_red(uncle)) { rb_set_black(uncle); rb_set_black(parent); rb_set_red(gparent); node = gparent; continue; } } if (parent-\u0026gt;rb_left == node) { register struct rb_node *tmp; __rb_rotate_right(parent, root); tmp = parent; parent = node; node = tmp; } rb_set_black(parent); rb_set_red(gparent); __rb_rotate_left(gparent, root); } } rb_set_black(root-\u0026gt;rb_node); } EXPORT_SYMBOL(rb_insert_color);   红黑树的删除的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147  static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root) { struct rb_node *other; while ((!node || rb_is_black(node)) \u0026amp;\u0026amp; node != root-\u0026gt;rb_node) { if (parent-\u0026gt;rb_left == node) { other = parent-\u0026gt;rb_right; if (rb_is_red(other)) { rb_set_black(other); rb_set_red(parent); __rb_rotate_left(parent, root); other = parent-\u0026gt;rb_right; } if ((!other-\u0026gt;rb_left || rb_is_black(other-\u0026gt;rb_left)) \u0026amp;\u0026amp; (!other-\u0026gt;rb_right || rb_is_black(other-\u0026gt;rb_right))) { rb_set_red(other); node = parent; parent = rb_parent(node); } else { if (!other-\u0026gt;rb_right || rb_is_black(other-\u0026gt;rb_right)) { rb_set_black(other-\u0026gt;rb_left); rb_set_red(other); __rb_rotate_right(other, root); other = parent-\u0026gt;rb_right; } rb_set_color(other, rb_color(parent)); rb_set_black(parent); rb_set_black(other-\u0026gt;rb_right); __rb_rotate_left(parent, root); node = root-\u0026gt;rb_node; break; } } else { other = parent-\u0026gt;rb_left; if (rb_is_red(other)) { rb_set_black(other); rb_set_red(parent); __rb_rotate_right(parent, root); other = parent-\u0026gt;rb_left; } if ((!other-\u0026gt;rb_left || rb_is_black(other-\u0026gt;rb_left)) \u0026amp;\u0026amp; (!other-\u0026gt;rb_right || rb_is_black(other-\u0026gt;rb_right))) { rb_set_red(other); node = parent; parent = rb_parent(node); } else { if (!other-\u0026gt;rb_left || rb_is_black(other-\u0026gt;rb_left)) { rb_set_black(other-\u0026gt;rb_right); rb_set_red(other); __rb_rotate_left(other, root); other = parent-\u0026gt;rb_left; } rb_set_color(other, rb_color(parent)); rb_set_black(parent); rb_set_black(other-\u0026gt;rb_left); __rb_rotate_right(parent, root); node = root-\u0026gt;rb_node; break; } } } if (node) rb_set_black(node); } void rb_erase(struct rb_node *node, struct rb_root *root) { struct rb_node *child, *parent; int color; if (!node-\u0026gt;rb_left) child = node-\u0026gt;rb_right; else if (!node-\u0026gt;rb_right) child = node-\u0026gt;rb_left; else { struct rb_node *old = node, *left; node = node-\u0026gt;rb_right; while ((left = node-\u0026gt;rb_left) != NULL) node = left; if (rb_parent(old)) { if (rb_parent(old)-\u0026gt;rb_left == old) rb_parent(old)-\u0026gt;rb_left = node; else rb_parent(old)-\u0026gt;rb_right = node; } else root-\u0026gt;rb_node = node; child = node-\u0026gt;rb_right; parent = rb_parent(node); color = rb_color(node); if (parent == old) { parent = node; } else { if (child) rb_set_parent(child, parent); parent-\u0026gt;rb_left = child; node-\u0026gt;rb_right = old-\u0026gt;rb_right; rb_set_parent(old-\u0026gt;rb_right, node); } node-\u0026gt;rb_parent_color = old-\u0026gt;rb_parent_color; node-\u0026gt;rb_left = old-\u0026gt;rb_left; rb_set_parent(old-\u0026gt;rb_left, node); goto color; } parent = rb_parent(node); color = rb_color(node); if (child) rb_set_parent(child, parent); if (parent) { if (parent-\u0026gt;rb_left == node) parent-\u0026gt;rb_left = child; else parent-\u0026gt;rb_right = child; } else root-\u0026gt;rb_node = child; color: if (color == RB_BLACK) __rb_erase_color(child, parent, root); } EXPORT_SYMBOL(rb_erase);   红黑树的查找的实现 下面是查找特定的结点的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  /* * This function returns the first node (in sort order) of the tree. */ struct rb_node *rb_first(const struct rb_root *root) { struct rb_node *n; n = root-\u0026gt;rb_node; if (!n) return NULL; while (n-\u0026gt;rb_left) n = n-\u0026gt;rb_left; return n; } EXPORT_SYMBOL(rb_first); struct rb_node *rb_last(const struct rb_root *root) { struct rb_node *n; n = root-\u0026gt;rb_node; if (!n) return NULL; while (n-\u0026gt;rb_right) n = n-\u0026gt;rb_right; return n; } EXPORT_SYMBOL(rb_last); struct rb_node *rb_next(const struct rb_node *node) { struct rb_node *parent; if (rb_parent(node) == node) return NULL; /* If we have a right-hand child, go down and then left as far as we can. */ if (node-\u0026gt;rb_right) { node = node-\u0026gt;rb_right; while (node-\u0026gt;rb_left) node=node-\u0026gt;rb_left; return (struct rb_node *)node; } /* No right-hand children. Everything down and left is smaller than us, so any \u0026#39;next\u0026#39; node must be in the general direction of our parent. Go up the tree; any time the ancestor is a right-hand child of its parent, keep going up. First time it\u0026#39;s a left-hand child of its parent, said parent is our \u0026#39;next\u0026#39; node. */ while ((parent = rb_parent(node)) \u0026amp;\u0026amp; node == parent-\u0026gt;rb_right) node = parent; return parent; } EXPORT_SYMBOL(rb_next); struct rb_node *rb_prev(const struct rb_node *node) { struct rb_node *parent; if (rb_parent(node) == node) return NULL; /* If we have a left-hand child, go down and then right as far as we can. */ if (node-\u0026gt;rb_left) { node = node-\u0026gt;rb_left; while (node-\u0026gt;rb_right) node=node-\u0026gt;rb_right; return (struct rb_node *)node; } /* No left-hand children. Go up till we find an ancestor which is a right-hand child of its parent */ while ((parent = rb_parent(node)) \u0026amp;\u0026amp; node == parent-\u0026gt;rb_left) node = parent; return parent; } EXPORT_SYMBOL(rb_prev);   替换单个结点的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root) { struct rb_node *parent = rb_parent(victim); /* Set the surrounding nodes to point to the replacement */ if (parent) { if (victim == parent-\u0026gt;rb_left) parent-\u0026gt;rb_left = new; else parent-\u0026gt;rb_right = new; } else { root-\u0026gt;rb_node = new; } if (victim-\u0026gt;rb_left) rb_set_parent(victim-\u0026gt;rb_left, new); if (victim-\u0026gt;rb_right) rb_set_parent(victim-\u0026gt;rb_right, new); /* Copy the pointers/colour from the victim to the replacement */ *new = *victim; } EXPORT_SYMBOL(rb_replace_node);   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/rbtree/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核红黑树。\u003c/p\u003e","title":"内核红黑树"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存寻址。\n简介 这部分内容和体系结构密切相关，而且涉及了大量过时的内容，我对这一块内容的兴趣也不大，所以这里只对 Intel x86 体系结构做很简单的介绍。\n更多资料建议参考 Intel 官方文档和 AMD 官方文档。\n分段内存模式 以下内容仅针对 Intel x86_32 体系结构。\n逻辑地址 逻辑地址（logical address）由一个段（segment）和偏移量（offset 或 displacement）组成。\n线性地址（虚拟地址） 线性地址（linear address）也被称作虚拟地址（virtual address），是 32 位的无符号整数。\n物理地址 用于内存芯片级内存单元寻址。\n地址间的关系 1  逻辑地址 \u0026lt;--- 分段单元 ---\u0026gt; 线性地址（虚拟地址）\u0026lt;--- 分页单元 ---\u0026gt; 物理地址   再次强调，线性地址就是虚拟地址，这两者是完全等价的。\n平坦内存模式 在 x86_64 体系结构中，分段被禁用了，内存是平坦的。\n线性地址是 48 位的。\n尽管 x86_64 理论上可以支持 64 位的线性地址，但目前 48 位已经足够使用了，所以处理器硬件通常也只提供了 48 条地址线。\n分段 现在是 64 位处理器的时代，分段基本被废弃了，这里只给出几个参考资料：\n GDT。 LDT。 IDT。 TSS。  相关的代码我准备放到系统启动部分一起介绍，见 TODO。\n分页 对于 32 位系统，两级页表已经足够了；而对于 64 位系统，往往需要更多的分页级别。\nLinux 采用了四级分页模型，如下图所示：\n相关的宏和函数基本位于 arch/x86/include/asm/pgtable.h，大部分看名字就能猜测出功能，实现也比较简单，这里不准备展开了。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/address/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍内存寻址。\u003c/p\u003e","title":"内存寻址"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核位图。\n内核位图的使用 下面只列举常用的内核位图函数/宏，头文件为 include/linux/bitops.h。\n创建位图 1  DECLARE_BITMAP(name,bits);   定义一个名称为 name 且至少包含 bits 位的位图。\n设置位 1  void set_bit(unsigned int nr, volatile unsigned long *addr);   清除位 1  void clear_bit(int nr, volatile unsigned long *addr);   改变位 1  void change_bit(int nr, volatile unsigned long *addr);   测试并设置位 1  int test_and_set_bit(int nr, volatile unsigned long *addr);   若被测试位为 0，返回 0，反之返回非 0 值。\n测试并清除位 1  int test_and_clear_bit(int nr, volatile unsigned long *addr);   若被测试位为 0，返回 0，反之返回非 0 值。\n测试并改变位 1  int test_and_change_bit(int nr, volatile unsigned long *addr);   若被测试位为 0，返回 0，反之返回非 0 值。\n测试位 1  int test_bit(int nr, const volatile unsigned long *addr);   若被测试位为 0，返回 0，反之返回非 0 值。\n内核位图的实现 定义内核位图的宏位于 include/linux/types.h。内核位操作的实现分为两部分，体系结构无关的实现位于 include/linux/bitops.h，x86 体系结构相关的部分位于 arch/x86/include/asm/bitops.h。\n创建位图的实现 include/linux/types.h：\n1 2  #define DECLARE_BITMAP(name,bits) \\ unsigned long name[BITS_TO_LONGS(bits)]   include/linux/bitops.h：\n1 2  #define BITS_PER_BYTE 8 #define BITS_TO_LONGS(nr) DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))   辅助宏的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #if __GNUC__ \u0026lt; 4 || (__GNUC__ == 4 \u0026amp;\u0026amp; __GNUC_MINOR__ \u0026lt; 1) /* Technically wrong, but this avoids compilation errors on some gcc versions. */ #define BITOP_ADDR(x) \u0026#34;=m\u0026#34; (*(volatile long *) (x)) #else #define BITOP_ADDR(x) \u0026#34;+m\u0026#34; (*(volatile long *) (x)) #endif  #define ADDR BITOP_ADDR(addr)  /* * We do the locked ops that don\u0026#39;t return the old value as * a mask operation on a byte. */ #define IS_IMMEDIATE(nr) (__builtin_constant_p(nr)) #define CONST_MASK_ADDR(nr, addr) BITOP_ADDR((void *)(addr) + ((nr)\u0026gt;\u0026gt;3)) #define CONST_MASK(nr) (1 \u0026lt;\u0026lt; ((nr) \u0026amp; 7))   IS_IMMEDIATE 宏判断 nr 是否是整数常量。如果把位图看成 8 列的二维数组，那么 CONST_MASK_ADDR 宏负责计算行号，CONST_MASK 宏负责计算列号。\n设置位的实现 arch/x86/include/asm/bitops.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * set_bit - Atomically set a bit in memory * @nr: the bit to set * @addr: the address to start counting from * * This function is atomic and may not be reordered. See __set_bit() * if you do not require the atomic guarantees. * * Note: there are no guarantees that this function will not be reordered * on non x86 architectures, so if you are writing portable code, * make sure not to rely on its reordering guarantees. * * Note that @nr may be almost arbitrarily large; this function is not * restricted to acting on a single-word quantity. */ static __always_inline void set_bit(unsigned int nr, volatile unsigned long *addr) { if (IS_IMMEDIATE(nr)) { asm volatile(LOCK_PREFIX \u0026#34;orb %1,%0\u0026#34; : CONST_MASK_ADDR(nr, addr) : \u0026#34;iq\u0026#34; ((u8)CONST_MASK(nr)) : \u0026#34;memory\u0026#34;); } else { asm volatile(LOCK_PREFIX \u0026#34;bts %1,%0\u0026#34; : BITOP_ADDR(addr) : \u0026#34;Ir\u0026#34; (nr) : \u0026#34;memory\u0026#34;); } }   LOCK_PREFIX 的实现原理涉及锁，见 TODO。\n查阅相关手册，可以知道这里 q 修饰符代表使用 8 位寄存器（例如 al、bl 等）。\nbts 指令（Bit Test and Set）是位测试并置位指令，此处 bts %1,%0 即先测试 %0 内存处的 %1 位的值，存入 CF 标志寄存器，再将该位置 1。\n清除位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /** * clear_bit - Clears a bit in memory * @nr: Bit to clear * @addr: Address to start counting from * * clear_bit() is atomic and may not be reordered. However, it does * not contain a memory barrier, so if it is used for locking purposes, * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit() * in order to ensure changes are visible on other processors. */ static __always_inline void clear_bit(int nr, volatile unsigned long *addr) { if (IS_IMMEDIATE(nr)) { asm volatile(LOCK_PREFIX \u0026#34;andb %1,%0\u0026#34; : CONST_MASK_ADDR(nr, addr) : \u0026#34;iq\u0026#34; ((u8)~CONST_MASK(nr))); } else { asm volatile(LOCK_PREFIX \u0026#34;btr %1,%0\u0026#34; : BITOP_ADDR(addr) : \u0026#34;Ir\u0026#34; (nr)); } }   btr 指令（Bit Test and Reset）是位测试并复位指令。\n改变位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /** * change_bit - Toggle a bit in memory * @nr: Bit to change * @addr: Address to start counting from * * change_bit() is atomic and may not be reordered. * Note that @nr may be almost arbitrarily large; this function is not * restricted to acting on a single-word quantity. */ static inline void change_bit(int nr, volatile unsigned long *addr) { if (IS_IMMEDIATE(nr)) { asm volatile(LOCK_PREFIX \u0026#34;xorb %1,%0\u0026#34; : CONST_MASK_ADDR(nr, addr) : \u0026#34;iq\u0026#34; ((u8)CONST_MASK(nr))); } else { asm volatile(LOCK_PREFIX \u0026#34;btc %1,%0\u0026#34; : BITOP_ADDR(addr) : \u0026#34;Ir\u0026#34; (nr)); } }   btc 指令（Bit Test and Complement）是位测试并取反指令。\n测试并设置位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * test_and_set_bit - Set a bit and return its old value * @nr: Bit to set * @addr: Address to count from * * This operation is atomic and cannot be reordered. * It also implies a memory barrier. */ static inline int test_and_set_bit(int nr, volatile unsigned long *addr) { int oldbit; asm volatile(LOCK_PREFIX \u0026#34;bts %2,%1\\n\\t\u0026#34; \u0026#34;sbb %0,%0\u0026#34; : \u0026#34;=r\u0026#34; (oldbit), ADDR : \u0026#34;Ir\u0026#34; (nr) : \u0026#34;memory\u0026#34;); return oldbit; }   这里很巧妙地借助了 sbb 指令执行带借位减法。如果 CF 标志被置位，函数返回 -1，反之返回 0。\n测试并清除位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * test_and_clear_bit - Clear a bit and return its old value * @nr: Bit to clear * @addr: Address to count from * * This operation is atomic and cannot be reordered. * It also implies a memory barrier. */ static inline int test_and_clear_bit(int nr, volatile unsigned long *addr) { int oldbit; asm volatile(LOCK_PREFIX \u0026#34;btr %2,%1\\n\\t\u0026#34; \u0026#34;sbb %0,%0\u0026#34; : \u0026#34;=r\u0026#34; (oldbit), ADDR : \u0026#34;Ir\u0026#34; (nr) : \u0026#34;memory\u0026#34;); return oldbit; }   测试并改变位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * test_and_change_bit - Change a bit and return its old value * @nr: Bit to change * @addr: Address to count from * * This operation is atomic and cannot be reordered. * It also implies a memory barrier. */ static inline int test_and_change_bit(int nr, volatile unsigned long *addr) { int oldbit; asm volatile(LOCK_PREFIX \u0026#34;btc %2,%1\\n\\t\u0026#34; \u0026#34;sbb %0,%0\u0026#34; : \u0026#34;=r\u0026#34; (oldbit), ADDR : \u0026#34;Ir\u0026#34; (nr) : \u0026#34;memory\u0026#34;); return oldbit; }   测试位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr) { return ((1UL \u0026lt;\u0026lt; (nr % BITS_PER_LONG)) \u0026amp; (((unsigned long *)addr)[nr / BITS_PER_LONG])) != 0; } static inline int variable_test_bit(int nr, volatile const unsigned long *addr) { int oldbit; asm volatile(\u0026#34;bt %2,%1\\n\\t\u0026#34; \u0026#34;sbb %0,%0\u0026#34; : \u0026#34;=r\u0026#34; (oldbit) : \u0026#34;m\u0026#34; (*(unsigned long *)addr), \u0026#34;Ir\u0026#34; (nr)); return oldbit; } #if 0/* Fool kernel-doc since it doesn\u0026#39;t do macros yet */ /** * test_bit - Determine whether a bit is set * @nr: bit number to test * @addr: Address to start counting from */ static int test_bit(int nr, const volatile unsigned long *addr); #endif  #define test_bit(nr, addr) \\ (__builtin_constant_p((nr)) \\ ? constant_test_bit((nr), (addr)) \\ : variable_test_bit((nr), (addr)))   bt 指令（Bit Test）是位测试指令。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/bitmap/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核位图。\u003c/p\u003e","title":"内核位图"},{"content":"Linux 内核学习笔记系列，TODO 列表，慢慢填坑。\n 内核位图 155 行，锁相关内容。 内核队列 261 行，屏障相关内容。 内核基数树 247 行，RCU 相关的内容。 内存寻址 61 行，系统启动相关内容。 内存模型 68 行，交换守护进程相关内容。 内存模型 141 行，避免碎片相关内容。 内存模型 279 和 300 行，内存扫描相关内容。 内存模型 306 行，等待队列相关内容。 内存模型 383 行，匿名页相关内容。 内存模型 385 行，活动页和不活动页相关内容。 连续页框的管理 532 行，块设备驱动程序相关内容。 slab 分配器 448 行，内核同步相关内容。 ","permalink":"https://freeflyingsheep.github.io/posts/kernel/todo/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，TODO 列表，慢慢填坑。\u003c/p\u003e","title":"TODO 列表"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍内存模型。\n内存模型简介 简单概括，内存被划分为若干个结点，每个结点又被划分为若干个区，而每个区又包含若干页框。\n结点（Node） 结点简介 我们习惯上认为计算机内存是一种均匀、共享的资源，即在忽略硬件高速缓存作用的情况下，任意 CPU 对任意内存单元的访问都需要相同时间。这种模型被称为一致访问内存（UMA） 模型。IBM 兼容 PC 一般都采用这种模型。\n但对于某些体系结构，如 ALpha 或 MIPS，这种假设不成立。它们使用非一致访问内存（NUMA） 模型。\nLinux 支持 NUMA 模型，它通过把物理内存划分为多个结点，来保证对于每个结点，给定的 CPU 访问页面需要的时间相同。这样对于每个 CPU，内核可以试图把耗时结点的访问次数减到最小。\n在配置不使用 NUMA 的情况下，Linux 还是会使用一个单独的结点，包括所有的物理内存。\n结点数据结构 include/linux/mm_types.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  typedef struct pglist_data { struct zone node_zones[MAX_NR_ZONES]; struct zonelist node_zonelists[MAX_ZONELISTS]; int nr_zones; ... struct page *node_mem_map; ... struct bootmem_data *bdata; ... unsigned long node_start_pfn; unsigned long node_present_pages; /* total number of physical pages */ unsigned long node_spanned_pages; /* total size of physical page range, including holes */ int node_id; wait_queue_head_t kswapd_wait; struct task_struct *kswapd; int kswapd_max_order; } pg_data_t;    node_zones：包含结点中区数据结构的数组。若区没有那么多，其余项用 0 填充。 node_zonelists：备用结点及内存区域列表，以便在当前结点没有可用空间时，在备用结点分配内存。 nr_zones：不同区的数目。 node_mem_map：指向页实例的指针，包含了当前结点所有区的页。 bdata：指向自举内存分配器实例的指针，见内存管理初始化。 node_start_pfn：当前结点第一个页帧的逻辑编号，系统中所有页帧是依次编号的，因此每个页帧的号码都是全局唯一的。特别地，在 UMA 系统中，因为只有一个结点，所以该值总为 0。 node_present_pages：当前结点中页帧的数目。 node_spanned_pages：以页帧为单位计算的长度。 node_id：全局结点编号，从 0 开始。 kswapd_wait、kswapd 和 kswapd_max_order：交换守护进程（swap daemon）相关的内容，见 TODO。  结点状态管理 include/linux/nodemask.h：\n1 2 3 4 5 6 7 8 9 10 11 12  enum node_states { N_POSSIBLE, /* The node could become online at some point */ N_ONLINE, /* The node is online */ N_NORMAL_MEMORY, /* The node has regular memory */ #ifdef CONFIG_HIGHMEM  N_HIGH_MEMORY, /* The node has regular or high memory */ #else  N_HIGH_MEMORY = N_NORMAL_MEMORY, #endif  N_CPU, /* The node has one or more cpus */ NR_NODE_STATES };   N_POSSIBLE、N_ONLINE 和 N_NORMAL_MEMORY 用于内存热插拔，这部分内容不属于该系列学习笔记的范畴。\n设置和清除结点的特定位使用 void node_set_state(int node, enum node_states state) 和 void node_clear_state(int node, enum node_states state) 函数。\n区（内存域，Zone） 区简介 理想模型中，所有的页框都是相同的，可以对其执行任何操作。现实中，硬件是有限制的：\n 一些硬件只能用某些特定的内存地址来执行 DMA。 一些体系结构的内存的物理地址范围比虚拟地址范围大得多，线性地址空间太小导致 CPU 不能直接访问所有的物理内存。  对内存的每个结点，Linux 分了 3 个区来解决这些限制：\n ZONE_DMA：执行 DMA 操作的页框。 ZONE_NORMAL：能正常映射的页框。 ZONE_HIGHMEM：动态映射的页框。  此处两本书的描述略有不同，《Linux 内核设计与实现》基于 2.6.34 版本，这时候已经新加了 ZONE_DMA32 区，该区和 ZONE_DMA 的区别在于这个区能被 32 位的设备访问。在 32 位系统上，该区长度为 0，而在 64 位系统上，该区长度可能为 0-4G。该区是 2.6.14 版本添加的，参考社区新闻 ZONE_DMA32。\nZONE_HIGHMEM 区的内存被称为高端内存，其余部分则被称为低端内存。\n举个例子，在 x86 上，ZONE_DMA 包含了物理内存 0-16MB，ZONE_NORMAL 包含了 16-896MB，ZONE_HIGHMEM 包含了剩下的部分。\n但不是所有体系结构都定义了全部区，如 x86-64 可以映射处理 64 位的内存空间，就不需要 ZONE_HIGHMEM 区了。\n区的类型 include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  enum zone_type { #ifdef CONFIG_ZONE_DMA  ZONE_DMA, #endif #ifdef CONFIG_ZONE_DMA32  ZONE_DMA32, #endif  ZONE_NORMAL, #ifdef CONFIG_HIGHMEM  ZONE_HIGHMEM, #endif  ZONE_MOVABLE, __MAX_NR_ZONES };   其中，ZONE_MOVABLE 是伪内存区域，用于防止内存碎片的机制，见 TODO。__MAX_NR_ZONES 在构建过程中会生成 include/generated/bounds.h 中的 MAX_NR_ZONES 宏（具体生成过程涉及 Kbuild，已经不属于本系列学习笔记的范畴），充当结束标记。\n区数据结构 区相关的枚举和结构体大部分位于 include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  struct zone { /* Fields commonly accessed by the page allocator */ unsigned long watermark[NR_WMARK]; unsigned long lowmem_reserve[MAX_NR_ZONES]; struct per_cpu_pageset __percpu *pageset; /* * free areas of different sizes */ spinlock_t lock; ... struct free_area free_area[MAX_ORDER]; ... ZONE_PADDING(_pad1_) /* Fields commonly accessed by the page reclaim scanner */ spinlock_t lru_lock; struct zone_lru { struct list_head list; } lru[NR_LRU_LISTS]; ... unsigned long pages_scanned; /* since last reclaim */ unsigned long flags; /* zone flags, see below */ /* Zone statistics */ atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS]; int prev_priority; ... ZONE_PADDING(_pad2_) /* Rarely used or read-mostly fields */ wait_queue_head_t * wait_table; unsigned long wait_table_hash_nr_entries; unsigned long wait_table_bits; /* * Discontig memory support fields. */ struct pglist_data *zone_pgdat; /* zone_start_pfn == zone_start_paddr \u0026gt;\u0026gt; PAGE_SHIFT */ unsigned long zone_start_pfn; unsigned long spanned_pages; /* total size, including holes */ unsigned long present_pages; /* amount of memory (excluding holes) */ /* * rarely used fields: */ const char *name; } ____cacheline_internodealigned_in_smp;   该结构体被 ZONE_PADDING 分割为多个部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * zone-\u0026gt;lock and zone-\u0026gt;lru_lock are two of the hottest locks in the kernel. * So add a wild amount of padding here to ensure that they fall into separate * cachelines. There are very few zone structures in the machine, so space * consumption is not a concern here. */ #if defined(CONFIG_SMP) struct zone_padding { char x[0]; } ____cacheline_internodealigned_in_smp; #define ZONE_PADDING(name) struct zone_padding name; #else #define ZONE_PADDING(name) #endif   因为对该结构体的访问非常频繁，在多处理系统上，通常会有不同的 CPU 试图访问结构体成员。使用 ZONE_PADDING 宏填充结构体，以确保每个自旋锁都处于自己的缓存行中。使用 ____cacheline_internodealigned_in_smp，实现最优的告诉缓存对齐方式。\n第一部分 先来看该结构体的第一部分，通常由页分配器访问的字段。\nwatermark 是页换出时使用的“水位标志”：\n1 2 3 4 5 6  enum zone_watermarks { WMARK_MIN, WMARK_LOW, WMARK_HIGH, NR_WMARK };   在较早版本的内核中，“水位标志”由三个 unsigned long 变量 pages_min、pages_low 和 pages_high 构成，现在它们被合并到了 watermark 数组。下面为了方便讨论该数组的三个元素，依然使用它们的旧变量名。\n这三个元素会影响交换守护程序的行为，这里只做简单介绍：\n pages_high：若空闲页多于该值，则区的状态是理想的。 pages_low：若空闲页低于该值，则内核开始讲页换出到硬盘。 pages_min：若空闲页低于该值，那么页回收工作的压力较大，内存急需空闲页。  lowmem_reserve 数组代表每个区必须保留的页框数目，见保留的页框池。\npageset 用于实现每个 CPU 的冷/热页帧列表，见 per-CPU 高速缓存。\nfree_area 用于实现伙伴系统，见伙伴系统。\n第二部分 再来看该结构体的第二部分，通常由页面回收扫描程序访问的字段。\n根据 lru 数组的名字，可以推测现在内核使用了 LRU 算法来管理页，该数组包含了若干个链表：\n1 2 3 4 5 6 7 8 9 10 11 12  #define LRU_BASE 0 #define LRU_ACTIVE 1 #define LRU_FILE 2  enum lru_list { LRU_INACTIVE_ANON = LRU_BASE, LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE, LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE, LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE, LRU_UNEVICTABLE, NR_LRU_LISTS };   这里先定义宏，再用宏的值定义枚举成员的值，目的是方便后续计算时使用这些宏的值，同时又可以用枚举成员作为与之对应的数组下标。\n较早的版本没有使用 lru 数组，而是用 struct list_head active_list 表示活动页的集合，struct list_head inactive_list 表示不活动页的集合，unsigned long nr_scan_active 和 unsigned long nr_scan_inactive 指定在回收内存时需要扫描的活动页和不活动页的数目，后面的内容针对的是较新的版本。\npages_scanned 指定了上次换出一页以来，有多少页未能成功扫描，见 TODO。\nflags 描述当前区的状态：\n1 2 3 4  typedef enum { ZONE_RECLAIM_LOCKED, /* prevents concurrent reclaim */ ZONE_OOM_LOCKED, /* zone is in OOM killer zonelist */ } zone_flags_t;   同样的，内核提供了相应的辅助函数来设置状态：\n1 2 3  void zone_set_flag(struct zone *zone, zone_flags_t flag); int zone_test_and_set_flag(struct zone *zone, zone_flags_t flag); void zone_clear_flag(struct zone *zone, zone_flags_t flag);   vm_stat 维护了当前区的统计信息。可以使用辅助函数 unsigned long zone_page_state(struct zone *zone, enum zone_stat_item item) 来读取其中的信息，该函数定义于 include/linux/vmstat.h。\nprev_priority 存储了上一次扫描操作扫描当前区的优先级，见 TODO。\n第三部分 最后来看该结构体的第三部分，很少使用或大多数情况下只读的字段。\nwait_table、wait_table_hash_nr_entries 和 wait_table_bits 实现了一个等待队列，可用于等待某一页变为可用进程。可以简单理解为进程排成一一个队列，等待某些条件，在条件变为真时，内核会通知进程恢复工作。具体原理见 TODO。\nzone_pgdat 指向对应的 pg_list_data 实例，建立了区和父结点之间的关联。\nzone_start_pfn 是内存域第一个页帧的索引。\nspanned_pages 指定区中页的总数，但并非所有都是可用的，内存中可能存在一些小的空洞。\npresent_pages 则给出了实际可用的页的总数。\nname 是一个字符串，保存当前区的惯用名称。\n页（Page） 页和页框简介 页框是系统内存的最小单位，对内存中的每个页，内核都会创建一个 struct page 实例。\n注意区分术语“页”和“页框”。操作系统为了方便管理存储器，把数据分成固定大小的区块，这些区块被称为页（页面，page）。处理器的分页单元会根据页的大小把物理内存划分为若干个物理块，这些物理块就是页框（页帧，page frame）。页存放于页框中，而 struct page 是页对应的描述符。\n页数据结构 页的数据结构在较新的内核中由 include/linux/mm.h 移到了 include/linux/mm_types.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  struct page { unsigned long flags; /* Atomic flags, some possibly * updated asynchronously */ atomic_t _count; /* Usage count, see below. */ union { atomic_t _mapcount; /* Count of ptes mapped in mms, * to show when page is mapped * \u0026amp; limit reverse map searches. */ struct { /* SLUB */ u16 inuse; u16 objects; }; }; union { struct { unsigned long private; /* Mapping-private opaque data: * usually used for buffer_heads * if PagePrivate set; used for * swp_entry_t if PageSwapCache; * indicates order in the buddy * system if PG_buddy is set. */ struct address_space *mapping; /* If low bit clear, points to * inode address_space, or NULL. * If page mapped as anonymous * memory, low bit is set, and * it points to anon_vma object: * see PAGE_MAPPING_ANON below. */ }; ... struct kmem_cache *slab; /* SLUB: Pointer to slab */ struct page *first_page; /* Compound tail pages */ }; union { pgoff_t index; /* Our offset within mapping. */ void *freelist; /* SLUB: freelist req. slab lock */ }; struct list_head lru; /* Pageout list, eg. active_list * protected by zone-\u0026gt;lru_lock ! */ #if defined(WANT_PAGE_VIRTUAL)  void *virtual; /* Kernel virtual address (NULL if not kmapped, ie. highmem) */ #endif /* WANT_PAGE_VIRTUAL */ ... };    flags：存储体系结构无关的标志，用于描述页的属性，相关标志位于 include/linux/page-flags.h。 _count：使用计数，表示内核中引用该页的次数。在其值为 0 时，内核知道 page 实例当前不使用，因此可以删除。 _mapcount：表示在页表中有多少项指向该页。 inuse、objects、slab 和 freelist：用于 slub 分配器，这部分内容不属于该学习笔记的范畴。 private：指向“私有”数据的指针，这里不准备展开介绍。 mapping 和 index：分部指定了页框所在的地址空间和页框在映射内部的偏移量。特别地，若 mapping 的低位被置 1，则该指针不指向 address_space 实例，而是指向 anon_vma，实现匿名页的逆向映射，见 TODO。 first_page：指向首页的指针。内核可以将多个连续的页合并成较大的复合页（compound page），分组中的第一个页被称为首页（head page），其余各页称为尾页（tail page）。 lru：用于在各种链表上维护该页，以便将页按不同类别分组。一个重要的例子是活动页和不活动页，见 TODO。 virtual：存储高端内存区域中页的虚拟地址。  用联合体的原因是，某些字段只会被内核的特定部分使用，对于其他部分是多余的，而 C 语言的联合体刚好能解决这一问题。例如，若某一页被用于 slub 分配器，则可以确保该页只被内核使用，那映射计数信息（_mapcount）就是多余的，该字段可以被用来存储 slub 分配器相关的信息（inuse 和 objects）。\n值得注意的是，mapping 指向的 address_space 实例总是对齐到 sizeof(long)，因此该指针的低位总是 0，可以用于存储额外的信息。内核中很多地方利用了这种方式，来尽可能地节约内存使用，但这种方式从可读性角度来看，确实是很糟糕的，正如书上说的，这是一种近乎“肆无忌惮”的技巧。\n个人理解 内核开发者试图在可读性与高效间权衡，在希望节省关键数据结构占用的空间时，他们尽可能复用现有的字段，甚至不想看到任何一个多余的字段。而在复用字段时，由于内核不同的部分需要的字段类型可能不同，他们不能接受用同一个类型来表示不同的数据类型，因此使用联合体来解决这一问题，如上面的 _mapcount、inuse 和 objects。但对于一些字段，如上面的 private，因为不同内核部分使用时需要的类型相同，都是 unsigned long，所以就没用到联合体。而对于一些特定的数据，如上面的指针 mapping，因为低位总是 0，所以低位可以用于存储额外的信息，进一步节省内存占用。如果说用联合体是为了可读性，复用字段是为了高效（降低内存占用），page 结构体则是这两者结合的产物。\n既然是为了可读性和高效，那思考下面的问题：\n 从可读性角度出发，就如上面的 private，为何不用联合体来为不同内核部分定义不同的字段名？ 从高效角度出发，对于其他指针，为何不复用它们的低位存储其他信息，来进一步减少内存空间的使用？ 可读性和高效间的度谁来权衡，怎么权衡？  这究竟是不是一种好的编程技巧呢？或许与大部分人的想法背道而驰，我认为这种代码是“糟糕的”而不是“巧妙的”，这更像是高手的“任性”，尽管这种技巧确实为内核节省了很多空间。\n我认为学习内核，重要的学习它的设计思想和实用的编程技巧。而上面用到的一些编程技巧，个人认为并不“实用”。在平时开发过程中，如果不是遇到一些极端的情况，比如需要尽可能压榨内存的使用等等，完全没必要做到这种程度，滥用这些编程技巧的危害往往更大。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/model/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍内存模型。\u003c/p\u003e","title":"内存模型"},{"content":"Linux 内核学习笔记系列，内核开发部分，简单介绍 Linux 内核的开发结构的相关知识，以提供参考资料为主。\n内核开发 内核文档中提供了大量关于内核开发的内容，具体可以参考 The Linux Kernel documentation。\n开发结构 命令链 内核所有活动组件都有一个维护者，维护者在 MAINTAINERS 文件中给出，具体内容可以直接看该文件头部的说明文字。\n开发周期 在一个新的内核版本发布后，Linus Torvalds 会打开一个合并窗口（merge window），在比较短的一段时间内保持开放，大约两星期。新代码通常只能在这段时间内加入。\n合并窗口关闭时，候选的发布版内核也准备好了。候选发布版提供了一个机会，可以测试各项修改之间的交互，以及识别并修复bug。\n在一切都稳定以后，一个新的内核版本就发布了。\n在线资源  https://www.kernel.org/：包含了内核源代码及许多基本的用户空间工具。 https://git.kernel.org/：Git 源代码的存储库。 https://lwn.net/：内核开发过程方面的首要信息源，收集了 Linux 开发所有方面的有趣新闻以及 IT 社区中的相关事件，而优秀的研究文章对各个项目的发展现状给出了深刻的见解。  编码风格 具体可以参考 Linux kernel coding style。\n补丁结构 现在建议使用 Git 来管理补丁。\n提交补丁可以参考 Submitting patches: the essential guide to getting your code into the kernel。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/develop/develop/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内核开发部分，简单介绍 Linux 内核的开发结构的相关知识，以提供参考资料为主。\u003c/p\u003e","title":"内核开发相关知识"},{"content":"Linux 内核学习笔记系列，内核开发部分，简单介绍 Linux 内核体系结构和可移植性相关的内容。\n体系结构相关的源码目录 为了便于扩展到新的体系结构，内核严格隔离了与体系结构相关和无关的代码。\n在较早的版本中，与体系结构 T 相关的 C 和汇编源码位于 arch/T 目录下，头文件则位于 include/asm-T。后来，体系结构相关的头文件挪到了 arch/T/include/asm 下。\n本系列学习笔记主要基于 Linux 2.6.34 版本，且仅针对 x86 体系结构，所以对于体系结构相关的代码，我只关心 arch/x86 目录。\n字长 字长是指机器一次能完成处理的数据。处理器的通用寄存器的大小应该和它的字长是一致的。\n对于 x86 处理器，有 32 位（i386）和 64 位（x86-64）的版本，出于历史原因和某些主观的命名习惯，我们根据长度来划分数据，长度的单位是位（bit）：\n   名称 长度     字节（byte） 8   字（word） 16   双字（double word） 32   四字（quad word） 64    在 Linux 中，一个字通常代表处理器的字长。对于 32 位的 i386，字长是 32 位（4 字节）；对于 64 位的 x86-64，字长是 64 位（8 字节）。\n具体“字”的含义，要根据上下文来确定。\n数据类型 C 标准并未明确指定数据类型的数据长度，在不同的平台下，这些数据类型的长度可能不同。我不准备在这里讨论 C 标准的具体内容。\n把内核中的数据类型归为以下几类：\n 不透明类型：如进程标识符 pid_t，通常情况下直接使用即可，可以把这些类型视为黑盒。 指定长度的类型：如 flag 参数应当使用 unsigned long（这样能确保该变量在 32 位和 64 位情况下长度一样），可以理解为人为的约定。 长度明确的类型：如 s8 代表有符号 8 位整数，u16 代表 16 位无符号整数，等等。  特别地，对于 char 类型，默认是带符号的还是不带符号的，在不同环境下可能不同。如果需要指明，可以显示声明为 signed char 或 unsigned char。否则使用的时候应该多加小心。\n数据对齐 数据对齐通常指把数据放置到其字节长度可以整除的字节地址，即对于一个大小为 $2^{n}$ 字节的数据类型，它的地址最低有效位的后 $n$ 位应当为 $0$。\n现在的编译器会自动完成数据对齐的工作，对于普通程序员，小心使用指针强制类型转换后引起的对齐问题即可，比如：\n1 2 3  char wolf[] = \u0026#34;Like a wolf\u0026#34;; char *p = \u0026amp;wolf[1]; unsigned long l = *(unsigned long *)p;   这里 l 试图解引用一个非对齐的数据。\n对于复合数据类型，它们的对齐标准如下：\n 数组：按基本数据类型进行对齐，这样所有的元素都能对齐。 联合体：按包含的最长的数据类型进行对齐。 结构体：结构体中每个元素都正确对齐。  特别地，对于结构体，为了使每个元素都正确对齐，有时需要填补，比如：\n1 2 3 4 5 6  struct animal { char dog; /* 1字节 */ unsigned long cat; /* 4字节 */ unsigned short pig; /* 2字节 */ char fox; /* 1字节 */ };   该结构体被填补后相当于下面的结构体：\n1 2 3 4 5 6 7 8  struct animal { char dog; /* 1字节 */ u8 __pad0[3]; /* 3字节 */ unsigned long cat; /* 4字节 */ unsigned short pig; /* 2字节 */ char fox; /* 1字节 */ u8 __pad1; /* 1字节 */ };   字节顺序 字节顺序分高位优先（大端机，big-endian）和低位优先（小端机，little-endian）。\n高位优先即数据的低位到高位对应内存地址的高位到低位，低位优先即数据的低位到高位对应内存地址的低位到高位。\n以存储数据 0x1 为例，高位优先和低位优先的存储方式如下：\n1 2 3 4 5 6  二进制位：0 1 2 3 二进制值：0 0 0 1 内存地址：0 1 2 3 高位优先：0 0 0 1 低位优先：1 0 0 0   不同处理器的字节顺序可能不同，对于 x86 体系结构，使用的都是低位优先的字节顺序。\n其他体系结构相关的内容 还有很多内容和体系结构相关，包括时间、页、内存分布、系统调用、处理器排序等等，这些内容不再展开，其中部分内容会在后续的学习笔记涉及。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/develop/arch/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内核开发部分，简单介绍 Linux 内核体系结构和可移植性相关的内容。\u003c/p\u003e","title":"体系结构相关知识"},{"content":"根据 Arch Linux Wiki 整理 Arch Linux 的安装。\n安装前准备 参考 Installation guide。\n准备安装介质 从下载页面下载镜像，并从安装介质启动。\n目前我使用的镜像是 archlinux-2020.10.01-x86_64.iso。\n设置键盘布局 我采用默认布局（美式键盘）。\n验证引导模式 1  ls /sys/firmware/efi/efivars   如果该命令没有报错，说明系统是 UEFI 模式引导的，反之是传统方式引导的。\n我的系统是 UEFI 模式引导的。\n连接到网络 我用的是有线连接，使用 ip link 命令可以查看到对应的网卡在列表中，并且已经启用。\n测试 ping archlinux.org 成功。\n更新系统时钟 1  timedatectl set-ntp true   磁盘分区 使用 fdisk -l 查看现在的磁盘分区。\n我需要重新分区，使用 parted 命令，参考 Parted 完成分区：\n parted /dev/sda 进入 parted。 mklabel 设置 gpt 分区类型。 mkpart \u0026quot;EFI system partition\u0026quot; fat32 1MiB 301MiB 设置 EFI 分区。 set 1 esp on 设置 EFI 分区标志。 mkpart \u0026quot;root partition\u0026quot; ext4 301MiB 102701MiB 设置根分区。 mkpart \u0026quot;swap partition\u0026quot; linux-swap 102701MiB 110893MiB 设置交换分区。 mkpart \u0026quot;home partition\u0026quot; ext4 110893Mib 100% 设置 /home 分区。 print 确认分区无误，若发现问题，用 rm \u0026lt;分区号\u0026gt; 删除，再重新用 mkpart 分区。 quit 退出 parted  格式化分区 再次使用 fdisk -l 查看现在的磁盘分区。\n执行以下命令格式化分区：\n1 2 3 4  mkfs.vfat /dev/sda1 mkfs.ext4 /dev/sda2 mkswap /dev/sda3 mkfs.ext4 /dev/sda4   挂载文件系统 挂载根文件系统到 /mnt：\n1  mount /dev/sda2 /mnt   挂载 EFI 分区到 /mnt/boot/efi：\n1 2  mkdir -p /mnt/boot/efi mount /dev/sda1 /mnt/boot/efi   挂载 /home 分区到 /mnt/home：\n1 2  mkdir /mnt/home mount /dev/sda4 /mnt/home   启用交换分区：\n1  swapon /dev/sda3   安装系统 参考 Installation guide。\n选择镜像服务器 执行 vim /etc/pacman.d/mirrorlist 修改镜像列表。\n把中国的站点放到最前面，发现清华站点竟然就在第一个的位置，直接退出即可。\n安装必要的软件包 这里只安装了一些必要的软件包，其余软件包可以稍后安装。\n1  pacstrap /mnt base linux linux-firmware networkmanager vi vim man-db man-pages texinfo   配置系统 配置 fstab 文件 1  genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab   cat /mnt/etc/fstab 确认文件内容无误。\n进入 Chroot 环境 1  arch-chroot /mnt   配置时区 我需要设置上海时区：\n1 2  ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc   本地化配置 执行 vim /etc/locale.gen 把需要的 locales 前的注释去掉。\n我去掉了 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 前面的注释。\n执行 locale-gen 生成 locales。\n执行 vim /etc/locale.conf 创建并编辑文件内容为 LANG=en_US.UTF-8。\n注意，默认使用英文，以后我也只在图形界面使用中文，来避免乱码问题。\n网络配置 执行 vim /etc/hostname 创建并编辑文件内容为主机名，我使用的是 loongson。\n执行 vim /etc/hosts 添加相应内容，注意与主机名对应：\n1 2 3  127.0.0.1 localhost ::1 localhost 127.0.1.1 loongson.localdomain loongson   Initramfs 这步可以直接跳过。\n设置 root 密码 1  passwd   安装引导程序 我选择使用 GRUB，参考 GRUB。\n由于我的计算机使用的是 Intel CPU，所以要安装相应的固件 intel-ucode。\n1 2 3  pacman -S intel-ucode grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg   重启系统 确认上述所有步骤都完成后可以重启。\n1 2  exit reboot   若重启后无法进入系统，除非你能排查问题并修复，否则建议直接重来。\n安装开发环境 启用网络 启用网络并配置：\n1  systemctl start NetworkManager   设置开机启动：\n1  systemctl enable NetworkManager   安装常用软件包 1  pacman -S base-devel zsh gdb git   配置用户 添加用户 参考 Users and groups。\n创建新用户 loongson，配置其登录 shell 为 bash，以后再使用 zsh：\n1  useradd -m -s /bin/bash loongson   为 loongson 配置密码：\n1  passwd loongson   设置管理员权限 将 loongson 添加到 wheel 组：\n1  usermod -a -G wheel loongson   编辑相应的配置文件，删除 # %wheel ALL=(ALL) ALL 一行的注释：\n1  EDITOR=vim visudo   安装图形界面 安装显示驱动 我用的是 Intel 集成显卡：\n1  pacman -S xf86-video-intel mesa   安装显示服务器 我选择使用 Xorg，参考 Xorg。\n1  pacman -S xorg   安装桌面环境 我选择使用 KDE，参考 KDE。\n1  pacman -S plasma kde-applications   设置开机启动：\n1  systemctl enable sddm   重启系统进入图形界面：\n1  reboot   其他操作 下面是可选的其他操作，仅针对 KDE 桌面环境。\n缩放屏幕 我需要修改屏幕缩放到 125%，在 System Settings -\u0026gt; Hardware -\u0026gt; Display and Monitor -\u0026gt; Display Configuration 中设置。\n设置完后先不急着重启，等后续步骤完成再一起重启。\n安装中文字体 参考 Localization (简体中文)/Simplified Chinese (简体中文)。\n打开 Konsole，我选择安装文泉驿中文字体：\n1  pacman -S wqy-microhei wqy-bitmapfont wqy-zenhei   设置图形界面显示中文 修改 System Settings -\u0026gt; Personalization -\u0026gt; Regional Settings -\u0026gt; Language，添加简体中文到顶部（可能显示的是部分乱码，暂时不用管）。\n现在重启计算机，进入桌面后应该是中文环境，且没有乱码，之后可以完成的其他个性化配置。\n添加中国社区源 我选择使用清华源，在 /etc/pacman.conf 中添加以下内容：\n1 2  [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch   安装密钥：\n1  sudo pacman -S archlinuxcn-keyring   如果出现密钥无法部署的问题，可以参考 https://www.archlinuxcn.org/gnupg-2-1-and-the-pacman-keyring/，进行如下操作：\n1 2 3 4 5 6 7 8  pacman -Syu haveged systemctl start haveged systemctl enable haveged rm -fr /etc/pacman.d/gnupg pacman-key --init pacman-key --populate archlinux pacman-key --populate archlinuxcn   使用 AUR 我选择安装 yay：\n1  sudo pacman -S yay   安装中文输入法 我选择安装搜狗输入法，该输入法在 AUR 中。\n首先，安装 fcitx：\n1  sudo pacman -S fcitx kcm-fcitx   其次，安装搜狗输入法：\n1  yay -S fcitx-sogoupinyin   然后，新建 ~/.pam_environment 并添加以下内容：\n1 2 3  GTK_IM_MODULE DEFAULT=fcitx QT_IM_MODULE DEFAULT=fcitx XMODIFIERS DEFAULT=\\@im=fcitx   最后，注销后重新登录，确认 fcitx 正常启动，右键修改配置，之后重新启动 fcitx，搜狗输入法应该能正常使用。\n美化终端 安装 oh-my-zsh，见 使用 Zsh。\n配置开机动画 参考 Plymouth。\n安装 Plymouth：\n1  sudo pacman -S plymouth   修改 /etc/mkinitcpio.conf：\n1 2 3  MODULES=(i915 ...) ... HOOKS=(base udev plymouth ...)   修改 /etc/default/grub：\n1  GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet splash loglevel=3 rd.udev.log_priority=3 vt.global_cursor_default=0\u0026#34;   重新生成 GRUB 配置文件：\n1  sudo grub-mkconfig -o /boot/grub/grub.cfg   安装 Plymouth 主题：\n1 2  yay -S plymouth-theme-arch-glow sudo plymouth-set-default-theme -R arch-glow   设置平滑过渡：\n1 2  sudo systemctl disable sddm sudo systemctl enable sddm-plymouth   重启计算机查看开机动画。\n配置 GRUB 主题 安装 Vimix 主题。\n重启查看效果。\n","permalink":"https://freeflyingsheep.github.io/posts/linux/arch/","summary":"\u003cp\u003e根据 \u003ca href=\"https://wiki.archlinux.org/\"\u003eArch Linux Wiki\u003c/a\u003e 整理 Arch Linux 的安装。\u003c/p\u003e","title":"安装 Arch Linux"},{"content":"Linux 内核学习笔记系列，内核开发部分，简单介绍 Linux 内核编译步骤。\n内核源码树    目录 内容     arch 体系结构相关的代码，包括头文件、C 和汇编源文件   block 块设备 I/O 层   crypto 加密层   Documentation 内核源码文档   drivers 设备驱动程序   firmware 使用某些驱动程序而需要的设备固件   fs 文件系统   include 内核头文件   init 内核引导和初始化   ipc 进程间通信   kernel 内核核心组件   lib 内核通用库   mm 内存管理子系统   net 网络子系统   samples 示例，示范代码   scripts 编译内核所用的脚本   security Linux 安全模块   sound 语音子系统，即声卡驱动程序   tools Linux 开发实用工具   usr 早期用户空间的代码   virt 虚拟化基础结构    配置内核 Kconfig 内核采用了一种被称为 Kconfig 的配置语言，该配置语言可以解决以下问题：\n 各组件可以持久编译到内核中、可以编译为组件或直接忽略掉（在某些环境下，可能无法将某些组件编译为模块）。 在配置选项之间，可能存在相互依赖关系（某些选项只能与一个或多个其他选项连同使用）。 必须能够给出一个可用选项列表，供用户从中选择（有些情形，需要提示用户输入编号或类似的值）。 必须能够层次化地编排各种配置选项（在一一个树型结构中）。 配置选项可能依体系结构而不同。 配置语言不应该过于复杂，因为编写配置脚本并非大多数内核程序员喜欢做的事情。  Kconfig 的具体语法和实现不属于本系列学习笔记的范畴，我考虑以后专门开一个专题介绍内核构建系统。\n配置内核的工具 内核提供了各种不同的工具来简化内核配置。\n最简单的是字符界面下的命令行工具：\n1  make config   该工具会逐一遍历所有配置项，要求用户选择 yes、no 或是 module（如果是三选一的话）。由于这个过程往往要耗费掉很长时间，所以，不建议使用该工具配置内核。\n常用的工具是基于 ncurse 库编制的图形界面工具：\n1  make menuconfig   或者，使用基于 gtk+ 的图形工具：\n1  make gconfig   其他配置方式 除了使用上述三个工具，还可以直接使用内核的默认配置：\n1  make defconfig   不论使用哪种配置方式，最终内核配置文件会位于内核代码树根目录下的 .config 文件。\n也可以直接复制或修改配置文件 .config，这么做之后，应该更新配置文件：\n1  make oldconfig   编译内核 Kbuild 内核使用 GNU make 来编译源代码，这是一个复杂的 Makefile 系统，我们把该系统称为 Kbuild 系统。\n同样，Kbuild 的具体实现不属于本系列学习笔记的范畴，我考虑以后专门开一个专题介绍内核构建系统。\n编译内核的命令 1  make [-jn]   可选的 -jn 参数代表用 n 个作业来并行编译。\n安装内核 安装内核映像 把内核映像拷贝到 /boot 目录下，修改相应的引导配置。\n安装内核模块 1  make modules_install   内核编译实例 上面的内容都是在本机上配置编译安装内核的步骤，下面展示一个交叉编译内核并安装的实例。\n现在我们有一个 x86 体系结构的主机，要为一台龙芯（3A4000）的机器安装内核（假设主机上的“指定目录”为 ../dest，内核映像将位于 ../dest/boot，内核模块将位于 ../dest/lib）：\n 设置交叉编译工具链的环境变量。 使用默认配置来配置内核：make ARCH=mips loongson3_defconfig。 使用 8 个作业来并行编译内核：make ARCH=mips CROSS_COMPILE=mips64el-unknown-linux-gnu- -j8。 复制内核映像到指定目录：cp vmlinuz ../dest/boot。 复制内核配置到指定目录：cp .config ../dest/boot（可选）。 安装模块到指定目录：make ARCH=mips CROSS_COMPILE=mips64el-unknown-linux-gnu- INSTALL_MOD_PATH=../dest -j8 modules_install。 打包 ../dest 目录并解包到目标机器。 安装内核映像（假设内核映像文件名为 vmlinuz-4.x）：cp boot/vmlinuz-4.x /boot（可选地复制内核配置文件到 /boot）。 安装内核模块（假设内核模块目录名为 4.19.150+）：cp -r lib/modules/4.19.150+ /lib/modules。 修改相应的引导配置。  内核调试 下面仅列举几个常用的调试方式。\n通过打印来调试 最好理解，用 printk() 函数在相应地方打印信息。\n借助 GDB 和 KGDB 这部分内容可以参考内核在线文档 Debugging kernel and modules via gdb 和 Using kgdb, kdb and the kernel debugger internals。\n使用 Git 进行二分搜索 首先，告诉 Git 使用二分搜索：\n1  git bisect start   其次，告诉 Git 出现问题的最早版本（如果当前版本就是，这步可以略过）：\n1  git bisect bad \u0026lt;commit\u0026gt;   然后，告诉 Git 可正常运行的最新版本：\n1  git bisect good \u0026lt;commit\u0026gt;   或者，将上述三步合成一步，直接告诉 Git 起点和终点（注意，终点 end 是最近的提交，而起点 begin 是更久以前的提交）：\n1  git bisect start \u0026lt;end\u0026gt; \u0026lt;begin\u0026gt;   之后，Git 会自动进行二分搜索，切换到中间的某次提交。如果该提交一切正常，将它标记为“好的”：\n1  git bisect good   反之，将它标记为“坏的”：\n1  git bisect bad   之后，Git 会继续进行二分搜索，直接找到引入问题的那次提交。\n最后，退出二分搜索：\n1  git bisect reset   如果确定引发 bug 的源，那么可以指定 Git 仅在与错误相关的目录（path）进行二分搜索：\n1  git bisect start -- \u0026lt;path\u0026gt;   这种方法能定位引入 bug 的版本，但如果 bug 已经被修复，希望在上游代码中寻找修复该 bug 的提交，那只能手动二分搜索了。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/develop/build/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内核开发部分，简单介绍 Linux 内核编译步骤。\u003c/p\u003e","title":"内核编译和调试"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核散列表。\n内核散列表的使用 内核散列表的实现称为 hlist，头文件为 include/linux/list.h。它的操作和内核链表基本一致，只是把函数名中的 list（LIST）替换成了 hlist（HLIST）。\n内核散列表的使用可以参考内核链表的用法，下面直接介绍其具体实现。\n内核散列表的实现 内核散列表使用拉链法（链地址法）解决冲突，内核散列的实现是内核链表的修改版本，同样位于 include/linux/list.h。由于大部分实现和内核链表相似，代码本身也不复杂，这里只贴出部分代码，不再重复介绍。\n散列表结构体的实现 1 2 3 4 5 6 7  struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; };   散列表的表头和链表元素是不对称的，表头和链表只通过一个指针来关联。散列表不需要在常数时间内访问链表的末端。链表元素依然却是包含两个指针的，值得注意的是，指向前一个结点（此处的结点可能是表头，也可能是链表元素）的指针是一个二级指针。\n为什么要这么做？下面是我的个人理解。\n散列表通常是一个较大的数组，数组元素就是这里的 struct hlist_head。我们当然希望节省空间，所以表头只包含了一个指针（每个表头节省一个指针的空间，占用空间变为了原本的一半）。但这也就带来了新的问题，表头类型（struct hlist_head）和链表元素类型（struct hlist_node）不一样，链表元素没法像内核链表那样指向表头（内核链表的表头和链表元素类型都是 struct list_head）。不过表头和链表元素都包含一个指向后一个结点的指针，该指针是 struct hlist_node * 类型的。那我们不妨利用这个指针，把表头和链表元素统一起来，用 struct hlist_node **pprev 指向前一个结点的“指向后一个结点的指针”——对于表头，该指针是 struct hlist_node *first；对于链表元素，该指针是 struct hlist_node *next。\n初始化结点的实现 初始化表头的实现 1 2 3  #define HLIST_HEAD_INIT { .first = NULL } #define HLIST_HEAD(name) struct hlist_head name = { .first = NULL } #define INIT_HLIST_HEAD(ptr) ((ptr)-\u0026gt;first = NULL)   初始化链表元素的实现 1 2 3 4 5  static inline void INIT_HLIST_NODE(struct hlist_node *h) { h-\u0026gt;next = NULL; h-\u0026gt;pprev = NULL; }   相关判断的实现 1 2 3 4 5 6 7 8 9  static inline int hlist_unhashed(const struct hlist_node *h) { return !h-\u0026gt;pprev; } static inline int hlist_empty(const struct hlist_head *h) { return !h-\u0026gt;first; }   添加链表元素的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h) { struct hlist_node *first = h-\u0026gt;first; n-\u0026gt;next = first; if (first) first-\u0026gt;pprev = \u0026amp;n-\u0026gt;next; h-\u0026gt;first = n; n-\u0026gt;pprev = \u0026amp;h-\u0026gt;first; } /* next must be != NULL */ static inline void hlist_add_before(struct hlist_node *n, struct hlist_node *next) { n-\u0026gt;pprev = next-\u0026gt;pprev; n-\u0026gt;next = next; next-\u0026gt;pprev = \u0026amp;n-\u0026gt;next; *(n-\u0026gt;pprev) = n; } static inline void hlist_add_after(struct hlist_node *n, struct hlist_node *next) { next-\u0026gt;next = n-\u0026gt;next; n-\u0026gt;next = next; next-\u0026gt;pprev = \u0026amp;n-\u0026gt;next; if(next-\u0026gt;next) next-\u0026gt;next-\u0026gt;pprev = \u0026amp;next-\u0026gt;next; }   删除链表元素的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static inline void __hlist_del(struct hlist_node *n) { struct hlist_node *next = n-\u0026gt;next; struct hlist_node **pprev = n-\u0026gt;pprev; *pprev = next; if (next) next-\u0026gt;pprev = pprev; } static inline void hlist_del(struct hlist_node *n) { __hlist_del(n); n-\u0026gt;next = LIST_POISON1; n-\u0026gt;pprev = LIST_POISON2; } static inline void hlist_del_init(struct hlist_node *n) { if (!hlist_unhashed(n)) { __hlist_del(n); INIT_HLIST_NODE(n); } }   移动链表元素的实现 1 2 3 4 5 6 7 8 9 10 11 12  /* * Move a list from one list head to another. Fixup the pprev * reference of the first entry if it exists. */ static inline void hlist_move_list(struct hlist_head *old, struct hlist_head *new) { new-\u0026gt;first = old-\u0026gt;first; if (new-\u0026gt;first) new-\u0026gt;first-\u0026gt;pprev = \u0026amp;new-\u0026gt;first; old-\u0026gt;first = NULL; }   获取包含链表元素的数据结构 1  #define hlist_entry(ptr, type, member) container_of(ptr,type,member)   遍历链表元素的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #define hlist_for_each(pos, head) \\ for (pos = (head)-\u0026gt;first; pos \u0026amp;\u0026amp; ({ prefetch(pos-\u0026gt;next); 1; }); \\ pos = pos-\u0026gt;next)  #define hlist_for_each_safe(pos, n, head) \\ for (pos = (head)-\u0026gt;first; pos \u0026amp;\u0026amp; ({ n = pos-\u0026gt;next; 1; }); \\ pos = n)  /** * hlist_for_each_entry - iterate over list of given type * @tpos: the type * to use as a loop cursor. * @pos: the \u0026amp;struct hlist_node to use as a loop cursor. * @head: the head for your list. * @member: the name of the hlist_node within the struct. */ #define hlist_for_each_entry(tpos, pos, head, member) \\ for (pos = (head)-\u0026gt;first; \\ pos \u0026amp;\u0026amp; ({ prefetch(pos-\u0026gt;next); 1;}) \u0026amp; \\ ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \\ pos = pos-\u0026gt;next)  /** * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry * @tpos: the type * to use as a loop cursor. * @pos: the \u0026amp;struct hlist_node to use as a loop cursor. * @n: another \u0026amp;struct hlist_node to use as temporary storage * @head: the head for your list. * @member: the name of the hlist_node within the struct. */ #define hlist_for_each_entry_safe(tpos, pos, n, head, member) \\ for (pos = (head)-\u0026gt;first; \\ pos \u0026amp;\u0026amp; ({ n = pos-\u0026gt;next; 1; }) \u0026amp;\u0026amp; \\ ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \\ pos = n)   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/hlist/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核散列表。\u003c/p\u003e","title":"内核散列表"},{"content":"根据 Linux Kernel 在线文档 Dynamic debug 整理。\n简介 动态调试（dyndbg）的主要功能是允许我们动态地打开或关闭内核代码的各种提示信息，如启用 pr_debug() 和 dev_debug() 之类的函数。\n注意，打开动态调试功能需要配置内核 Kernel hacking -\u0026gt; printk and dmesg options -\u0026gt; Enable dynamic printk() support。\n控制调试行为 通过往 debugfs 文件系统上的一个控制文件写入数据，来控制 pr_debug() 和 dev_debug() 的行为。\n首先，必须挂载 debugfs 文件系统（如果没自动挂载的话）：\n1  mount -t debugfs none /sys/kernel/debug   此时，控制文件位于 \u0026lt;debugfs\u0026gt;/dynamic_debug/control。\n例如，启用文件 svcsock.c 第 1603 行的调试内容：\n1  echo \u0026#39;file svcsock.c line 1603 +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control   如果语法错误，那么写入操作将会失败：\n1 2  $ echo \u0026#39;file svcsock.c wtf 1 +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control -bash: echo: write error: Invalid argument   查看调试行为 直接访问 \u0026lt;debugfs\u0026gt;/dynamic_debug/control 文件即可。比如：\n1 2 3 4 5 6 7  $ cat \u0026lt;debugfs\u0026gt;/dynamic_debug/control # filename:lineno [module]function flags format net/sunrpc/svc_rdma.c:323 [svcxprt_rdma]svc_rdma_cleanup =_ \u0026#34;SVCRDMA Module Removed, deregister RPC RDMA transport\\012\u0026#34; net/sunrpc/svc_rdma.c:341 [svcxprt_rdma]svc_rdma_init =_ \u0026#34;\\011max_inline : %d\\012\u0026#34; net/sunrpc/svc_rdma.c:340 [svcxprt_rdma]svc_rdma_init =_ \u0026#34;\\011sq_depth : %d\\012\u0026#34; net/sunrpc/svc_rdma.c:338 [svcxprt_rdma]svc_rdma_init =_ \u0026#34;\\011max_requests : %d\\012\u0026#34; ...   命令语言语法 空白符 多个空白符（空格和制表符）和单个空白符是等价的。\n举个例子，下面三行命令语言是等价的：\n1 2 3  echo -n \u0026#39;file svcsock.c line 1603 +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control echo -n \u0026#39; file svcsock.c line 1603 +p \u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control echo -n \u0026#39;file svcsock.c line 1603 +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control   通配符 可以使用通配符来匹配多个内容。\n举个例子，匹配所有的 usb 驱动：\n1  echo \u0026#34;file drivers/usb/* +p\u0026#34; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control   关键词 1 2 3 4 5 6 7 8 9 10 11 12 13 14  command ::= match-spec* flags-spec match-spec ::= \u0026#39;func\u0026#39; string | \u0026#39;file\u0026#39; string | \u0026#39;module\u0026#39; string | \u0026#39;format\u0026#39; string | \u0026#39;line\u0026#39; line-range line-range ::= lineno | \u0026#39;-\u0026#39;lineno | lineno\u0026#39;-\u0026#39; | lineno\u0026#39;-\u0026#39;lineno lineno ::= unsigned-int   注意，line-range 不能包含空格，比如 1-30 是合法的，而 1 - 30 是非法的。\nfunc 将字符串与函数名称比较。\n1 2  func svc_tcp_accept func *recv* # in rfcomm, bluetooth, ping, tcp   file 将字符串与相对路径名或源文件名比较。\n1 2 3 4 5  file svcsock.c file kernel/freezer.c # ie column 1 of control file file drivers/usb/* # all callsites under it file inode.c:start_* # parse :tail as a func (above) file inode.c:1-100 # parse :tail as a line-range (above)   module 将字符串与模块名进行比较。模块名是用 lsmod 查看到的模块名称，去掉 .ko 后缀，且如果名称包含连字符 -，转换成下划线 _。\n1 2 3  module sunrpc module nfsd module drm* # both drm, drm_kms_helper   format 将字符串与动态调试用到的格式化字符串比较。字符串不是完整匹配，只需要部分匹配。特殊字符可以用 C 语言的转义字符来表示，如 \\040 代表空格符。或者，也可以用单引号或双引号包裹字符串。\n1 2 3 4 5  format svcrdma: // many of the NFS/RDMA server pr_debugs format readahead // some pr_debugs in the readahead cache format nfsd:\\040SETATTR // one way to match a format with whitespace format \u0026#34;nfsd: SETATTR\u0026#34; // a neater way to match a format with whitespace format \u0026#39;nfsd: SETATTR\u0026#39; // yet another way to match a format with whitespace   line 将行数与动态调试函数的行号比较。\nline 1603 // exactly line 1603 line 1600-1605 // the six lines from line 1600 to line 1605 line -1605 // the 1605 lines from line 1 to line 1605 line 1600- // all lines from line 1600 to the end of the file\nflags-spec flags-spec 由一个更改操作符（change operation）和标志（flag characters）构成。\n   更改操作符 用途     - 移除标志   + 添加标志   = 设置标志    | 标志 | 用途 | | p | 启用动态调试函数 | | f | 在输出信息中包含函数名称 | | l | 在输出信息中包含行号 | | m | 在输出信息中包含模块名 | | t | 在输出信息中包含线程号（不是中断上下文产生的线程号） | | _ | 不设置标志 |\n对于 print_hex_dump_debug() 和 print_hex_dump_bytes(), 只有 p 起作用，其他标志将被忽略。\n显示标志的时候，标志前面会带有 =（代表当前标志等于什么）。\n要一次性清楚所有标志，使用 =_ 或 -flmpt。\n引导过程中的调试信息 要在引导过程中（甚至在用户空间和 debugfs 存在）为核心代码和内置模块激活调试消息，使用 dyndbg=\u0026quot;QUERY\u0026quot;、module.dyndbg=\u0026quot;QUERY\u0026quot;。 QUERY 遵循命令语言语法，但不得超过 1023 个字符，引导程序可能会施加额外的限制。\n这些参数是在 early_initcall 中 ddebug 表处理完之后进行处理的。因此，此引导参数可以启用在 early_initcall 之后运行的所有代码中的调试消息。\n如果 foo 模块不是内置的，则 foo.dyndbg 仍将在引导时进行处理，但没有任何效果，但是在以后加载模块时将对其进行重新处理。而 dyndbg= 只在引导时被处理。\n模块初始化时的调试信息 有三种方式能在模块初始化时设置动态调试。\n配置 /etc/modprobe.d/*.conf 1 2  options foo dyndbg=+pt options foo dyndbg # defaults to +p   设置引导参数 1  foo.dyndbg=\u0026#34; func bar +p; func buz +mp\u0026#34;   设置 modprobe 参数 1  modprobe foo dyndbg==pmf # override previous settings   实例 命令语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // enable the message at line 1603 of file svcsock.c echo -n \u0026#39;file svcsock.c line 1603 +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // enable all the messages in file svcsock.c echo -n \u0026#39;file svcsock.c +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // enable all the messages in the NFS server module echo -n \u0026#39;module nfsd +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // enable all 12 messages in the function svc_process() echo -n \u0026#39;func svc_process +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // disable all 12 messages in the function svc_process() echo -n \u0026#39;func svc_process -p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // enable messages for NFS calls READ, READLINK, READDIR and READDIR+. echo -n \u0026#39;format \u0026#34;nfsd: READ\u0026#34; +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // enable messages in files of which the paths include string \u0026#34;usb\u0026#34; echo -n \u0026#39;*usb* +p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // enable all messages echo -n \u0026#39;+p\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control // add module, function to all enabled messages echo -n \u0026#39;+mf\u0026#39; \u0026gt; \u0026lt;debugfs\u0026gt;/dynamic_debug/control   引导参数 1 2 3 4 5 6 7 8  // boot-args example, with newlines and comments for readability Kernel command line: ... // see whats going on in dyndbg=value processing dynamic_debug.verbose=1 // enable pr_debugs in 2 builtins, #cmt is stripped dyndbg=\u0026#34;module params +p #cmt ; module sys +p\u0026#34; // enable pr_debugs in 2 functions in a module loaded later pc87360.dyndbg=\u0026#34;func pc87360_init_device +p; func pc87360_find +p\u0026#34;   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/miscellaneous/dynamic-debug/","summary":"\u003cp\u003e根据 Linux Kernel 在线文档 \u003ca href=\"https://www.kernel.org/doc/html/latest/admin-guide/dynamic-debug-howto.html\"\u003eDynamic debug\u003c/a\u003e 整理。\u003c/p\u003e","title":"动态调试"},{"content":"Linux 内核学习笔记系列，内核简介部分，简单介绍 Linux 内核常见的函数及其作用。\n内核函数库 显然，在编写内核时，不能使用 C 标准库。内核实现了自己的函数库，位于名为 lib 的目录下（对于 x86 平台，内核函数库包括 lib 和 arch/x86/lib 目录）。\n内核函数库和 C 标准库中不少函数的功能是一致的。\n常见函数/宏 比较大小 include/linux/kernel.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /* * min()/max()/clamp() macros that also do * strict type-checking.. See the * \u0026#34;unnecessary\u0026#34; pointer comparison. */ #define min(x, y) ({ \\ typeof(x) _min1 = (x); \\ typeof(y) _min2 = (y); \\ (void) (\u0026amp;_min1 == \u0026amp;_min2); \\ _min1 \u0026lt; _min2 ? _min1 : _min2; })  #define max(x, y) ({ \\ typeof(x) _max1 = (x); \\ typeof(y) _max2 = (y); \\ (void) (\u0026amp;_max1 == \u0026amp;_max2); \\ _max1 \u0026gt; _max2 ? _max1 : _max2; })  /* * ..and if you can\u0026#39;t take the strict * types, you can specify one yourself. * * Or not use min/max/clamp at all, of course. */ #define min_t(type, x, y) ({ \\ type __min1 = (x); \\ type __min2 = (y); \\ __min1 \u0026lt; __min2 ? __min1: __min2; })  #define max_t(type, x, y) ({ \\ type __max1 = (x); \\ type __max2 = (y); \\ __max1 \u0026gt; __max2 ? __max1: __max2; })   取整 include/linux/kernel.h：\n1 2 3 4 5 6 7 8 9 10 11 12  /* * This looks more complex than it should be. But we need to * get the type for the ~ right in round_down (it needs to be * as wide as the result!), and we want to evaluate the macro * arguments just once each. */ #define __round_mask(x, y) ((__typeof__(x))((y)-1)) #define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1) #define round_down(x, y) ((x) \u0026amp; ~__round_mask(x, y))  #define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d)) #define roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))   内存分配 1 2  void *kmalloc(size_t size, gfp_t flags); void kfree(const void *)   这两个函数类似于标准库函数 malloc() 和 free()，其中 flags 表示分配标志，在 Linux 内存管理 (基础部分)中介绍。\n输出信息 1  int printk(const char *fmt, ...);   该函数类似于标准库函数的 printf()，但使用时可以在字符串前面加上日志级别，如 printk(KERN_ERR \u0026quot;bad value %d\\n\u0026quot;, value);。如果不指定日志级别，默认是 KERN_WARNING，但可能受其他因素影响，最好手动指定。\n日志级别定义于 include/linux/kernel.h：\n1 2 3 4 5 6 7 8  #define KERN_EMERG \u0026#34;\u0026lt;0\u0026gt;\u0026#34; /* system is unusable */#define KERN_ALERT \u0026#34;\u0026lt;1\u0026gt;\u0026#34; /* action must be taken immediately */#define KERN_CRIT \u0026#34;\u0026lt;2\u0026gt;\u0026#34; /* critical conditions */#define KERN_ERR \u0026#34;\u0026lt;3\u0026gt;\u0026#34; /* error conditions */#define KERN_WARNING \u0026#34;\u0026lt;4\u0026gt;\u0026#34; /* warning conditions */#define KERN_NOTICE \u0026#34;\u0026lt;5\u0026gt;\u0026#34; /* normal but significant condition */#define KERN_INFO \u0026#34;\u0026lt;6\u0026gt;\u0026#34; /* informational */#define KERN_DEBUG \u0026#34;\u0026lt;7\u0026gt;\u0026#34; /* debug-level messages */  缓存对齐 include/linux/cache.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #ifndef ____cacheline_aligned #define ____cacheline_aligned __attribute__((__aligned__(SMP_CACHE_BYTES))) #endif  #ifndef ____cacheline_aligned_in_smp #ifdef CONFIG_SMP #define ____cacheline_aligned_in_smp ____cacheline_aligned #else #define ____cacheline_aligned_in_smp #endif /* CONFIG_SMP */#endif  #ifndef __cacheline_aligned #define __cacheline_aligned \\ __attribute__((__aligned__(SMP_CACHE_BYTES), \\ __section__(\u0026#34;.data.cacheline_aligned\u0026#34;))) #endif /* __cacheline_aligned */ #ifndef __cacheline_aligned_in_smp #ifdef CONFIG_SMP #define __cacheline_aligned_in_smp __cacheline_aligned #else #define __cacheline_aligned_in_smp #endif /* CONFIG_SMP */#endif  /* * The maximum alignment needed for some critical structures * These could be inter-node cacheline sizes/L3 cacheline * size etc. Define this in asm/cache.h for your arch */ #ifndef INTERNODE_CACHE_SHIFT #define INTERNODE_CACHE_SHIFT L1_CACHE_SHIFT #endif  #if !defined(____cacheline_internodealigned_in_smp) #if defined(CONFIG_SMP) #define ____cacheline_internodealigned_in_smp \\ __attribute__((__aligned__(1 \u0026lt;\u0026lt; (INTERNODE_CACHE_SHIFT)))) #else #define ____cacheline_internodealigned_in_smp #endif #endif   正如这些宏的字面意思，可以简单理解为按高速缓存行对齐。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/introduction/common/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内核简介部分，简单介绍 Linux 内核常见的函数及其作用。\u003c/p\u003e","title":"Linux 内核常见函数/宏"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核队列。\n内核队列的使用 内核通用队列的实现称为 kfifo，头文件为 include/linux/kfifo.h。\n创建队列 创建并初始化一个大小为 size 的 kfifo，使用 gfp_mask 分配内存（成功则返回 0，反之返回一个负数错误码）：\n1  int kfifo_alloc(struct kfifo *fifo, unsigned int size, gfp_t gfp_mask);   创建并初始化一个 kfifo 对象，使用 buffer 指向的 size 大小的内存：\n1  void kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size);   静态声明 kfifo（不常用）：\n1 2  DECLARE_KFIFO(name, size); INIT_KFIFO(name);   以上所有的 size 必须为 2 的幂。\n插入队列数据 1  unsigned int kfifo_in(struct kfifo *fifo, const void *from, unsigned int len);   该函数把 from 指针所指的 len 字节数据拷贝到 fifo 所指的队列中。如果成功，返回推入数据的字节大小。如果队列中的空闲字节小于 len，返回值可能小于 len，甚至会返回 0，这时意味着没有任何数据被推入。\n摘取队列数据 1  unsigned int kfifo_out(struct kfifo *fifo, void *to, unsigned int len);   该函数从 fifo 所指向的队列中拷贝出长度为 len 字节的数据到 to 所指的缓冲中。如果成功，返回拷贝的数据长度。如果队列中数据大小小于 len，则该函数拷贝出的数据必然小于需要的数据大小。\n当数据被摘取后，数据就不再存在于队列之中。这是队列操作的常用方式。不过如果仅仅想“偷窥”队列中的数据，而不真想删除它，可以使用下面的方法:\n1  unsigned int kfifo_out_peek(struct kfifo *fifo, void *to, unsigned int len, unsigned offset);   该函数和 kffo_out() 类似，但出口偏移不增加，而且摘取的数据仍然可被下次 kfifo_out() 获得。参数 offset 指向队列中的索引位置，如果该参数为 0，则读队列头。\n获取队列长度 获得用于存储 kfifo 队列的空间的总体大小：\n1  unsigned int kfifo_size(struct kfifo *fifo);   获得 kfifo 队列中已推入的数据大小：\n1  unsigned int kfifo_len(struct kfifo *fifo);   获得 kfifo 队列中还有多少可用空间：\n1  unsigned int kfifo_avail(struct kfifo *fifo);   以上所有函数的返回值以字节为单位。\n判断给定的 kfifo 是否为空的，若是则返回非 0 值，反之返回 0：\n1  int kfifo_is_empty(struct kfifo *fifo);   判断给定的 kfifo 是否为空的，若是则返回非 0 值，反之返回 0：\n1  int kfifo_is_full(struct kfifo *fifo);   重置队列 1  void kfifo_reset(struct kfifo *fifo);   撤销队列 若通过 kfifo_alloc() 创建的队列，用下面的函数撤销：\n1  void kfifo_free(struct kfifo *fifo);   若通过 kfifo_init() 创建的队列，需要手动释放相应的内存。\n队列使用实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  struct kfifo fifo; int ret; unsigned int i; unsigned int val; // 创建一个大小为 PAGE_SIZE 的队列 fifo ret = kfifo_alloc(\u0026amp;kifo, PAGE_SIZE, GFP_KERNEL); if (ret) return ret; // 将 [0,32) 压入到名为 fifo 的 kfifo 中 for(i = 0; i \u0026lt; 32; i++) kfifo_in(fifo, \u0026amp;i, sizeof(i)); // 查看队列的第一个元素 ret = kfifo_out_peek(fifo, \u0026amp;val, sizeof(val), 0); if (ret != sizeof(val)) return -EINVAL; printk(KERN_INFO \u0026#34;%u\\n\u0026#34;, val); // 应该输出 0  // 摘取并打印 kfifo 中的所有元素 while (kfifo_avail(fifo)) { ret = kfifo_out(fifo, \u0026amp;val, sizeof(val)); if (ret != sizeof(val)) return -EINVAL; printk(KERN_INFO \u0026#34;%u\\n\u0026#34;, val); // 应该按序输出 0 到 31 }   内核队列的实现 内核队列的实现均位于 kernel/kfifo.c 和 include/linux/kfifo.h，下面列出常用函数/宏的实现。\n队列结构体的实现 1 2 3 4 5 6  struct kfifo { unsigned char *buffer; /* the buffer holding the data */ unsigned int size; /* the size of the allocated buffer */ unsigned int in; /* data is added at offset (in % size) */ unsigned int out; /* data is extracted from off. (out % size) */ };   显然，内核队列是一个循环队列。下面我们把 in 称为队尾指针，out 称为队头指针，buffer 视为缓冲区数组。\n传统的队列存储的数据类型往往是已知的，入队、出队一个元素对应缓冲区数组下标加减 1。而为了通用性，内核队列把缓冲区数组声明为 char 类型，对应的入队、出队需要通过元素的大小来计算下标的值（如 int 类型的一个元素入队、出队对应缓冲区数组下标加减 4）。\n既然是循环队列，就存在区分队满和队空的情况，传统的解决方法就几种：一是记录队列的元素个数或记录队列的总大小；二是牺牲一个存储单元来用作判断；三是通过一个额外的标志来判断队满或队空。此处采用了第一种方法，用 size 记录了缓冲区数组的大小。\n帮助函数/宏的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  /* helper macro */ #define __kfifo_initializer(s, b) \\ (struct kfifo) { \\ .size = s, \\ .in = 0, \\ .out = 0, \\ .buffer = b \\ }  /* * __kfifo_add_out internal helper function for updating the out offset */ static inline void __kfifo_add_out(struct kfifo *fifo, unsigned int off) { smp_mb(); fifo-\u0026gt;out += off; } /* * __kfifo_add_in internal helper function for updating the in offset */ static inline void __kfifo_add_in(struct kfifo *fifo, unsigned int off) { smp_wmb(); fifo-\u0026gt;in += off; } /* * __kfifo_off internal helper function for calculating the index of a * given offeset */ static inline unsigned int __kfifo_off(struct kfifo *fifo, unsigned int off) { return off \u0026amp; (fifo-\u0026gt;size - 1); } static inline void __kfifo_in_data(struct kfifo *fifo, const void *from, unsigned int len, unsigned int off) { unsigned int l; /* * Ensure that we sample the fifo-\u0026gt;out index -before- we * start putting bytes into the kfifo. */ smp_mb(); off = __kfifo_off(fifo, fifo-\u0026gt;in + off); /* first put the data starting from fifo-\u0026gt;in to buffer end */ l = min(len, fifo-\u0026gt;size - off); memcpy(fifo-\u0026gt;buffer + off, from, l); /* then put the rest (if any) at the beginning of the buffer */ memcpy(fifo-\u0026gt;buffer, from + l, len - l); } static inline void __kfifo_out_data(struct kfifo *fifo, void *to, unsigned int len, unsigned int off) { unsigned int l; /* * Ensure that we sample the fifo-\u0026gt;in index -before- we * start removing bytes from the kfifo. */ smp_rmb(); off = __kfifo_off(fifo, fifo-\u0026gt;out + off); /* first get the data from fifo-\u0026gt;out until the end of the buffer */ l = min(len, fifo-\u0026gt;size - off); memcpy(to, fifo-\u0026gt;buffer + off, l); /* then get the rest (if any) from the beginning of the buffer */ memcpy(to + l, fifo-\u0026gt;buffer, len - l); }    __kfifo_initializer()：静态初始化队列。 __kfifo_add_out()：增加队头指针。 __kfifo_add_in()：增加队尾指针。 __kfifo_off()：计算 in % size 或 out % size。 __kfifo_in_data()：从 from 拷贝 len 大小的数据到队列头部偏移 off 的位置。 __kfifo_out_data()：从队列头部偏移 off 的位置拷贝 len 大小的数据到 to。  这里先忽略 smp_ 开头的函数，它们是内存屏障，我把内核队列作为介绍内存屏障的例子，见 TODO。\n对于 __kfifo_off() 中的计算，其实是用了这么一个结论：如果 m 是 2 的幂，那么 n % m 等价于 n \u0026amp; (m - 1)。这个结论其实不难理解，我们来看一个简单的例子。假设所有的数占用 8 位，取 m 为 4，那么 m 的二进制为 0000 0100，m - 1 的二进制为 0000 0011 。取 n 为 3，即 n 的二进制为 0000 0011，那么 n \u0026amp; (m - 1) 的结果为 0000 0011。取 n 为 5，即 n 的二进制为 0000 0101，那么 n \u0026amp; (m - 1) 的结果为 0000 0001。不难发现 n \u0026amp; (m - 1) 的意义是把 n 的高位清零且低位不变，这和 n % m 是等价的（具体的数学证明显然不属于本学习笔记的范畴）。通过使用与运算来代替模运算，可以有效缩短运算时间。\n__kfifo_in_data() 和 __kfifo_out_data() 相对复杂一些。因为是循环队列，所以更要注意要缓冲区数组边界的判断。对于 __kfifo_in_data()，先是拷贝数据到队尾指针偏移处，若拷贝至数组尾部仍然不够，再拷贝剩下的内容到数组头部。对于 __kfifo_out_data()，先是从队头指针偏移处拷贝数据，若拷贝至数组尾部仍然不够，再从数组头部拷贝剩下的内容。此处的实现考虑了的偏移 off 和数据大小 len，而对应常规的入队、出队单个元素的操作，偏移 off 总为 0，且 len 总为单个元素的大小，这点可以从下面的插入队列数据的实现和摘取队列数据的实现中看到。\n获取队列长度的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  /** * kfifo_size - returns the size of the fifo in bytes * @fifo: the fifo to be used. */ static inline __must_check unsigned int kfifo_size(struct kfifo *fifo) { return fifo-\u0026gt;size; } /** * kfifo_len - returns the number of used bytes in the FIFO * @fifo: the fifo to be used. */ static inline unsigned int kfifo_len(struct kfifo *fifo) { register unsigned int out; out = fifo-\u0026gt;out; smp_rmb(); return fifo-\u0026gt;in - out; } /** * kfifo_is_empty - returns true if the fifo is empty * @fifo: the fifo to be used. */ static inline __must_check int kfifo_is_empty(struct kfifo *fifo) { return fifo-\u0026gt;in == fifo-\u0026gt;out; } /** * kfifo_is_full - returns true if the fifo is full * @fifo: the fifo to be used. */ static inline __must_check int kfifo_is_full(struct kfifo *fifo) { return kfifo_len(fifo) == kfifo_size(fifo); } /** * kfifo_avail - returns the number of bytes available in the FIFO * @fifo: the fifo to be used. */ static inline __must_check unsigned int kfifo_avail(struct kfifo *fifo) { return kfifo_size(fifo) - kfifo_len(fifo); }   重置队列的实现 1 2 3 4 5 6 7 8  /** * kfifo_reset - removes the entire FIFO contents * @fifo: the fifo to be emptied. */ static inline void kfifo_reset(struct kfifo *fifo) { fifo-\u0026gt;in = fifo-\u0026gt;out = 0; }   创建队列的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  /** * INIT_KFIFO - Initialize a kfifo declared by DECLARE_KFIFO * @name: name of the declared kfifo datatype */ #define INIT_KFIFO(name) \\ name = __kfifo_initializer(sizeof(name##kfifo_buffer) - \\ sizeof(struct kfifo), \\ name##kfifo_buffer + sizeof(struct kfifo))  /** * DEFINE_KFIFO - macro to define and initialize a kfifo * @name: name of the declared kfifo datatype * @size: size of the fifo buffer. Must be a power of two. * * Note1: the macro can be used for global and local kfifo data type variables * Note2: the macro creates two objects: * A kfifo object with the given name and a buffer for the kfifo * object named name##kfifo_buffer */ #define DEFINE_KFIFO(name, size) \\ unsigned char name##kfifo_buffer[size]; \\ struct kfifo name = __kfifo_initializer(size, name##kfifo_buffer)  static void _kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size) { fifo-\u0026gt;buffer = buffer; fifo-\u0026gt;size = size; kfifo_reset(fifo); } /** * kfifo_init - initialize a FIFO using a preallocated buffer * @fifo: the fifo to assign the buffer * @buffer: the preallocated buffer to be used. * @size: the size of the internal buffer, this has to be a power of 2. * */ void kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size) { /* size must be a power of 2 */ BUG_ON(!is_power_of_2(size)); _kfifo_init(fifo, buffer, size); } EXPORT_SYMBOL(kfifo_init); /** * kfifo_alloc - allocates a new FIFO internal buffer * @fifo: the fifo to assign then new buffer * @size: the size of the buffer to be allocated, this have to be a power of 2. * @gfp_mask: get_free_pages mask, passed to kmalloc() * * This function dynamically allocates a new fifo internal buffer * * The size will be rounded-up to a power of 2. * The buffer will be release with kfifo_free(). * Return 0 if no error, otherwise the an error code */ int kfifo_alloc(struct kfifo *fifo, unsigned int size, gfp_t gfp_mask) { unsigned char *buffer; /* * round up to the next power of 2, since our \u0026#39;let the indices * wrap\u0026#39; technique works only in this case. */ if (!is_power_of_2(size)) { BUG_ON(size \u0026gt; 0x80000000); size = roundup_pow_of_two(size); } buffer = kmalloc(size, gfp_mask); if (!buffer) { _kfifo_init(fifo, NULL, 0); return -ENOMEM; } _kfifo_init(fifo, buffer, size); return 0; } EXPORT_SYMBOL(kfifo_alloc);   插入队列数据的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /** * kfifo_in - puts some data into the FIFO * @fifo: the fifo to be used. * @from: the data to be added. * @len: the length of the data to be added. * * This function copies at most @len bytes from the @from buffer into * the FIFO depending on the free space, and returns the number of * bytes copied. * * Note that with only one concurrent reader and one concurrent * writer, you don\u0026#39;t need extra locking to use these functions. */ unsigned int kfifo_in(struct kfifo *fifo, const void *from, unsigned int len) { len = min(kfifo_avail(fifo), len); __kfifo_in_data(fifo, from, len, 0); __kfifo_add_in(fifo, len); return len; } EXPORT_SYMBOL(kfifo_in);   摘取队列数据的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /** * kfifo_out - gets some data from the FIFO * @fifo: the fifo to be used. * @to: where the data must be copied. * @len: the size of the destination buffer. * * This function copies at most @len bytes from the FIFO into the * @to buffer and returns the number of copied bytes. * * Note that with only one concurrent reader and one concurrent * writer, you don\u0026#39;t need extra locking to use these functions. */ unsigned int kfifo_out(struct kfifo *fifo, void *to, unsigned int len) { len = min(kfifo_len(fifo), len); __kfifo_out_data(fifo, to, len, 0); __kfifo_add_out(fifo, len); return len; } EXPORT_SYMBOL(kfifo_out); /** * kfifo_out_peek - copy some data from the FIFO, but do not remove it * @fifo: the fifo to be used. * @to: where the data must be copied. * @len: the size of the destination buffer. * @offset: offset into the fifo * * This function copies at most @len bytes at @offset from the FIFO * into the @to buffer and returns the number of copied bytes. * The data is not removed from the FIFO. */ unsigned int kfifo_out_peek(struct kfifo *fifo, void *to, unsigned int len, unsigned offset) { len = min(kfifo_len(fifo), len + offset); __kfifo_out_data(fifo, to, len, offset); return len; } EXPORT_SYMBOL(kfifo_out_peek);   撤销队列的实现 1 2 3 4 5 6 7 8 9 10  /** * kfifo_free - frees the FIFO internal buffer * @fifo: the fifo to be freed. */ void kfifo_free(struct kfifo *fifo) { kfree(fifo-\u0026gt;buffer); _kfifo_init(fifo, NULL, 0); } EXPORT_SYMBOL(kfifo_free);   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/kfifo/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核队列。\u003c/p\u003e","title":"内核队列"},{"content":"根据 GCC CPP 在线文档的 Predefined Macros 章节整理。\n简介 GCC 的预处理器 CPP 预定了很多宏，这些宏被称为“预定义宏”（Predefined Macros）。\n对于 C 语言，预定义宏包含三类：标准的（standard）、通用的（common）和特定于系统的（system-specific）。\n对于 C++ 语言，除了上述三类，还多了一类：命名运算符（named operators）。\n标准的预定义宏 标准的预定义宏由相关的语言标准指定，因此实现这些标准的所有编译器都可以使用它们（较早的编译器可能无法提供所有的宏），它们的名字都以双下划线开头。\n下面列出几个常用的宏：\n   宏 含义     __FILE__ 该宏以 C 字符串常量的形式扩展为当前输入文件的名称（如 \u0026quot;/usr/local/include/myheader.h\u0026quot;）   __LINE__ 该宏以十进制整数常量的形式扩展为当前输入行号。   __cplusplus 当使用 C++ 编译器时，该宏被定义为 1   __ASSEMBLER__ 当预处理汇编语言时，该宏被定义为 1    通用的预定义宏 通用的预定义宏是 GNU C 扩展，在 GNU C 和 GNU Fortran 的系统上含义相同，它们的名字都以双下划线开头。\n其中，__GNUC__、__GNUC_MINOR__ 和 __GNUC_PATCHLEVEL__ 被所有使用 C 预处理程序的 GNU 编译器（C，C++，Objective-C 和 Fortran）定义。它们的值分别是编译器的主要版本、次要版本和补丁级别，是整数常量。比如，GCC 版本 x.y.z 定义了 __GNUC__ 为 x，__GNUC_MINOR__ 为 y，__GNUC_PATCHLEVEL__ 为 z。\n特定于系统的预定义宏 C 预处理器通常会预定义一些宏来表示系统和机器类型，显然这些宏在不同目标机器上是不同的。不建议使用特定于系统的预定义宏，最好使用 autoconf 之类的工具检查所需的功能。\n命名运算符 在 C++ 中，有 11 个关键字，它们是常用标点符号的替代写法。即使在预处理器中，也可以使用这些关键词，如在 #if 中拿它们充当运算符。\n在 C 中，可以通过包含 iso646.h 来要求这些关键字具有 C++ 的含义。该头文件将它们定义为普通的宏，并扩展到相应的标点符号。\n下面列出这 11 个命名运算符及对应的标点符号：\n   命名运算符 标点符号     and \u0026amp;\u0026amp;   and_eq \u0026amp;=   bitand \u0026amp;   bitor `   compl ~   not !   not_eq !=   or `   or_eq `   xor ^   xor_eq ^=   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/miscellaneous/predefined-macros/","summary":"\u003cp\u003e根据 GCC CPP 在线文档的 \u003ca href=\"https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html#Predefined-Macros\"\u003ePredefined Macros\u003c/a\u003e 章节整理。\u003c/p\u003e","title":"预定义宏"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 GCC 扩展语法。\nextern \u0026quot;C\u0026quot; 这是提供给 C++ 编译器的，extern \u0026quot;C\u0026quot; 通知编译器使用 C 语言的链接规范，即不需要改变函数名称。由于 C++ 具有函数重载功能，因此 C++ 编译器不能仅使用函数名作为链接的唯一标识，而会在原本的函数名中添加参数相关的信息。\n自然，在编译内核时，我们需要使用 C 语言的链接规范。\ninclude/linux/linkage.h：\n1 2 3 4 5  #ifdef __cplusplus #define CPP_ASMLINKAGE extern \u0026#34;C\u0026#34; #else #define CPP_ASMLINKAGE #endif   __cplusplus 宏将在使用 C++ 编译器时被定义，这时候需要告知编译器使用 C 语言的链接规范。\n属性 属性向编译器提供了有关函数或变量用法的详细信息，可能影响代码输出方面的一些细节。这使得编译器可以应用更准确的优化选项，以生成质量更好的代码，或者实现用普通 C 语言无法描述的功能。\n属性通过对变量或函数的声明增加前缀或后缀来指定，关键字是 __attribute__((list))，下面用几个例子来说明。\nnoreturn include/linux/linkage.h：\n1  #define ATTRIB_NORET __attribute__((noreturn))   noreturn 用于指定被调用函数不返回到调用者。该关键词一般用在会触发内核恐慌（panic）的函数，或在结束后通常会关机的函数。使用该属性主要是为了防止编译器在相关代码中发出未初始化变量的警告，或者没有返回值的警告等。\n举个简单的例子，首先创建一个文件 test.c：\n1 2 3 4 5 6 7 8 9  extern void stop(void); int fun(int n) { if (n \u0026lt; 0) stop(); else return 0; }   之后编译该文件（不同版本 GCC 产生的输出可能不同）：\n1 2 3 4 5  $ gcc -c -Wall test.c test.c: In function ‘fun’: test.c:9:1: warning: control reaches end of non-void function [-Wreturn-type] 9 | } | ^   下面我们修改 test.c：\n1 2 3 4 5 6 7 8 9  extern void stop(void) __attribute__((noreturn)); int fun(int n) { if (n \u0026lt; 0) stop(); else return 0; }   再次编译，没有产生任何警告。\nregparm(number) arch/x86/include/asm/linkage.h：\n1 2  #ifdef CONFIG_X86_32 #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))   在 x86-32 平台上，regparm(number) 用于指定以寄存器传递参数的个数。regparm(0) 即不使用寄存器传递参数。\nwarn_unused_result include/linux/compiler-gcc4.h：\n1  #define __must_check __attribute__((warn_unused_result))   warn_unused_result 用于指定函数返回值必须被调用者使用，否则会产生警告。该属性主要用于不检查函数返回值会导致安全问题或者造成 bug 的情况。\n内联汇编 GCC 允许借助专门的语句，将汇编代码直接集成到 C 代码中，编译器来承担联合代码生成的工作。插入汇编代码是平台相关的，但用于集成汇编语句与 C 代码的机制是平台无关的。\n注意，GCC 无法检查内联汇编的代码是否正确，也不能检查所使用的寄存器是否适用于特定的应用程序，这是程序员的责任。\n插入汇编代码的关键词为 asm 或 __asm__，语法如下：\n1 2 3 4 5  asm (\u0026#34;汇编代码（用分号分隔多个语句）\u0026#34; : 输出操作数（可选） : 输入操作数（可选） : 修饰寄存器列表（可选） );   在 x86 平台，汇编代码必须使用 AT\u0026amp;T 格式，这部分内容可以参考《深入理解计算机系统》第二版第三章。\n输入和输出操作数通过 \u0026quot;约束\u0026quot; (变量) 的形式定义，常用的约束：\n   约束 含义     r 使用一个通用寄存器   m 使用内存中的一个地址   I 定义一个位于 0-31 的常数用于 32 位移位操作   J 定义一个位于 0-63 的常数用于 64 位移位操作    常用的约束修饰符如下表所示：\n   约束修饰符 含义     = 指定操作数是只写的，丢弃前一个值，替换为操作的输出值   + 指定操作数是读写的    来看一个简单的例子：\n1 2 3 4 5 6 7 8  int a = 5; int b; asm (\u0026#34;movl %1, %%eax; movl %%eax, %0\u0026#34; : \u0026#34;=r\u0026#34; (b) : \u0026#34;r\u0026#34; (a) : \u0026#34;%%eax\u0026#34;);   该代码段将 a 赋值给 b，即 b = a。其中，%1 代表第 2 个出现的寄存器（注意从 0 开始计数），%%eax 代表 %eax（%% 最终会被转义为一个 %），因此 movl %1, %%eax 相当于 %eax = a。同理，movl %%eax, %0 相当于 b = %eax。\n__builtin 函数 __builtin 函数向编译器提供了其他选项，可以执行 C 语言常规能力范围之外的操作，又不必借助内联汇编。\n__builtin_return_address(0) __builtin_return_address(0) 返回函数的返回地址，即函数结束时控制流将定位到的目标地址。这是一个特定于体系结构的任务，该函数提供了一个通用的前端。\n__builtin_expect(long exp, long c) __builtin_expect(long exp, long c) 函数主要帮助编译器优化分支预测。exp 是一个将计算表达式的结果值，c 是返回的预期结果。\n举个简单的例子，对于如下的 if 语句：\n1 2 3 4 5  if (expression) { ... } else { ... }   如果知道在大部分情况下 expression 为真，那么这段代码可以优化为：\n1 2 3 4 5  if (__builtin_expect(expression), 1) { ... } else { ... }   这样编译器将通过预先计算第一个分支的方式，来影响处理器的分支预测。\n内核中定义了两个宏来优化“很可能”和“不太可能”的分支。\ninclude/linux/compiler.h：\n1 2  #define likely(x) __builtin_expect(!!(x), 1) #define unlikely(x) __builtin_expect(!!(x), 0)   此处了使用双重否定号 (!!)，是为了标准化表达式的结果为该函数所预期的 0 和 1。具体而言，考虑指针和其他表达式的值：\n 空指针 (NULL)：第一个否定把 NULL 变成了 1，第二个否定把 1 变成了 0。 非空指针：第一个否定把非空指针变成了 0，第二个否定把 0 变成了 1。 其他表达式的 0 值：第一个否定把 0 变成了 1，第二个否定把 1 变成了 0。 其他表达式的非 0 值：第一个否定把非 0 值变成了 0，第二个否定把 0 变成了 1。  指针运算 通常在 C 语言中，只允许对具有显示类型的指针进行计算，如 int *。GNU 编译器拓宽了该限制，支持 void 指针和函数指针的运算，加 1 的语义是增加 1 字节。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/expansion/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 GCC 扩展语法。\u003c/p\u003e","title":"GCC 扩展语法"},{"content":"Linux 内核学习笔记系列，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核链表。\n传统的链表与内核链表 在通常情况下，假设我们需要一个描述狐狸信息的双向链表：\n1 2 3 4 5 6 7  struct fox { unsigned long tail_length; /* 尾巴长度，以厘米为单位 */ unsigned long weight; /* 重量，以千克为单位 */ bool is_fantastic; /* 这只狐狸奇妙吗? */ struct fox *next; /* 指向下一只狐狸 */ struct fox *prev; /* 指向前一只狐狸 */ };   我们会在 fox 结构体添加该结构体的指针，这样 fox 数据结构（即链表的结点）就能被塞入链表。\n然后我们针对 fox 结构体实现相关的链表操作，比如添加狐狸：\n1 2 3 4  void add_fox(struct fox *list, struct fox *f) { ... }   现在我们又需要一个描述兔子信息的双向链表，自然我们需要定义一个新的结构体：\n1 2 3 4 5 6  struct rabbit { unsigned long weight; /* 重量，以千克为单位 */ bool is_fantastic; /* 这只兔子奇妙吗? */ struct rabbit *next; /* 指向下一只兔子 */ struct rabbit *prev; /* 指向前一只兔子 */ };   然后我们需要针对 rabbit 结构体实现相关的链表操作，比如添加狐狸：\n1 2 3 4  void add_rabbit(struct rabbit *list, struct rabbit *r) { ... }   这时候就有人提出了，我们已经为 fox 结构体定义过了相关的操作，但为了 rabbit 结构体我们需要再次实现几乎完全一样的功能，这是重复劳动。\n我们希望实现一个更加通用的方案，针对链表的操作应该对所有情况都适用（比如上面的 fox 和 rabbit）。显然传统的链表是无法解决这一问题的，因而与传统的方式相反，内核把链表结点塞入其他数据结构，实现了一种独特解法。\n内核链表是一个独特的双向循环链表，下面我们先展示内核链表的用法，再介绍其具体实现。\n内核链表的使用 内核链表实现称为 list，头文件为 include/linux/list.h。它实现了通用的链表操作，仍然以 fox 结构体为例，下面展示内核链表的常见用法。\n定义链表 1 2 3 4 5 6  struct fox { unsigned long tail_length; /* 尾巴长度，以厘米为单位 */ unsigned long weight; /* 重量，以千克为单位 */ bool is_fantastic; /* 这只狐狸奇妙吗? */ struct list_head list; /* 所有 fox 结构体形成链表 */ };   初始化链表 动态初始化 1 2 3 4 5 6  struct fox *f; f = kmalloc(sizeof(*f), GFP_KERNEL); f-\u0026gt;tail_length = 40; f-\u0026gt;weight = 6; f-\u0026gt;is_fantastic = false; INIT_LIST_HEAD(\u0026amp;f-\u0026gt;list);   静态初始化 1 2 3 4 5  struct fox f = { .tail_length = 40, .weight = 6, .list = LIST_HEAD_INIT(f.list), };   定义链表头 1  static LIST_HEAD(fox_list);   添加结点 在头部添加结点 1  list_add(\u0026amp;f-\u0026gt;list, \u0026amp;fox_list);   在尾部添加结点 1  list_add_tail(\u0026amp;f-\u0026gt;list, \u0026amp;fox_list);   删除结点 1  list_del(\u0026amp;f-\u0026gt;list);   遍历链表 基本方法 1 2 3 4 5 6  struct list_head *p; struct fox *f; list_for_each(p, \u0026amp;fox_list) { f = list_entry(p, struct fox, list); ... }   常用方法 1 2 3 4  struct fox *f; list_for_each_entry(f, \u0026amp;fox_list, list) { ... }   遍历时删除 1 2 3 4  struct fox *f, *next; list_for_each_entry_safe(f, next, \u0026amp;fox_list, list) { ... }   内核链表的实现 所有内核链表的实现均位于 include/linux/list.h。\n链表结构体的实现 1 2 3  struct list_head { struct list_head *next, *prev; };   初始化链表的实现 1 2 3 4 5 6 7 8 9 10  #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) }  #define LIST_HEAD(name) \\ struct list_head name = LIST_HEAD_INIT(name)  static inline void INIT_LIST_HEAD(struct list_head *list) { list-\u0026gt;next = list; list-\u0026gt;prev = list; }   相关判断的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  /** * list_is_last - tests whether @list is the last entry in list @head * @list: the entry to test * @head: the head of the list */ static inline int list_is_last(const struct list_head *list, const struct list_head *head) { return list-\u0026gt;next == head; } /** * list_empty - tests whether a list is empty * @head: the list to test. */ static inline int list_empty(const struct list_head *head) { return head-\u0026gt;next == head; } /** * list_empty_careful - tests whether a list is empty and not being modified * @head: the list to test * * Description: * tests whether a list is empty _and_ checks that no other CPU might be * in the process of modifying either member (next or prev) * * NOTE: using list_empty_careful() without synchronization * can only be safe if the only activity that can happen * to the list entry is list_del_init(). Eg. it cannot be used * if another CPU could re-list_add() it. */ static inline int list_empty_careful(const struct list_head *head) { struct list_head *next = head-\u0026gt;next; return (next == head) \u0026amp;\u0026amp; (next == head-\u0026gt;prev); } /** * list_is_singular - tests whether a list has just one entry. * @head: the list to test. */ static inline int list_is_singular(const struct list_head *head) { return !list_empty(head) \u0026amp;\u0026amp; (head-\u0026gt;next == head-\u0026gt;prev); }   添加结点的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-\u0026gt;prev = new; new-\u0026gt;next = next; new-\u0026gt;prev = prev; prev-\u0026gt;next = new; } /** * list_add - add a new entry * @new: new entry to be added * @head: list head to add it after * * Insert a new entry after the specified head. * This is good for implementing stacks. */ static inline void list_add(struct list_head *new, struct list_head *head) { __list_add(new, head, head-\u0026gt;next); } /** * list_add_tail - add a new entry * @new: new entry to be added * @head: list head to add it before * * Insert a new entry before the specified head. * This is useful for implementing queues. */ static inline void list_add_tail(struct list_head *new, struct list_head *head) { __list_add(new, head-\u0026gt;prev, head); }   删除结点的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* * Delete a list entry by making the prev/next entries * point to each other. * * This is only for internal list manipulation where we know * the prev/next entries already! */ static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; prev-\u0026gt;next = next; } /** * list_del - deletes entry from list. * @entry: the element to delete from the list. * Note: list_empty() on entry does not return true after this, the entry is * in an undefined state. */ static inline void list_del(struct list_head *entry) { __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); entry-\u0026gt;next = LIST_POISON1; entry-\u0026gt;prev = LIST_POISON2; } /** * list_del_init - deletes entry from list and reinitialize it. * @entry: the element to delete from the list. */ static inline void list_del_init(struct list_head *entry) { __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); INIT_LIST_HEAD(entry); }   值得注意的是，list_del() 函数在调用 __list_del() 函数完成删除 entry 后，仍然设置了 entry 的指针。LIST_POISON1 和 LIST_POISON2 被定义于 include/linux/poison.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /********** include/linux/list.h **********/ /* * Architectures might want to move the poison pointer offset * into some well-recognized area such as 0xdead000000000000, * that is also not mappable by user-space exploits: */ #ifdef CONFIG_ILLEGAL_POINTER_VALUE # define POISON_POINTER_DELTA _AC(CONFIG_ILLEGAL_POINTER_VALUE, UL) #else # define POISON_POINTER_DELTA 0 #endif  /* * These are non-NULL pointers that will result in page faults * under normal circumstances, used to verify that nobody uses * non-initialized list entries. */ #define LIST_POISON1 ((void *) 0x00100100 + POISON_POINTER_DELTA) #define LIST_POISON2 ((void *) 0x00200200 + POISON_POINTER_DELTA)   根据注释，设置这两个值是为了在循环中遍历到 entry 时触发页面异常，这相当于加了一道保险，毕竟不应该出现遍历已经删除了的结点的情况。\n与 list_del() 形成对比，list_del_init() 在删除 entry 后，重新初始化 entry，这是为了能再次使用包含 entry 的数据结构，比如需要把该数据结构重新添加到链表中（正如刚刚说的，如果使用 list_add() 添加 list_del() 后的 entry，遍历时会发生页面异常）。\n移动结点的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /** * list_move - delete from one list and add as another\u0026#39;s head * @list: the entry to move * @head: the head that will precede our entry */ static inline void list_move(struct list_head *list, struct list_head *head) { __list_del(list-\u0026gt;prev, list-\u0026gt;next); list_add(list, head); } /** * list_move_tail - delete from one list and add as another\u0026#39;s tail * @list: the entry to move * @head: the head that will follow our entry */ static inline void list_move_tail(struct list_head *list, struct list_head *head) { __list_del(list-\u0026gt;prev, list-\u0026gt;next); list_add_tail(list, head); } /** * list_rotate_left - rotate the list to the left * @head: the head of the list */ static inline void list_rotate_left(struct list_head *head) { struct list_head *first; if (!list_empty(head)) { first = head-\u0026gt;next; list_move_tail(first, head); } }   其中，list_rotate_left() 函数用于将链表的第一个结点移动至末尾。\n拆分链表的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  static inline void __list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry) { struct list_head *new_first = entry-\u0026gt;next; list-\u0026gt;next = head-\u0026gt;next; list-\u0026gt;next-\u0026gt;prev = list; list-\u0026gt;prev = entry; entry-\u0026gt;next = list; head-\u0026gt;next = new_first; new_first-\u0026gt;prev = head; } /** * list_cut_position - cut a list into two * @list: a new list to add all removed entries * @head: a list with entries * @entry: an entry within head, could be the head itself * and if so we won\u0026#39;t cut the list * * This helper moves the initial part of @head, up to and * including @entry, from @head to @list. You should * pass on @entry an element you know is on @head. @list * should be an empty list or a list you do not care about * losing its data. * */ static inline void list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry) { if (list_empty(head)) return; if (list_is_singular(head) \u0026amp;\u0026amp; (head-\u0026gt;next != entry \u0026amp;\u0026amp; head != entry)) return; if (entry == head) INIT_LIST_HEAD(list); else __list_cut_position(list, head, entry); }   合并链表的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  static inline void __list_splice(const struct list_head *list, struct list_head *prev, struct list_head *next) { struct list_head *first = list-\u0026gt;next; struct list_head *last = list-\u0026gt;prev; first-\u0026gt;prev = prev; prev-\u0026gt;next = first; last-\u0026gt;next = next; next-\u0026gt;prev = last; } /** * list_splice - join two lists, this is designed for stacks * @list: the new list to add. * @head: the place to add it in the first list. */ static inline void list_splice(const struct list_head *list, struct list_head *head) { if (!list_empty(list)) __list_splice(list, head, head-\u0026gt;next); } /** * list_splice_tail - join two lists, each list being a queue * @list: the new list to add. * @head: the place to add it in the first list. */ static inline void list_splice_tail(struct list_head *list, struct list_head *head) { if (!list_empty(list)) __list_splice(list, head-\u0026gt;prev, head); } /** * list_splice_init - join two lists and reinitialise the emptied list. * @list: the new list to add. * @head: the place to add it in the first list. * * The list at @list is reinitialised */ static inline void list_splice_init(struct list_head *list, struct list_head *head) { if (!list_empty(list)) { __list_splice(list, head, head-\u0026gt;next); INIT_LIST_HEAD(list); } } /** * list_splice_tail_init - join two lists and reinitialise the emptied list * @list: the new list to add. * @head: the place to add it in the first list. * * Each of the lists is a queue. * The list at @list is reinitialised */ static inline void list_splice_tail_init(struct list_head *list, struct list_head *head) { if (!list_empty(list)) { __list_splice(list, head-\u0026gt;prev, head); INIT_LIST_HEAD(list); } }   获取包含结点的数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * list_entry - get the struct for this entry * @ptr: the \u0026amp;struct list_head pointer. * @type: the type of the struct this is embedded in. * @member: the name of the list_struct within the struct. */ #define list_entry(ptr, type, member) \\ container_of(ptr, type, member)  /** * list_first_entry - get the first element from a list * @ptr: the list head to take the element from. * @type: the type of the struct this is embedded in. * @member: the name of the list_struct within the struct. * * Note, that list is expected to be not empty. */ #define list_first_entry(ptr, type, member) \\ list_entry((ptr)-\u0026gt;next, type, member)   container_of() 宏位于 include/linux/kernel.h：\n1 2 3 4 5 6 7 8 9 10  /** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */ #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type, member) );})   该宏用到的 offsetof() 宏位于 include/linux/stddef.h：\n1 2 3 4 5  #ifdef __compiler_offsetof #define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER) #else #define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) #endif   先来看宏 offsetof() 宏的思路。若编译器内置了相关功能，则使用内置的 __compiler_offsetof()，否则使用自定义的宏。offsetof() 的作用正如其名，获取 TYPE 类型结构体的成员 MEMBER 在该结构体中的偏移量：\n (TYPE *)0：强制类型转换，把 0 转换成指向 TYPE 类型的指针。 ((TYPE *)0)-\u0026gt;MEMBER：获取 TYPE 类型结构体的成员 MEMBER。 \u0026amp;((TYPE *)0)-\u0026gt;MEMBER：获取该成员的地址。 (size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER：把地址强制类型转换为 size_t 类型。  编译器在计算结构体成员的地址时，采用“成员地址 = 结构体首地址 + 成员偏移量”的方式，而这里巧妙地借助了 0 地址，把结构体首地址设为 0，得到的成员地址就等于成员偏移量。注意，这里只是获取了 MEMBER，即编译器只需要进行一些简单的地址计算，而无需实际访问相关的地址，因此不会生成相应的访存指令，也就不会导致运行时错误。\n再来看 container_of() 宏，有很多相似的地方，该宏获通过指向 type 类型结构体的成员 member 的指针 ptr 来获取该结构体本身：\n (type *)0：强制类型转换，把 0 转换成指向 type 类型的指针。 ((type *)0)-\u0026gt;member：获取 type 类型结构体的成员 member。 typeof( ((type *)0)-\u0026gt;member )：获取 member 的类型，记为 T。 const typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr);：定义一个 const T * 类型的变量 __mptr，并赋值为 ptr。 (char *)__mptr：将 __mptr 强制转换成 char * 类型（char * 指针加 1 的语义是增加 1 字节）。 (char *)__mptr - offsetof(type, member)：把 __mptr 的地址减去 member 在 type 类型结构体中的偏移量，计算结果为 type 类型结构体的首地址。 (type *)( (char *)__mptr - offsetof(type, member) );：把计算结果（结构体的首地址）强制转换为 type * 类型。  其中，typeof 关键字是 GCC 扩展语法，typeof(exp) var 能获取表达式 exp 的计算结果的类型，并声明该类型的变量 var。比如 typeof(1 + 1) a;，因为表达式 1 + 1 的结果是 int 类型，所以变量 a 也是 int 类型。\n额外定义一个 __mptr 看似是多余的，这么做的理由是为了方便程序员发现错误。具体来说，如果 ptr 的类型和 member 不一致，那么在编译 const typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr); 时会产生警告，以便让程序员注意到自己犯了错误。\n最后来看 list_entry() 和 list_first_entry() 宏，就很好理解了。以上文的 fox 结构体为例，通过一个指向 struct fox 成员 list 的指针 p，来获取该结构体本身：\n1 2 3 4 5  struct fox *f; f = list_entry(p, // 指向结构体成员的指针  struct fox, // 结构体类型  list // 成员名  );   遍历链表的实现 遍历链表的函数相当多，这里只列出几个。\n基本方法的实现 1 2 3 4 5 6 7 8  /** * list_for_each - iterate over a list * @pos: the \u0026amp;struct list_head to use as a loop cursor. * @head: the head for your list. */ #define list_for_each(pos, head) \\ for (pos = (head)-\u0026gt;next; prefetch(pos-\u0026gt;next), pos != (head); \\ pos = pos-\u0026gt;next)   大部分的遍历都通过 prefetch() 来优化遍历速度，prefetch() 借助了 GCC 扩展语法，定义于 include/linux/prefetch.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /* prefetch(x) attempts to pre-emptively get the memory pointed to by address \u0026#34;x\u0026#34; into the CPU L1 cache. prefetch(x) should not cause any kind of exception, prefetch(0) is specifically ok. prefetch() should be defined by the architecture, if not, the #define below provides a no-op define. There are 3 prefetch() macros: prefetch(x) - prefetches the cacheline at \u0026#34;x\u0026#34; for read prefetchw(x) - prefetches the cacheline at \u0026#34;x\u0026#34; for write spin_lock_prefetch(x) - prefetches the spinlock *x for taking there is also PREFETCH_STRIDE which is the architecure-prefered \u0026#34;lookahead\u0026#34; size for prefetching streamed operations. */ #ifndef ARCH_HAS_PREFETCH #define prefetch(x) __builtin_prefetch(x) #endif   使用这种方法遍历链表，往往要借助 list_entry() 来获取结构体，比较麻烦，因此不常用。\n常用方法的实现 1 2 3 4 5 6 7 8 9 10  /** * list_for_each_entry - iterate over list of given type * @pos: the type * to use as a loop cursor. * @head: the head for your list. * @member: the name of the list_struct within the struct. */ #define list_for_each_entry(pos, head, member) \\ for (pos = list_entry((head)-\u0026gt;next, typeof(*pos), member); \\ prefetch(pos-\u0026gt;member.next), \u0026amp;pos-\u0026gt;member != (head); \\ pos = list_entry(pos-\u0026gt;member.next, typeof(*pos), member))   反向遍历的实现 1 2 3 4 5 6 7 8 9 10  /** * list_for_each_entry_reverse - iterate backwards over list of given type. * @pos: the type * to use as a loop cursor. * @head: the head for your list. * @member: the name of the list_struct within the struct. */ #define list_for_each_entry_reverse(pos, head, member) \\ for (pos = list_entry((head)-\u0026gt;prev, typeof(*pos), member); \\ prefetch(pos-\u0026gt;member.prev), \u0026amp;pos-\u0026gt;member != (head); \\ pos = list_entry(pos-\u0026gt;member.prev, typeof(*pos), member))   遍历时删除的实现 1 2 3 4 5 6 7 8 9 10 11 12  /** * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry * @pos: the type * to use as a loop cursor. * @n: another type * to use as temporary storage * @head: the head for your list. * @member: the name of the list_struct within the struct. */ #define list_for_each_entry_safe(pos, n, head, member) \\ for (pos = list_entry((head)-\u0026gt;next, typeof(*pos), member), \\ n = list_entry(pos-\u0026gt;member.next, typeof(*pos), member); \\ \u0026amp;pos-\u0026gt;member != (head); \\ pos = n, n = list_entry(n-\u0026gt;member.next, typeof(*n), member))   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/data-structure/list/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，GCC 扩展语法和内核数据结构部分，简单介绍 Linux 内核链表。\u003c/p\u003e","title":"内核链表"},{"content":"Linux 内核学习笔记系列，内核简介部分，简单介绍 Linux 内核学习的前置知识，以及 Linux 内核的基本概念。\n前置知识（书单推荐） C 语言  《C Primer Plus》 《C和指针》 《C专家编程》 《C陷阱与缺陷》 《C程序设计语言》  数据结构  《数据结构与算法分析 —— C 语言描述》  操作系统  《现代操作系统》 《操作系统 精髓与设计原理》  其他  《深入理解计算机系统》  Linux 内核基本概念 内核和操作系统的关系 内核是硬件和软件之间的一个中间层，其作用时将应用程序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。\n把操作系统定义为在整个系统中负责完成最基本功能和系统管理的那些部分。这些部分应该包括内核、设备驱动程序、启动引导程序、命令行 Shell 或者其他种类的用户界面、基本的文件管理工具和系统工具。\nLinux 版本 以 2.6.26.1 为例，2 为主版本号，6 为副版本号（从版本号），26 为修订版本号，1 为稳定版本号。主版本号和副版本号一起构成了“内核系列”。在 2.6 内核系列前，还没有稳定版本号，那时副版本号为奇数代表开发版，为偶数代表稳定版。而 2.6 之后的内核系列不属于本学习笔记系列记录的范畴。\n内核的组成部分 ","permalink":"https://freeflyingsheep.github.io/posts/kernel/introduction/basis/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内核简介部分，简单介绍 Linux 内核学习的前置知识，以及 Linux 内核的基本概念。\u003c/p\u003e","title":"Linux 内核基础"},{"content":"Linux 内核学习笔记系列，整理《深入理解 Linux 内核》（第三版，以下简称 ULK3）、《Linux 内核设计与实现》（原书第 3 版，以下简称 LKD3）和《深入 Linux 内核架构》（以下简称 PLKA）相关章节的联系以及个人理解。\n引言 本文将作为 Linux 内核学习笔记系列的目录。原计划用一年时间，初步阅读这三本书籍，逐渐完善相关学习笔记。现在正式宣告计划破产，之后不定期填坑（逃\n这三本讲解 Linux 内核的经典书籍，都基于 Linux 2.6 版本的内核。ULK3 基于 Linux 2.6.11 版本，LKD3 基于 Linux 2.6.34 版本，PLKA 基于 Linux 2.6.24 版本。\n虽然书中很多内容已经过时，但对于入门内核来说还是非常不错的选择。2.6 版本的 Linux 内核源码可以在 https://www.kernel.org/pub/linux/kernel/v2.6/ 上下载，本系列学习笔记将基于 2.6.34 版本。\n注意，本系列学习笔记只记录根据三本书籍整理的内容，即到 Linux 2.6.34 为止，且仅针对 x86 体系结构，学习笔记中的不少内容可能已经不适用于现在的内核。\n手册 在阅读源码的过程中，可能需要查询下列手册/官方文档：\n GCC 在线文档（包括 GCC、CPP 等） GNU Binutils 在线文档（包括 ld、as 等） GNU 在线文档（除了上述两个，还包括 Make 等） Linux Kernel 在线文档  下面是我根据手册部分章节整理的知识点：\n 宏的陷阱和使用技巧 预定义宏 动态调试  目录 我倾向于将这三本书联系起来阅读，先看 LKD3，然后结合着看另外两本，某些章节 ULK3 更容易理解，某些则是 PLKA 更容易理解。\n下面根据个人理解，列出三本书相关章节的联系以及阅读顺序。其中某些标题具有包含的关系，如”文件系统“包含”虚拟文件系统“，但考虑到其内容较多，所以单独拿出来。不论按什么顺序阅读，不同章节之间总是存在一定的交叉引用，很无奈。\n内核简介  LKD3 第 1 章：Linux 内核简介 ULK3 第 一 章：绪论 PLKA 第 1 章：简介和概述   Linux 内核基础 Linux 内核常见函数/宏  内核开发  LKD3 第 2 章：从内核出发 LKD3 第 18 章：调试 LKD3 第 19 章：可移植性 LKD3 第 20 章：补丁、开发和社区 PLKA 附录 A：体系结构相关知识 PLKA 附录 B：使用源代码 PLKA 附录 F：内核开发过程   内核编译和调试 体系结构相关知识 内核开发相关知识  GCC 扩展语法和内核数据结构  LKD3 第 6 章：内核数据结构 PLKA 附录 C：有关 C 语言的注记   GCC 扩展语法 内核位图 内核链表 内核散列表 内核队列 内核红黑树 内核基数树 内核映射  内存管理  LKD3 第 12 章：内存管理 ULK3 第 二 章：内存寻址 ULK3 第 八 章：内存管理 PLKA 第 3 章：内存管理   内存寻址 内存模型 伙伴系统 per-CPU 高速缓存 连续页框的管理 内存映射 非连续页框的管理 slab 分配器 内存管理初始化 bootmem 分配器 内存管理补充  进程管理  LKD3 第 3 章：进程管理 LKD3 第 4 章：进程调度 ULK3 第 三 章：进程 ULK3 第 七 章：进程调度 PLKA 第 2 章：进程管理和调度  进程地址空间  LKD3 第 15 章：进程地址空间 ULK 第 九 章：进程地址空间 PLKA 第 4 章：进程虚拟内存  系统调用  LKD3 第 5 章：系统调用 ULK3 第 十 章：系统调用 PLKA 第 13 章；系统调用  中断  LKD3 第 7 章：中断和中断处理 LKD3 第 8 章：下半部和推后执行的工作 ULK3 第 四 章：中断和异常 PLKA 第 14 章：内核活动  内核同步  LKD3 第 9 章：内核同步介绍 LKD3 第 10 章：内核同步方法 ULK3 第 五 章：内核同步 PLKA 第 5 章：锁与进程间通信（5.1 和 5.2）  时间管理  LKD3 第 11 章：定时器和时间管理 ULK3 第 六 章：定时测量 PLKA 第 15 章：时间管理  虚拟文件系统  LKD3 第 13 章：虚拟文件系统 ULK3 第 十二 章：虚拟文件系统 PLKA 第 8 章：虚拟文件系统  高速缓存  LKD3 第 16 章：页高速缓存和页回写 ULK3 第 十五 章：页高速缓存 PLKA 第 16 章：页缓存和块缓存 PLKA 第 17 章：数据同步  回收页框  ULK3 第 十七 章：回收页框 PLKA 第 18 章：页面回收和页交换  文件系统  ULK3 第 十六 章：访问文件 ULK3 第 十八 章：Ext2 和 Ext3 文件系统 PLKA 第 9 章：Ext 文件系统族 PLKA 第 10 章：无持久存储的文件系统 PLKA 第 11 章：扩展属性和访问控制表  设备驱动程序  LKD3 第 14 章：块 I/O 层 ULK3 第 十三 章：I/O 体系结构和设备驱动程序 ULK3 第 十四 章：块设备驱动程序 PLKA 第 6 章：设备驱动程序  模块  LKD3 第 17 章：设备与模块 ULK3 附录 二：模块 PLKA 第 7 章：模块  进程间通信  ULK3 第 十一 章：信号 ULK3 第 十九章：进程通信 PLKA 第 5 章：锁与进程间通信（其余部分）  程序的执行  ULK3 第 二十 章：程序的执行 PLKA 附录 E：ELF 二进制格式  系统启动  ULK3 附录 一：系统启动 PLKA 附录 D：系统启动  其他内容  PLKA 第 12 章：网络 PLKA 第 19 章：审计   TODO 列表 ","permalink":"https://freeflyingsheep.github.io/posts/kernel/kernel/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，整理《深入理解 Linux 内核》（第三版，以下简称 ULK3）、《Linux 内核设计与实现》（原书第 3 版，以下简称 LKD3）和《深入 Linux 内核架构》（以下简称 PLKA）相关章节的联系以及个人理解。\u003c/p\u003e","title":"Linux 内核学习笔记"},{"content":"使用 Hugo 配合 Github Pages 搭建静态博客，利用 Github Actions 自动部署。\n安装 Hugo Windows 从 Hugo Releases 页面下载软件压缩包，之后解压到想要的目录，并添加环境变量。\nLinux 在大部分发行版中，直接安装软件包 hugo 即可。\n新建网站 运行以下命令新建一个名为 Blog 的网站。\n1  hugo new site Blog   使用主题 此处以本人使用的 LoveIt 主题为例。\n注意：由于 LoveIt 主题已经不再更新，本博客现在改用 PaperMod 主题。\n使用如下命令初始化 Git 仓库并添加主题子模块：\n1 2  git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt   主题的配置可以参考相应主题的文档。\n使用 Gitalk 静态博客不具备评论功能，使用 Gitalk 实现评论功能。\n由于 LoveIt 主题支持 Gitalk，只需要注册一个 GitHub Application（位于 Settings -\u0026gt; Developer settings -\u0026gt; OAuth Apps），并在 LoveIt 的配置中设置好相应内容即可启用。\n关联到 Github 使用 hugo 命令会生成静态网站，默认在 public 文件夹中。需要 Github 展示的是 public 文件夹的内容，而不是整个项目的内容。\n可以采用子模块的方式管理这两个项目这样就可以方便地管理这两个项目。\n设置 Github Pages 在 Github 的 \u0026lt;username\u0026gt;.github.io 仓库中设置启用 Github Pages，使用 master 分支以及根路径。\n保存后等待 Github 完成相应的构建，即可访问 https://\u0026lt;username\u0026gt;.github.io，查看个人博客。注意，有时候博客已经完成构建，但该网址仍然无法访问，Github 完成网址的映射可能需要几分钟甚至数个小时。\n克隆项目 由于项目带子模块，采用如下方式克隆：\n1  git clone --recurse-submodules \u0026lt;url\u0026gt;   或者：\n1 2 3 4  git clone \u0026lt;url\u0026gt; cd \u0026lt;project\u0026gt; git submodule init git submodule update   后两个命令还可以合并为 git submodule update --init。\n自动化脚本 建立脚本来简化常用的操作。\n注意：现在已经可以利用 Github Actions 自动部署了，见 自动部署。\n一键预览 通常运行 hugo serve 即可，但以 LoveIt 主题为例，希望启用一些生成环境的功能，使用如下脚本：\n1  hugo serve --disableFastRender -e production   一键部署 同时部署 Blog 和 \u0026lt;username\u0026gt;.github.io 项目：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  echo \u0026#34;Deploying updates to GitHub...\u0026#34; cd public git rm -rf . \u0026gt; /dev/null cd .. hugo cd public git add . msg=\u0026#34;Rebuild site on `date \u0026#39;+%x %X\u0026#39;`\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git diff-index --quiet HEAD || git commit -m \u0026#34;$msg\u0026#34; git push origin master cd .. git add . git diff-index --quiet HEAD || git commit -am \u0026#34;$msg\u0026#34; git push --recurse-submodules=check origin master   每次生成静态网站前强制删了了以前的文件，这是为了应对修改了某些博文所在的目录后，原本的目录会残留的问题，目前没想到更好的解决办法。\n一键更新 使用 git pull --rebase --recurse-submodules 命令更新会让子模块位于分离头指针的状态，分别更新它们：\n1 2 3 4 5 6 7 8 9 10 11  echo \u0026#34;Updating public...\u0026#34; cd public git pull --rebase echo \u0026#34;Updating LoveIt...\u0026#34; cd ../themes/LoveIt git pull --rebase echo \u0026#34;Updating Blog...\u0026#34; cd ../ git pull --rebase   自动部署 本博客现在已经采用自动部署的方式。\nGithub Actions 配置 参考 GitHub Actions for Hugo。\n新建 .github\\workflows\\gh-pages.yml 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  name: Github Pages on: push: branches: - main  # Set a branch name to trigger deployment jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # Use Hugo extended - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public force_orphan: true   现在 Github Actions 会在每次 push 后自动编译网站，并将生成的 public 文件夹中的内容上传到 gh-pages 分支。\nGithub Pages 配置 启用 Github Pages，使用 gh-pages 分支以及根路径。\n依赖自动更新 新建 .github\\dependabot.yml 文件：\n1 2 3 4 5 6 7 8 9 10 11  version: 2 updates: # Enable version updates for github-actions - package-ecosystem: \u0026#34;github-actions\u0026#34; directory: \u0026#34;/\u0026#34; schedule: interval: \u0026#34;daily\u0026#34; labels: - \u0026#34;dependabot\u0026#34; commit-message: prefix: \u0026#34;github-actions\u0026#34;   现在 Github Dependabot 会每日自动检测 github-actions 脚本更新。\n","permalink":"https://freeflyingsheep.github.io/posts/tips/hugo/","summary":"\u003cp\u003e使用 \u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e 配合 \u003ca href=\"https://pages.github.com/\"\u003eGithub Pages\u003c/a\u003e 搭建静态博客，利用 \u003ca href=\"https://github.com/features/actions\"\u003eGithub Actions\u003c/a\u003e 自动部署。\u003c/p\u003e","title":"使用 Hugo 搭建个人博客"},{"content":"使用 Zsh 作为默认 shell，安装 Zsh 和 oh my zsh 框架并完成配置。\n安装 Zsh 在 Linux 系统中安装 Zsh，大部分发行版中 Zsh 的包名都为 zsh。\n安装 oh my zsh 参考 oh my zsh 官网，使用如下命令安装：\n1  sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34;   或者：\n1  sh -c \u0026#34;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\u0026#34;   配置 oh my zsh 修改家目录下的 .zshrc 文件，将 ZSH_THEME 修改为想要的主题，如 ZSH_THEME=\u0026quot;agnoster\u0026quot;。\n某些主题会提示计算机名，如果不希望在当前用户下提示计算机名，可以在 .zshrc 文件的末尾添加 DEFAULT_USER=\u0026quot;$(whoami)\u0026quot;。\n安装插件和其他主题 安装教程可以参考对应网站上的教程，下面推荐几个插件和主题。\n推荐四个插件：\n 额外的命令补全 代码提示 语法高亮 历史记录的子字符串搜索  推荐一个主题：\n Powerlevel10k ","permalink":"https://freeflyingsheep.github.io/posts/tips/zsh/","summary":"\u003cp\u003e使用 Zsh 作为默认 shell，安装 Zsh 和 oh my zsh 框架并完成配置。\u003c/p\u003e","title":"使用 Zsh"},{"content":"根据微软官方文档 Windows Subsystem for Linux Installation Guide for Windows 10 整理。\nWSL 1 和 WSL 2 的选择 两者的比较可以参考微软官方文档比较 WSL 1 和 WSL 2。\n个人推荐优先选择 WSL 2，若发现 WSL 2 和其他软件冲突，再回退到 WSL 1。\n启用 WSL 1 以管理员身份打开 PowerShell 并运行：\n1  dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart   重启计算机即可。\n启用 WSL 2 在启用 WSL 1的基础上，不要重启，而是以管理员身份打开 PowerShell 并运行：\n1  dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart   现在重启计算机。\n安装升级软件包 下载 WSL2 Linux kernel update package for x64 machines 并安装。\n将 WSL 2 设置为默认版本 以管理员的身份打开 PowerShell 并运行：\n1  wsl --set-default-version 2   从 WSL 2 回到 WSL 1 当 WSL 2 和其他软件冲突，需要关闭相关功能时，以管理员的身份打开 PowerShell 并运行：\n1 2  wsl --set-default-version 1 dism.exe /online /disable-feature /featurename:VirtualMachinePlatform   重启计算机。\n关闭 WSL 1 若开启了 WSL 2，先从 WSL 2 回到 WSL 1，跳过重启。\n以管理员的身份打开 PowerShell 并运行：\n1  dism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux   现在重启计算机。\n安装 Linux 发行版 在应用商店选择想要安装的发行版即可。个人推荐在 WSL 1 下使用 Debian，在 WSL 2 下使用 Ubuntu 或者 Debian。\n指定发行版使用 WSL1 或 WSL2 查看所有安装的发行版，以管理员的身份打开 PowerShell 并运行：\n1  wsl --list -v   举个例子，若需要修改发行版 Debian 使用 WSL 1，运行以下指令：\n1  wsl --set-version Debian 1   安装 Windows Terminal 在应用商店选择安装 Windows Terminal。\n若想把 WSL 设为默认启动的终端，将 defaultProfile 设置为 WSL 的 guid，默认为 PowerShell。\n如果要指定终端启动时的大小，在 defaultProfile 之后加入如下配置（配置文件提供的注释已经很友好了）：\n1 2 3 4  // You can add more global application settings here. // To learn more about global settings, visit https://aka.ms/terminal-global-settings \u0026#34;initialCols\u0026#34;: 80, \u0026#34;initialRows\u0026#34;: 24,   在 profiles 的 defaults 中加入通用的配置，如：\n1 2 3 4  // Put settings here that you want to apply to all profiles. \u0026#34;fontFace\u0026#34;: \u0026#34;Jetbrains Mono\u0026#34;, \u0026#34;fontSize\u0026#34;: 14, \u0026#34;colorScheme\u0026#34;: \u0026#34;idleToes\u0026#34;   若使用自定义主题（如上面的 idleToes），需要在 schemes 中加入与 colorScheme 对应的颜色主题配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Add custom color schemes to this array. // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes \u0026#34;schemes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;idleToes\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#323232\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#d25252\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#7fe173\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#ffc66d\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#4099ff\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#f680ff\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#bed6ff\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#eeeeec\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#535353\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#f07070\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#9dff91\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#ffe48b\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#5eb7f7\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#ff9dff\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#dcf4ff\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#323232\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#ffffff\u0026#34; } ]   更多颜色主题可以参考 https://windowsterminalthemes.dev/。\n如果希望打开终端时路径是家目录，下面介绍两种常见的方式。\n第一种方法是很多博客介绍的，将 WSL 对应的 source 改为 commandline，并添加 startingDirectory，以 Ubuntu 20.04 为例，本人的家目录是 /home/chris，修改配置如下：\n1 2 3  // \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34; \u0026#34;commandline\u0026#34;: \u0026#34;ubuntu2004\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;/home/chris\u0026#34;   第二种方法是官方文档里介绍的，只需要添加 startingDirectory 选项，以 Debian 为例，修改配置如下：\n1 2  \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/debian\u0026#34;   WSL2 和部分 VPN 冲突 使用 WSL2 时出现“参考的对象类型不支持尝试的操作”的提示，可能是因为开启了 VPN，解决方案如下：\n Thanks for the info.\nWe have reproduced this issue. Apparently, wsl.exe displays this error if Winsock LSP DLL gets loaded into its process.\nThe easiest solution is to use WSCSetApplicationCategory WinAPI call for wsl.exe to prevent \u0026gt;this. Under the hood the call creates an entry for wsl.exe at \u0026gt;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters\\AppId_Catalog This tells Windows not to load LSP DLLs into wsl.exe process.\nWe have a tool that can make this call: www.proxifier.com/tmp/Test20200228/NoLsp.exe\nPlease just run as admin with the full path to wsl.exe as the parameter: NoLsp.exe c:\\windows\\system32\\wsl.exe\nThis has fixed the problem in my case.\nPlease let me know how it works for you.\n 上述内容来源于 https://github.com/microsoft/WSL/issues/4177#issuecomment-597736482。\n","permalink":"https://freeflyingsheep.github.io/posts/linux/wsl/","summary":"\u003cp\u003e根据微软官方文档 \u003ca href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\"\u003eWindows Subsystem for Linux Installation Guide for Windows 10\u003c/a\u003e 整理。\u003c/p\u003e","title":"安装 WSL"},{"content":"根据《Linux From Scratch 版本 20200901-systemd，中文翻译版》构建 LFS systemd 10.0 的归纳总结。\nLFS 简介 LFS 项目主要是从源码一步一步构建一个定制的 Linux 系统。具体内容可以访问项目主页。\nLFS 构建过程 阅读官方手册。 宿主机环境检查，安装相应软件包，完成相关配置。 新建分区。 下载需要的软件包和补丁。 配置工作环境，主要包括创建目录布局、添加 lfs 用户、完成 lfs 用户的环境配置。 编译交叉工具链。 用编译好的交叉工具链，交叉编译基本工具，用于构建其他软件包。 进入 Chroot 环境，构建一些额外工具，用于后续构建和测试。 构建完整的 LFS 系统。 完成系统的基本设置。 配置内核和引导加载器。 收尾工作。  常见问题及个人理解 构建 LFS 系统的意义 如果是为了构建自己使用 Linux 系统，我真的不推荐 LFS，除非你有不得不用 LFS 系统的理由，不然用现成的 Linux 发行版比较靠谱。\n那么对于大部分人来说，构建 LFS 的意义肯定不是自己使用了，而是体验一步一步从源码构建的过程。这个过程，能让我们熟悉如何从源码安装软件包，了解一个系统包括哪些必要的组件，以及在一定程度上知晓它们的依赖关系。这对今后使用其他 Linux 发行版是有好处的，至少在一定程度上具备了从源码自己构建相关软件包的能力。\n当前，这一切的前提，是理解了构建 LFS 的大部分指令的含义，而不是复制粘贴完成构建。\n多次构建工具链的意义 这也是 LFS 作者重点讨论的内容。来看手册上描述的三个阶段：\n   阶段 Build Host Target 操作描述     1 pc pc lfs 在 pc 上使用 cc-pc 构建交叉编译器 cc1   2 pc lfs lfs 在 pc 上使用 cc1 构建 cc-lfs   3 lfs lfs lfs 在 lfs 上使用 cc-lfs 重新构建并测试它本身    根据官方手册，抛开用于验证的第三阶段，我们构建了两遍工具链，不妨来反向思考这个问题。\n最终我们希望用工具链 cc-lfs 来构建完整的 LFS 系统，所以我们需要构建 cc-lfs。\n现在我们需要在宿主机上构建 cc-lfs，如果直接用宿主机自带的 cc-pc，那么构建的 cc-lfs 将依赖于我们的宿主系统，这显然不是我们想要的结果，所以必须使用交叉编译工具链 cc1 来避免这种依赖，这就是第二遍构建——用 cc1 构建 cc-lfs。\n现在要在宿主机上构建交叉编译工具链 cc1，自然是使用宿主机自带的工具链 cc-pc，这就是第一次构建——用 cc-pc 构建交叉编译器 cc1。\n多次切换环境的意义 在构建 LFS 的过程中，我们进行了多次环境的切换，下面列出所有可能的环境切换：\n 从普通用户切换到 root 用户。 从 root 用户切换到 lfs 用户。 从 lfs 用户返回到 root 用户。 从 root 用户切换到 Chroot 环境。 从 Chroot 环境返回到 root 用户。 从 root 用户返回到普通用户。  第一次切换和第六次对应，是为了用 root 权限执行一些指令。\n第二次切换和第三次切换对应，这个切换不是强制要求的，因为用 root 权限进行操作存在较大风险，所以通过切换到 lfs 用户来降低这种风险，同时创建一个新用户也能更容易地建立干净的工作环境。\n第四次切换和第五次切换对应，因为我们希望在一个与宿主机隔离的环境中构建 LFS，确保尽可能不受宿主系统影响，所以进入了 Chroot 这个临时环境。\n工具链编译顺序的问题 这部分内容 LFS 作者给出了完整的介绍，简单概括如下：\n 我们首先安装 Binutils。这是由于 GCC 和 Glibc 的 configure 脚本首先测试汇编器和链接器的一些特性，以决定启用或\u0026gt;禁用一些软件特性。\n下一步安装 GCC。\n下一步安装“净化的” (sanitized) Linux API 头文件。这允许 C 标准库 (Glibc) 与 Linux 内核提供的各种特性交互。\n下一步安装 Glibc。在构建 Glibc 时需要着重考虑编译器，二进制工具，以及内核头文件。\n接下来构建 C++ 标准库，然后是第 6 章中那些需要自身才能构建的程序后。\n在第 6 章一节的末尾，构建 lfs 本地编译器。首先使用和其他程序相同的 DESTDIR 第二次构建 binutils，然后第二次\u0026gt; 构建 GCC，构建时忽略 libstdc++ 和其他不重要的库。\n在第 7 章中，进入 chroot 环境后，首先安装 libstdc++。之后临时性地安装工具链的正常工作所必须的程序。还要构建测试其他程序时必须的程序。此后，核心工具链成为自包含的本地工具链。在第 8 章中，构建、测试并最后一次安装所有软件包，它们组成功能完整的系统。\n 自动构建 LFS 官方的 ALFS 项目，是利用 shell 或 Python 脚本解析 LFS 手册的 XML 代码，生成相应的构建脚本完成全自动构建。但这个项目似乎很久没人维护了，目前依然停留在较早版本。这是一个非常智能的构建脚本，但技术要求相对较高。\n本人基于官方手册，抱着写着玩的心态，写了一个自动构建 LFS 的项目，该项目使用 shell 脚本编写，可以自动构建 LFS systemd 10.0 到一个虚拟磁盘文件，项目地址如下：https://github.com/FreeFlyingSheep/lfs。\n原本准备用 Python 重构一个脚本，但感觉实际意义不大，又耗时，就鸽了……\n","permalink":"https://freeflyingsheep.github.io/posts/linux/lfs/","summary":"\u003cp\u003e根据《\u003ca href=\"https://bf.mengyan1223.wang/lfs/zh_CN/10.0-systemd/\"\u003eLinux From Scratch 版本 20200901-systemd，中文翻译版\u003c/a\u003e》构建 \u003ccode\u003eLFS systemd 10.0\u003c/code\u003e 的归纳总结。\u003c/p\u003e","title":"构建 LFS 系统"},{"content":"查看 Linux 发行版和内核版本的多种方式。\nLinux 发行版 以下指令均能查看 Linux 发行版信息：\n1 2 3  uname -a cat /etc/os-release cat /etc/lsb-release   其中，/etc/lsb-release 仅推荐在 /etc/os-release 不存在的时候访问。\nLinux 内核 以下指令均能查看 Linux 内核信息：\n1 2  uname -a cat /proc/version   其中，# 后面的数字代表编译次数。如果是手动编译的内核，它应该与源码目录下的 .version 文件保持一致。同时，顶层 Makefile 的前几行代表内核版本信息。\n","permalink":"https://freeflyingsheep.github.io/posts/tips/linux-version/","summary":"\u003cp\u003e查看 Linux 发行版和内核版本的多种方式。\u003c/p\u003e","title":"查看 Linux 版本"},{"content":"通过重定向让 shell 切换环境后继续执行。\n用途 在执行 su、exec 或者 chroot 之类的指令后，继续执行想要的命令，主要是在尝试写自动构建 LFS 的时候遇到的。\n实例 su 1 2 3  su - lfs \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; \u0026lt;command\u0026gt; EOF   exec 1 2 3 4 5 6  exec /bin/bash -c \u0026#34;\u0026lt;command\u0026gt;\u0026#34; exec /bin/bash \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; \u0026lt;command\u0026gt; EOF   chroot 1 2 3 4 5  chroot /mnt/lfs /bin/bash -c \u0026#34;\u0026lt;command\u0026gt;\u0026#34; chroot /mnt/lfs /bin/bash \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; \u0026lt;command\u0026gt; EOF   ","permalink":"https://freeflyingsheep.github.io/posts/tips/shell-redirect/","summary":"\u003cp\u003e通过重定向让 shell 切换环境后继续执行。\u003c/p\u003e","title":"shell 重定向小技巧"},{"content":"根据 GCC CPP 在线文档的 Macro Pitfalls 章节整理。\ndo ... while(0) do ... while(0) 的实例 在内核中经常包括以下种类的宏：\n1 2 3 4 5 6  #define ELF_PLAT_INIT(_r, load_addr) \\ do { \\ _r-\u0026gt;bx = 0; _r-\u0026gt;cx = 0; _r-\u0026gt;dx = 0; \\ _r-\u0026gt;si = 0; _r-\u0026gt;di = 0; _r-\u0026gt;bp = 0; \\ _r-\u0026gt;ax = 0; \\ } while (0)   do ... while(0) 的作用 如果把上面的宏用于 if 语句或类似的语言要素，比如：\n1 2  if (...) ELF_PLAT_INIT(...);   此时如果不使用 do ... while(0) 来封装，就会出现问题，只有宏的第一行是归入 if 语句体的，这显然不是我们期望的结果。\n使用 do ... while(0) 封装，就可以避免这种问题，保证宏的所有内容都被归于 if 语句体，而多余的循环语句也会被编译器自动优化掉。\n补充：那么，能不能直接写成如下形式呢：\n1 2 3 4 5 6  #define ELF_PLAT_INIT(_r, load_addr) \\ { \\ _r-\u0026gt;bx = 0; _r-\u0026gt;cx = 0; _r-\u0026gt;dx = 0; \\ _r-\u0026gt;si = 0; _r-\u0026gt;di = 0; _r-\u0026gt;bp = 0; \\ _r-\u0026gt;ax = 0; \\ }   乍一看似乎没问题，考虑下面的用法：\n1 2 3 4  if (...) ELF_PLAT_INIT(...); else ...   这将被扩展成如下形式：\n1 2 3 4 5 6 7  if (...) { _r-\u0026gt;bx = 0; _r-\u0026gt;cx = 0; _r-\u0026gt;dx = 0; _r-\u0026gt;si = 0; _r-\u0026gt;di = 0; _r-\u0026gt;bp = 0; _r-\u0026gt;ax = 0; }; else ...   我们注意到大括号后面多了个分号，导致 else 悬空了，所以省掉 do ... while(0) 是不行的。\n({ … }) ({ … }) 的实例 1 2 3 4  #define min(X, Y) \\ ({ typeof (X) x_ = (X); \\ typeof (Y) y_ = (Y); \\ (x_ \u0026lt; y_) ? x_ : y_; })   ({ … }) 的作用 按照常规写法，我们会如此定义求最小值的宏：\n1  #define min(X, Y) ((X) \u0026lt; (Y) ? (X) : (Y))   但当我们把具有副作用的表达式作为参数时，如 next = min (x + y, foo (z));，该代码会被扩展为 next = ((x + y) \u0026lt; (foo (z)) ? (x + y) : (foo (z)));，表达式 x + y 或 foo(z) 将被执行两遍，这显然不是我们希望的。\n标准 C 中没有办法能解决这个问题（硬要说的话，要么小心地使用这些宏，要么采用内联函数）。\nGCC 扩展语法提供了 ({ … }) 来生成一个用作表达式的复合语句，其值是最后一个语句的值。这允许我们在其中定义局部变量，把参数赋值给局部变量来保证它们只被计算一次，正如实例中的 min 宏。注意，局部变量的名称后面带有下划线，是为了以减少与其他变量发生冲突的可能性，但这是无法避免的。\n自引用的宏（Self-Referential Macros） 自引用的宏简介 一个自引用的宏是名字出现在其定义中的宏。\n为了避免无限的展开，自引用的宏只会被扩展一次，举个例子：\n1  #define foo (4 + foo)   在代码中用到的 foo 只会被扩展为 (4 + foo)，而不会再被扩展为 (4 + (4 + foo))。\n自引用的宏的实例 在代码中，经常看到在枚举类型中穿插自引用的宏定义，比如 /usr/include/dirent.h 头文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /* File types for `d_type\u0026#39;. */ enum { DT_UNKNOWN = 0, # define DT_UNKNOWN DT_UNKNOWN  DT_FIFO = 1, # define DT_FIFO DT_FIFO  DT_CHR = 2, # define DT_CHR DT_CHR  DT_DIR = 4, # define DT_DIR DT_DIR  DT_BLK = 6, # define DT_BLK DT_BLK  DT_REG = 8, # define DT_REG DT_REG  DT_LNK = 10, # define DT_LNK DT_LNK  DT_SOCK = 12, # define DT_SOCK DT_SOCK  DT_WHT = 14 # define DT_WHT DT_WHT };   自引用的宏的作用 根据官方文档，此处自引用的作用是对于用 enum 定义的数字常量，也可以使用 #ifdef 进行预处理。\n根据 Stack Overflow 上相关提问的回答，这可能是一个历史遗漏问题，原本的代码采用 #define 定义常量，而后续改用 enum 定义，为了与先前的代码兼容，额外使用自引用的宏，我倾向于这种观点。\n参数预扫描 参数预扫描介绍 除非将宏的参数是一个字符串化的（如 #x）或被连接到其他标记上（如 x##y），否则它们在被替换为宏主体之前必须经过完整的扩展。替换后，预处理器将再次扫描整个宏主体（包括替换的参数），以进一步扩展。\n特别地，对于自引用的宏，若它在第一次扫描中不被扩展，那么在第二次扫描中它也不会被扩展。\n可以简单地把参数预扫描理解为先扩展宏的参数（第一次扫描），再扩展宏本身（第二次扫描），如果宏的主体包含 # 或 ##，则不扩展参数。\n参数预扫描的实例 Linux 2.6.34 内核中的 include/linux/compiler-gcc.h 文件中包含如下的代码，可以根据 GCC 版本导入相应的头文件：\n1 2 3 4  #define __gcc_header(x) #x #define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h) #define gcc_header(x) _gcc_header(x) #include gcc_header(__GNUC__)  若使用 GCC 4.x 版本编译这段代码，最终会生成 #include \u0026quot;linux/compiler-gcc4.h\u0026quot;（4 由 __GNUC__ 提供，这是 GCC 的预定义宏，代表 GCC 主版本号），以下是扩展的步骤：\n 第一次扫描 gcc_header(__GNUC__)，扩展为 gcc_header(4)。 第二次扫描 gcc_header(4)，扩展为 _gcc_header(4)。 第一次扫描 _gcc_header(4)，发现 ##，不扩展。 第二次扫描 _gcc_header(4)，扩展为 __gcc_header(linux/compiler-gcc4.h)。 第一次扫描 __gcc_header(linux/compiler-gcc4.h)，发现 #，不扩展 第二次扫描__gcc_header(linux/compiler-gcc4.h)，扩展为 \u0026quot;linux/compiler-gcc4.h\u0026quot;。  注意，_gcc_header 宏是必要的，考虑下面的写法：\n1 2 3  #define __gcc_header(x) #x #define gcc_header(x) __gcc_header(linux/compiler-gcc##x.h) #include gcc_header(__GNUC__)  这段代码最终会生成 #include \u0026quot;linux/compiler-gcc__GNUC__.h\u0026quot;，以下是扩展的步骤：\n 第一次扫描 gcc_header(__GNUC__)，发现 ##，不扩展。 第二次扫描 gcc_header(__GNUC__)，扩展为 __gcc_header(linux/compiler-gcc__GNUC__.h)。 第一次扫描 __gcc_header(linux/compiler-gcc__GNUC__.h)，发现 #，不扩展。 第二次扫描 __gcc_header(linux/compiler-gcc__GNUC__.h)，扩展为 \u0026quot;linux/compiler-gcc__GNUC__.h\u0026quot;。 ","permalink":"https://freeflyingsheep.github.io/posts/kernel/miscellaneous/macros-pitfalls/","summary":"\u003cp\u003e根据 GCC CPP 在线文档的 \u003ca href=\"https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html#Macro-Pitfalls\"\u003eMacro Pitfalls\u003c/a\u003e 章节整理。\u003c/p\u003e","title":"宏的陷阱和使用技巧"},{"content":"整理使用 Git 打补丁的方法，补充一些常用指令，并给出一个 Git 命令的综合应用实例。\n导出补丁 git diff 1  git diff \u0026lt;branch1\u0026gt;[:\u0026lt;file1\u0026gt;] \u0026lt;branch2\u0026gt;[:\u0026lt;file2\u0026gt;] \u0026gt; \u0026lt;patch\u0026gt;   使用 git diff 导出的补丁，不包含提交（commit）信息。\ngit format-patch 导出单个补丁：\n1  git format-patch -1 \u0026lt;commit\u0026gt; [-o \u0026lt;dir\u0026gt;]   导出多个连续的补丁：\n1  git format-patch \u0026lt;commit1\u0026gt;[..\u0026lt;commit2\u0026gt;] [-o \u0026lt;dir\u0026gt;]   注意，导出的区间是 (commit1, commit2]。\n使用 git format-patch 导出的补丁，默认包含提交信息。\n应用补丁 git apply 直接应用补丁：\n1  git apply \u0026lt;patch\u0026gt;   不应用补丁，而是检查补丁能否被直接应用：\n1  git apply --check \u0026lt;patch\u0026gt;   强制应用补丁，遇到冲突会生成 .rej 文件：\n1  git apply --reject \u0026lt;patch\u0026gt;   git am 1  git am \u0026lt;patch\u0026gt; ...   在遇到冲突时，可以使用如下方法处理：\n git am --skip：跳过当前补丁。 git am --abort：终止打补丁并恢复打补丁前的状态。注意，如果应用了多个补丁，会直接恢复到最初状态，而不是仅终止当前的补丁。 git am --continue：手动解决冲突后，继续下一个补丁。  其他指令 清理未跟踪的文件 可以先执行以下命令查看要被清理的文件：\n1  git clean -n   然后执行以下命令清理未跟踪的文件：\n1  git clean -f   撤销提交 有时我们需要取消某次具体的提交，这次提交与当前头指针可能已经相隔了多次提交，因此我们不方便直接用 git reset 回滚，此时可以使用如下命令撤销单次提交：\n1  git revert \u0026lt;commit\u0026gt;   也可以使用如下命令撤销一系列连续的提交：\n1  git revert \u0026lt;commit1\u0026gt;..\u0026lt;commit2\u0026gt;   注意撤销范围是 (\u0026lt;commit1\u0026gt;, \u0026lt;commit2\u0026gt;]。\nGit 命令的综合应用实例 简介 现在有一个练手任务：在龙芯上移植 3.16.85 版本的内核到 3.17.0 版本。\n有一个修改过的 linux 内核，其中 linux-3.16 分支由于已经加入了补丁，所以能在龙芯机器上运行，现在需要把该分支从 3.16.85 版本开始的补丁，应用到 3.17.0 版本上，最终让 3.17.0 版本也能在龙芯机器上运行。\n获取项目 首先，从指定地址克隆项目（修改过的 linux 内核）。\n1  git clone ...   查看分支 使用 git branch 查看分支：\n1 2 3  $ git branch linux-3.16 * master   发现默认分支是 master。\n切换分支 需要先切换到 linux-3.16 分支：\n1  git checkout linux-3.16   查看提交信息 查看提交信息，确定从哪个提交开始导出补丁：\n1 2 3 4 5  $ git log --oneline ... a804eddbca6c MIPS: Fix restart of indirect syscalls 8ac8e9653550 Sync code to Linux-3.16.85 from upstream 19583ca584d6 (tag: v3.16) Linux 3.16   3.16.85 版本对应的提交的哈希值是 8ac8e9653550。\n导出相应补丁 把从 8ac8e9653550 开始（不包括 8ac8e9653550）的提交以补丁形式导出到上级目录的 patch 文件夹。\n1  git format-patch 8ac8e965355 -o ../patch   查看标签 之前使用 git branch 发现项目并不包含 linux-3.17 分支，使用 git tag 查看标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13  $ git tag ... v3.16 v3.16-rc1 v3.16-rc2 v3.16-rc3 v3.16-rc4 v3.16-rc5 v3.16-rc6 v3.16-rc7 v3.17 v3.17-rc1 ...   v3.17 标签就对应需要的 3.17.0 版本。\n创建并切换分支 从 v3.17 标签创建新分支 linux-3.17，并切换到该分支：\n1  git checkout -b linux-3.17 v3.17   应用相应补丁 1  git am ../patch/*   跳过不需要的补丁 1  git am --skip   手动解决冲突 对于小补丁，直接看补丁文件，修改相应内容即可。\n对于大补丁，我采用如下思路解决冲突：\n 使用 git apply --reject \u0026lt;patch\u0026gt; 强制打上补丁。 根据 .rej 文件修改相应内容。 删除 .rej 文件。 使用 git am --continue 继续下一个补丁。  其他补丁 在移植过程中，发现有些编译问题已经被其他人解决，可以直接导入相关补丁。\n此时使用 git diff 导出补丁，然后用 git apply 应用，手动解决冲突。\n","permalink":"https://freeflyingsheep.github.io/posts/git/patch/","summary":"\u003cp\u003e整理使用 Git 打补丁的方法，补充一些常用指令，并给出一个 Git 命令的综合应用实例。\u003c/p\u003e","title":"Git 打补丁"},{"content":"Linux 内核学习笔记系列，内存管理部分，内存管理的一些补充说明。\n分配函数的选择 如果需要连续的物理页，可以使用某个低级页分配器（分区页框分配器里请求页框和释放页框的函数/宏）或 kmalloc() 函数。\n对于中断处理程序和其他不能睡眠的代码段，使用 GFP_ATOMIC 表示不进行睡眠的高优先级分配。\n对于可以睡眠的代码，使用 GFP_KERNEL 表示如果有必要可以进行睡眠。\n如果想从高端内存进行分配，可以使用 alloc_pages() 函数。 该函数返回一个指向 struct page 结构的指针，而不是一个指向某个逻辑地址的指针。因为高端内存很可能没有被映射，要获得真正的指针，需要调用 kmap() 函数把高端内存映射到内核的逻辑地址空间。\n如果不需要物理上连续的页，而仅仅需要虚拟地址上连续的页，可以使用 vmalloc() 函数（但该函数相对 kmalloc() 有一定的性能损失）。\n如果要创建和撤销很多大的数据结构，可以考虑建立 slab 高速缓存。\nvmalloc() 和 kmalloc() vmalloc() 为了把物理上不连续的页转换为虚拟地址空间上连续的页，必须专门建立页表项，而且因为它们物理上是不连续的，所以必须一个一个进行映射，这会导致比直接内存映射大得多的 TLB 抖动。\n尽管在某些情况下才需要物理上的连续内存块，但出于性能的考虑，很多内核代码都使用 kmalloc()。除非在不得已时才使用 vmalloc()，比如动态装载模块时，需要获得大块内存。\nslub 分配器 slub 分配器逐渐取代了 slab 分配器，成为默认的内存分配器。\nslub 分配器在 2.6.22 版本引入，它具有设计简单、代码精简、额外内存占用率小、扩展性高，性能优秀、方便调试等很多优点。\n内存管理相关函数调用关系 分配连续内存的函数调用关系大致如下：\n释放连续内存的函数调用关系大致如下：\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/supplement/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，内存管理的一些补充说明。\u003c/p\u003e","title":"内存管理补充"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍连续页框的管理。\n分区页框分配器 请求页框的标志 include/linux/gfp.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  /* * GFP bitmasks.. */ /* Zone modifiers in GFP_ZONEMASK (see linux/mmzone.h - low two bits) */ #define __GFP_DMA 0x01 #define __GFP_HIGHMEM 0x02  /* * Action modifiers - doesn\u0026#39;t change the zoning * * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt * _might_ fail. This depends upon the particular VM implementation. * * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller * cannot handle allocation failures. * * __GFP_NORETRY: The VM implementation must not retry indefinitely. */ #define __GFP_WAIT 0x10 /* Can wait and reschedule? */#define __GFP_HIGH 0x20 /* Should access emergency pools? */#define __GFP_IO 0x40 /* Can start physical IO? */#define __GFP_FS 0x80 /* Can call down to low-level FS? */#define __GFP_COLD 0x100 /* Cache-cold page required */#define __GFP_NOWARN 0x200 /* Suppress page allocation failure warning */#define __GFP_REPEAT 0x400 /* Retry the allocation. Might fail */#define __GFP_NOFAIL 0x800 /* Retry for ever. Cannot fail */#define __GFP_NORETRY 0x1000 /* Do not retry. Might fail */#define __GFP_NO_GROW 0x2000 /* Slab internal usage */#define __GFP_COMP 0x4000 /* Add compound page metadata */#define __GFP_ZERO 0x8000 /* Return zeroed page on success */ #define __GFP_BITS_SHIFT 16 /* Room for 16 __GFP_FOO bits */#define __GFP_BITS_MASK ((1 \u0026lt;\u0026lt; __GFP_BITS_SHIFT) - 1)  /* if you forget to add the bitmask here kernel will crash, period */ #define GFP_LEVEL_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_FS| \\ __GFP_COLD|__GFP_NOWARN|__GFP_REPEAT| \\ __GFP_NOFAIL|__GFP_NORETRY|__GFP_NO_GROW|__GFP_COMP)  #define GFP_ATOMIC (__GFP_HIGH) #define GFP_NOIO (__GFP_WAIT) #define GFP_NOFS (__GFP_WAIT | __GFP_IO) #define GFP_KERNEL (__GFP_WAIT | __GFP_IO | __GFP_FS) #define GFP_USER (__GFP_WAIT | __GFP_IO | __GFP_FS) #define GFP_HIGHUSER (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HIGHMEM)  /* Flag - indicates that the buffer will be suitable for DMA. Ignored on some platforms, used as appropriate on others */ #define GFP_DMA __GFP_DMA   请求页框    函数 功能     alloc_pages(gfp_mask, order) 请求 $2^{order}$ 个连续的页框，成功则返回分配的第一个页框描述符的地址，失败则返回 NULL。   alloc_page(gfp_mask) 请求一个单独的页框，成功则返回分配的第一个页框描述符的地址，失败则返回 NULL。   __get_free_pages(gfp_mask, order) 请求 $2^{order}$ 个连续的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。   __get_free_page(gfp_mask) 请求一个单独的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。   get_zeroed_page(gfp_mask) 请求一个填满 0 的单独的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。   __get_dma_pages(gfp_mask, order) 请求 $2^{order}$ 个适用于 DMA 的页框，成功则返回分配的第一个页框的线性地址，失败则返回 0。    include/linux/gfp.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  static inline struct page *alloc_pages_node(int nid, unsigned int gfp_mask, unsigned int order) { if (unlikely(order \u0026gt;= MAX_ORDER)) return NULL; return __alloc_pages(gfp_mask, order, NODE_DATA(nid)-\u0026gt;node_zonelists + (gfp_mask \u0026amp; GFP_ZONEMASK)); } #ifdef CONFIG_NUMA extern struct page *alloc_pages_current(unsigned gfp_mask, unsigned order); static inline struct page * alloc_pages(unsigned int gfp_mask, unsigned int order) { if (unlikely(order \u0026gt;= MAX_ORDER)) return NULL; return alloc_pages_current(gfp_mask, order); } #else #define alloc_pages(gfp_mask, order) \\ alloc_pages_node(numa_node_id(), gfp_mask, order) #endif #define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)  extern unsigned long FASTCALL(__get_free_pages(unsigned int gfp_mask, unsigned int order)); extern unsigned long FASTCALL(get_zeroed_page(unsigned int gfp_mask)); #define __get_free_page(gfp_mask) \\ __get_free_pages((gfp_mask),0)  #define __get_dma_pages(gfp_mask, order) \\ __get_free_pages((gfp_mask) | GFP_DMA,(order))   mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /* * Common helper functions. */ fastcall unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order) { struct page * page; page = alloc_pages(gfp_mask, order); if (!page) return 0; return (unsigned long) page_address(page); } EXPORT_SYMBOL(__get_free_pages); fastcall unsigned long get_zeroed_page(unsigned int gfp_mask) { struct page * page; /* * get_zeroed_page() returns a 32-bit address, which cannot represent * a highmem page */ BUG_ON(gfp_mask \u0026amp; __GFP_HIGHMEM); page = alloc_pages(gfp_mask | __GFP_ZERO, 0); if (page) return (unsigned long) page_address(page); return 0; } EXPORT_SYMBOL(get_zeroed_page);   mm/mempolicy.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * alloc_pages_current - Allocate pages. * * @gfp: * %GFP_USER user allocation, * %GFP_KERNEL kernel allocation, * %GFP_HIGHMEM highmem allocation, * %GFP_FS don\u0026#39;t call back into a file system. * %GFP_ATOMIC don\u0026#39;t sleep. * @order: Power of two of allocation size in pages. 0 is a single page. * * Allocate a page from the kernel page pool. When not in * interrupt context and apply the current process NUMA policy. * Returns NULL when no page can be allocated. */ struct page *alloc_pages_current(unsigned gfp, unsigned order) { struct mempolicy *pol = current-\u0026gt;mempolicy; if (!pol || in_interrupt()) pol = \u0026amp;default_policy; if (pol-\u0026gt;policy == MPOL_INTERLEAVE) return alloc_page_interleave(gfp, order, interleave_nodes(pol)); return __alloc_pages(gfp, order, zonelist_policy(gfp, pol)); } EXPORT_SYMBOL(alloc_pages_current);   __alloc_pages() 函数见 __alloc_pages() 函数。\n释放页框    函数 功能     __free_pages(page, order) 检查 page 指向的页描述符，若该页框未被保留 (PG_reserved 标志为 0)，就把 count 减一。如果 count 为 0，就释放页框。   free_pages(addr, order) 接受页框的线性地址而不是页描述符，其余和 __free_pages(page, order) 相同   __free_page(page) __free_pages(page, 0)   free_page(addr) free_pages(addr, 0)    include/linux/gfp.h：\n1 2 3 4 5 6 7  extern void FASTCALL(__free_pages(struct page *page, unsigned int order)); extern void FASTCALL(free_pages(unsigned long addr, unsigned int order)); extern void FASTCALL(free_hot_page(struct page *page)); extern void FASTCALL(free_cold_page(struct page *page)); #define __free_page(page) __free_pages((page), 0) #define free_page(addr) free_pages((addr),0)   mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9  fastcall void free_pages(unsigned long addr, unsigned int order) { if (addr != 0) { BUG_ON(!virt_addr_valid((void *)addr)); __free_pages(virt_to_page((void *)addr), order); } } EXPORT_SYMBOL(free_pages);   __free_pages() 函数见释放内存。\n很多函数涉及伙伴系统和 per-CPU 页框高速缓存，这里就不展开了。\n管理区分配器简介 管理区分配器是内核页框分配器的前端。\n整个连续内存分配涉及的内容大致如下：\n管理区分配器必须分配一个包含足够多空闲页框的内存区，来满足内存请求，它得满足如下目标：\n 保护保留的页框池。 当内存不足且允许阻塞当前进程时，应当触发页框回收算法，一旦某些页框被释放，将再次尝试分配。 如果可能，应当保存小而珍贵的 ZONE_DMA 内存管理区。例如，如果是对 ZONE_NORMAL 或 ZONE_HIGHMEM 页框的请求，尽可能不分配 ZONE_DMA 内存管理区中的页框。  保留的页框池 在请求内存时，一些内核控制路径不能被阻塞，如处理中断或执行临界区内的代码时。在这些情况下，一条控制路径应当产生原子内存分配请求 (设置 GFP_ATOMIC 标志)。原子请求从不被阻塞，如果没有足够空闲页，仅返回失败。\n尽管无法保证原子内存分配请求不失败，但内核会设法尽量减少这种不幸事件发生的可能性。因此，内核为原子内存分配请求保留了一个页框池，只有在内存不足时才使用。\n保留内存的数量（以 KB 为单位）存放在 min_free_kbytes 变量中。管理区描述符的部分字段都会在 mim_free_kbytes 初始化时一起完成初始化（init_per_zone_pages_min() 函数调用 setup_per_zone_pages_min() 函数和 setup_per_zone_lowmem_reserve() 函数，这些函数都位于 mm/page_alloc.c）。\n pages_min：管理区中保留页的数目，被设置为 $\\lfloor \\sqrt{16 \\times 直接映射内存的大小} \\rfloor$。 pages_low：回收页框使用的下界，被设置为 pages_min 的 $\\frac{5}{4}$。 pages_high：回收页框使用的上界，被设置为 pages_min 的 $\\frac{3}{2}$。 lowmem_reserve：每个管理区必须保留的页框数目，例子代码注释中有，见下。  1 2 3 4 5 6 7 8  /* * results with 256, 32 in the lowmem_reserve sysctl: * 1G machine -\u0026gt; (16M dma, 800M-16M normal, 1G-800M high) * 1G machine -\u0026gt; (16M dma, 784M normal, 224M high) * NORMAL allocation will leave 784M/256 of ram reserved in the ZONE_DMA * HIGHMEM allocation will leave 224M/32 of ram reserved in ZONE_NORMAL * HIGHMEM allocation will (224M+784M)/256 of ram reserved in ZONE_DMA */   分配内存 zone_watermark_ok() 函数 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* * Return 1 if free pages are above \u0026#39;mark\u0026#39;. This takes into account the order * of the allocation. */ int zone_watermark_ok(struct zone *z, int order, unsigned long mark, int classzone_idx, int can_try_harder, int gfp_high) { /* free_pages my go negative - that\u0026#39;s OK */ long min = mark, free_pages = z-\u0026gt;free_pages - (1 \u0026lt;\u0026lt; order) + 1; int o; if (gfp_high) min -= min / 2; if (can_try_harder) min -= min / 4; if (free_pages \u0026lt;= min + z-\u0026gt;lowmem_reserve[classzone_idx]) return 0; for (o = 0; o \u0026lt; order; o++) { /* At the next order, this order\u0026#39;s pages become unavailable */ free_pages -= z-\u0026gt;free_area[o].nr_free \u0026lt;\u0026lt; o; /* Require fewer higher order pages to be free */ min \u0026gt;\u0026gt;= 1; if (free_pages \u0026lt;= min) return 0; } return 1; }   zone_watermark_ok() 是一个辅助函数，在满足如下两个条件时返回 1：\n 除了被分配的页框外，内存管理区中至少还有 min 个空闲页框（不包括保留的页框）。 除了被分配的页框外，在 order 至少为 o 的块中，有大于等于 min / $2^{o}$ 个空闲页框。  阈值 min 的值由 mask. can_try_harder 和 gfp_high 确定：\n mask 可能是 pages_min. pages_low 和 pages_high 中的一个。 若 gfp_high 被置位，把么把 mask 除以 2。 这种情况通常发生在 __GFP_WAIT 标志被置位时，即能从高端内存分配页框。 若 can_try_harder被置位，那么把 mask 再除以 4。 这种情况通常发生在 __GFP_WAIT 标志被置位时，或者当前进程是一个位于进程上下文中（不在中断处理程序和可延迟函数中）且已经完成内存分配的实时进程。  __alloc_pages() 函数 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11  /* * This is the \u0026#39;heart\u0026#39; of the zoned buddy allocator. */ struct page * fastcall __alloc_pages(unsigned int gfp_mask, unsigned int order, struct zonelist *zonelist) { ... // 详细流程见下 } EXPORT_SYMBOL(__alloc_pages);   该函数的详细流程是：\n  准备工作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const int wait = gfp_mask \u0026amp; __GFP_WAIT; struct zone **zones, *z; struct page *page; struct reclaim_state reclaim_state; struct task_struct *p = current; int i; int classzone_idx; int do_retry; int can_try_harder; int did_some_progress; might_sleep_if(wait); /* * The caller may dip into page reserves a bit more if the caller * cannot run direct reclaim, or is the caller has realtime scheduling * policy */ can_try_harder = (unlikely(rt_task(p)) \u0026amp;\u0026amp; !in_interrupt()) || !wait; zones = zonelist-\u0026gt;zones; /* the list of zones suitable for gfp_mask */ if (unlikely(zones[0] == NULL)) { /* Should this ever happen?? */ return NULL; } classzone_idx = zone_idx(zones[0]);     第一次遍历存放管理区的数组（zonelist），寻找有足够空闲内存的管理区。若能满足请求，跳转到第 15 步。\n1 2 3 4 5 6 7 8 9 10 11 12  restart: /* Go through the zonelist once, looking for a zone with enough free */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-\u0026gt;pages_low, classzone_idx, 0, 0)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; }     来到这里，说明没足够的空闲内存。触发页框回收算法，这部分内容属于《深入理解 Linux 内核》中“回收页框”章节，这里不展开。\n1 2  for (i = 0; (z = zones[i]) != NULL; i++) wakeup_kswapd(z, order);     第二次遍历存放管理区的数组，但使用了较低的阈值（注意传递给 zone_watermark_ok() 的参数不同）。若能满足请求，跳转到第 15 步。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * Go through the zonelist again. Let __GFP_HIGH and allocations * coming from realtime tasks to go deeper into reserves */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-\u0026gt;pages_min, classzone_idx, can_try_harder, gfp_mask \u0026amp; __GFP_HIGH)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; }     来到这里，说明系统没足够内存。如果内存分配请求的内核路径不是一个中断处理程序或一个可延迟函数，并且试图回收页框（PF_MEMALLOC 或 TIF_MEMDIE 标志被置位），那么进行第三次遍历，这次忽略阈值（不调用 zone_watermark_ok()）。这种情况下，允许内核控制路径耗用为内存不足预留的页（保留的页框池）。其实，PF_MEMALLOC 表示该进程当前正在执行“内存规整（memory compaction）”或“直接回收（direct reclaim）”，而 TIF_MEMDIE 则表示该进程已经触发了内存不足清理（out-of-memory killer）并且正在尝试退出，以上这些操作都可能导致更多的内存页框被释放，因此只要有可能，请求就被满足。若能满足请求，跳转到第 15 步；反之，跳转到第 14 步。\n1 2 3 4 5 6 7 8 9 10  /* This allocation should allow future memory freeing. */ if (((p-\u0026gt;flags \u0026amp; PF_MEMALLOC) || unlikely(test_thread_flag(TIF_MEMDIE))) \u0026amp;\u0026amp; !in_interrupt()) { /* go through the zonelist yet again, ignoring mins */ for (i = 0; (z = zones[i]) != NULL; i++) { page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; } goto nopage; }     来到这里，必须阻塞当前进程才能满足请求（__GFP_WAIT 需要被置位）。否则，跳转到第 14 步。\n1 2 3  /* Atomic allocations - we can\u0026#39;t balance anything */ if (!wait) goto nopage;     来到这里，说明进程能够被阻塞，调用 cond_resched() 检查是否有其它进程需要 CPU。\n1 2  rebalance: cond_resched();     设置 PF_MEMALLOC 标志，表示进程已经准备好执行内存回收。\n1 2  /* We now go into synchronous reclaim */ p-\u0026gt;flags |= PF_MEMALLOC;     将 reclaim_state 存入 current-\u0026gt;reclaim_state。\n1 2  reclaim_state.reclaimed_slab = 0; p-\u0026gt;reclaim_state = \u0026amp;reclaim_state;     调用 try_to_free_pages() 来回收页框，这部分内容属于《深入理解 Linux 内核》中“回收页框”章节，这里不展开。该函数可能阻塞当前进程，一旦函数返回，重设 PF_MEMALLOC 标志并再次调用 cond_resched()。\n1 2 3 4 5 6  did_some_progress = try_to_free_pages(zones, gfp_mask, order); p-\u0026gt;reclaim_state = NULL; p-\u0026gt;flags \u0026amp;= ~PF_MEMALLOC; cond_resched();     如果已经释放了一些页框，那么按第 4 步的方式再次遍历存放内存管理区的数组。若能满足请求，跳转到第 15 步。如果分配请求不能被满足，__GFP_NORETRY（分配失败时不重复分配）被清除且 __GFP_FS（可以启动文件系统 I/O）被置位，那么再次遍历存放内存管理区的数组（注意传递给 zone_watermark_ok() 的参数不同）。若能满足请求，跳转到第 15 步；反之，说明内存耗尽，通过调用 out_of_memory()（该函数位于 mm/oom_kill.c）杀死一个进程，来保证系统不崩溃，然后转到第 2 步。这次遍历的阈值比之前的要高，因此很容易失败，只有在另一个内核控制路径已经通过杀死了一个进程来回收了它的内存的时候，才会成功，但这种情况下，确实避免了两个无辜的进程（而不是一个）被杀死。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  if (likely(did_some_progress)) { /* * Go through the zonelist yet one more time, keep * very high watermark here, this is only to catch * a parallel oom killing, we must fail if we\u0026#39;re still * under heavy pressure. */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-\u0026gt;pages_min, classzone_idx, can_try_harder, gfp_mask \u0026amp; __GFP_HIGH)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; } } else if ((gfp_mask \u0026amp; __GFP_FS) \u0026amp;\u0026amp; !(gfp_mask \u0026amp; __GFP_NORETRY)) { /* * Go through the zonelist yet one more time, keep * very high watermark here, this is only to catch * a parallel oom killing, we must fail if we\u0026#39;re still * under heavy pressure. */ for (i = 0; (z = zones[i]) != NULL; i++) { if (!zone_watermark_ok(z, order, z-\u0026gt;pages_high, classzone_idx, 0, 0)) continue; page = buffered_rmqueue(z, order, gfp_mask); if (page) goto got_pg; } out_of_memory(gfp_mask); goto restart; }     如果 order \u0026lt;= 3（和具体实现有关）或者 __GFP_REPEAT 被置位，设置 do_retry。如果 __GFP_NOFAIL 被置位，设置 do_retry。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * Don\u0026#39;t let big-order allocations loop unless the caller explicitly * requests that. Wait for some write requests to complete then retry. * * In this implementation, __GFP_REPEAT means __GFP_NOFAIL for order * \u0026lt;= 3, but that may not be true in other implementations. */ do_retry = 0; if (!(gfp_mask \u0026amp; __GFP_NORETRY)) { if ((order \u0026lt;= 3) || (gfp_mask \u0026amp; __GFP_REPEAT)) do_retry = 1; if (gfp_mask \u0026amp; __GFP_NOFAIL) do_retry = 1; }     如果 do_retry 被设置，调用 blk_congestion_wait() 使进程休眠一会（见 TODO），并跳转到第 7 步。\n1 2 3 4  if (do_retry) { blk_congestion_wait(WRITE, HZ/50); goto rebalance; }     来到这里，说明请求不能被满足，返回 NULL。\n1 2 3 4 5 6 7 8  nopage: if (!(gfp_mask \u0026amp; __GFP_NOWARN) \u0026amp;\u0026amp; printk_ratelimit()) { printk(KERN_WARNING \u0026#34;%s: page allocation failure.\u0026#34; \u0026#34; order:%d, mode:0x%x\\n\u0026#34;, p-\u0026gt;comm, order, gfp_mask); dump_stack(); } return NULL;     来到这里，说明请求能被满足，调用 zone_statistics() 完成一些数据统计工作 (主要针对 NUMA)，然后返回第一个被分配的页框的页描述符。\n1 2 3  got_pg: zone_statistics(zonelist, z); return page;     释放内存 __free_pages() 函数比较简单，直接贴代码。\nmm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  void __free_pages_ok(struct page *page, unsigned int order) { LIST_HEAD(list); int i; arch_free_page(page, order); mod_page_state(pgfree, 1 \u0026lt;\u0026lt; order); #ifndef CONFIG_MMU  if (order \u0026gt; 0) for (i = 1 ; i \u0026lt; (1 \u0026lt;\u0026lt; order) ; ++i) __put_page(page + i); #endif  for (i = 0 ; i \u0026lt; (1 \u0026lt;\u0026lt; order) ; ++i) free_pages_check(__FUNCTION__, page + i); list_add(\u0026amp;page-\u0026gt;lru, \u0026amp;list); kernel_map_pages(page, 1\u0026lt;\u0026lt;order, 0); free_pages_bulk(page_zone(page), 1, \u0026amp;list, order); } fastcall void __free_pages(struct page *page, unsigned int order) { if (!PageReserved(page) \u0026amp;\u0026amp; put_page_testzero(page)) { if (order == 0) free_hot_page(page); else __free_pages_ok(page, order); } } EXPORT_SYMBOL(__free_pages);   include/linux/mm.h：\n1 2 3 4 5 6 7 8 9  /* * Drop a ref, return true if the logical refcount fell to zero (the page has * no users) */ #define put_page_testzero(p) \\ ({ \\ BUG_ON(page_count(p) == 0); \\ atomic_add_negative(-1, \u0026amp;(p)-\u0026gt;_count); \\ })   很多函数涉及伙伴系统和 per-CPU 页框高速缓存，这里就不展开了。\n内存池 内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。\n注意内存池与保留的页框池（见保留的页框池）的区别。保留的页框池是用于满足中断处理程序或内部临界区发出的原子分配请求的；而内存池是动态内存的储备，只能被特定的内核成分（池的拥有者）使用。\n拥有者通常不使用内存池的储备（而是从普通内存中分配），如果动态内存变得极其稀有以至于所有普通内存分配请求都失败的话，那么内核成分就能调用特地的内存池函数提取储备得到所需的内存。当然，这已经是最后的解决手段了。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/continuous/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍连续页框的管理。\u003c/p\u003e","title":"连续页框的管理"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍 slab 分配器。\nslab 分配器简介 slab 分配器是为了解决内碎片问题而设计的。\nslab 分配器算法的前提  所存放数据的类型可以影响内存区的分配方式。slab 分配器概念扩充了这种思想，并把内存区看作对象（object），这些对象由一组数据结构和几个叫构造和析构的函数（方法）组成。前者初始化内存区，后者回收内存区。 内核函数倾向于反复请求同一类型的内存区。 对内存区的请求可以根据它们发生的频率分类。 在引入的对象大小不是几何分布（数据结构的起始物理地址不是 2 的幂（的情况下，可以借助处理器的硬件高速缓存。 硬件高速缓存的高性能会限制对伙伴系统分配器的调用，因为对伙伴系统的每次调用都“弄脏”硬件高速缓存，所以增加了内存的平均访问时间。内核函数对硬件高速缓存的影响就是所谓的函数“足迹（footprint）”，其定义为函数结束时重写硬件高速缓存的百分比。大“足迹”的函数的执行使硬件高速缓存填满了无用信息，导致之后执行代码的速度变慢。  slab 分配器算法的设计思想  频繁使用的数据结构也会频繁分配和释放，因此应当缓存它们。 频繁分配和回收必然会导致内存碎片（难以找到大块连续的可用内存）。空闲链表的缓存应该连续存放，因为已经释放的数据结构又会放回空闲链表，所以不会导致碎片。 回收的对象可以立即投入下一次分配，因此对于频繁的分配和释放，空闲链表能提高性能。 如果分配器知道对象的大小、页大小和总硬件高速缓存大小，它能做出更明智的决策。 如果让部分缓存专属于某个处理器，那么分配和释放就可以在不加 SMP 锁的情况下进行。 如果分配器是与 NUMA 相关的，它就可以从相同的内存结点为请求者进行分配。 对存放的对象进行着色（color），以防多个对象映射到相同的硬件高速缓存行（cache line）。  slab 分配器的组成 包含高速缓存（cache）的主内存区域被划分为多个 slab，每个 slab 由一个或多个连续的页框组成，这些页框既包含已分配的对象（object），也包含空闲的对象。\nslab 分配器相关的描述符 高速缓存描述符 include/linux/slab.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  /* * The slab lists of all objects. * Hopefully reduce the internal fragmentation * NUMA: The spinlock could be moved from the kmem_cache_t * into this structure, too. Figure out what causes * fewer cross-node spinlock operations. */ struct kmem_list3 { struct list_head slabs_partial; /* partial list first, better asm code */ struct list_head slabs_full; struct list_head slabs_free; unsigned long free_objects; int free_touched; unsigned long next_reap; struct array_cache *shared; }; /* * kmem_cache_t * * manages a cache. */ struct kmem_cache_s { /* 1) per-cpu data, touched during every alloc/free */ struct array_cache *array[NR_CPUS]; unsigned int batchcount; unsigned int limit; /* 2) touched by every alloc \u0026amp; free from the backend */ struct kmem_list3 lists; /* NUMA: kmem_3list_t *nodelists[MAX_NUMNODES] */ unsigned int objsize; unsigned int flags; /* constant flags */ unsigned int num; /* # of objs per slab */ unsigned int free_limit; /* upper limit of objects in the lists */ spinlock_t spinlock; /* 3) cache_grow/shrink */ /* order of pgs per slab (2^n) */ unsigned int gfporder; /* force GFP flags, e.g. GFP_DMA */ unsigned int gfpflags; size_t colour; /* cache colouring range */ unsigned int colour_off; /* colour offset */ unsigned int colour_next; /* cache colouring */ kmem_cache_t *slabp_cache; unsigned int slab_size; unsigned int dflags; /* dynamic flags */ /* constructor func */ void (*ctor)(void *, kmem_cache_t *, unsigned long); /* de-constructor func */ void (*dtor)(void *, kmem_cache_t *, unsigned long); /* 4) cache creation/removal */ const char *name; struct list_head next; /* 5) statistics */ ... }; typedef struct kmem_cache_s kmem_cache_t;   slab 描述符 mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * struct slab * * Manages the objs in a slab. Placed either at the beginning of mem allocated * for a slab, or allocated from an general cache. * Slabs are chained into three list: fully used, partial, fully free slabs. */ struct slab { struct list_head list; unsigned long colouroff; void *s_mem; /* including colour offset */ unsigned int inuse; /* num of objs active in slab */ kmem_bufctl_t free; };   对象描述符 每个对象都有一个类型为 kmem_bufctl_t 的描述符，该描述符定义于 include/asm-xx/types.h (xx 代表相应体系结构)，是一个无符号整型。\nslab 的对象描述符也可以用两种方式存放：\n 外部对象描述符：存放在 slab 外部，位于高速缓存描述符 slabp_cache 字段指向的一个普通高速缓存中，内存区大小取决于在 slab 中所存放的对象个数（高速缓存描述符的 num 字段）。 内部对象描述符：存放在 slab 内部，正好位于描述符所描述的对象之前。  各描述符之间的关系 高速缓存描述符与 slab 描述符的关系如下：\nslab 描述符与对象描述符的关系如下：\n普通高速缓存和专用高速缓存 高速缓存被分为普通和专用两种，普通高速缓存只由 slab 分配器用于自己的目的，而专用高速缓存由内核的其余部分使用。\n普通高速缓存 第一个高速缓存叫 kmem_cache，包含在 cache_cache 中。\nmm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13  /* internal cache of cache description objs */ static kmem_cache_t cache_cache = { .lists = LIST3_INIT(cache_cache.lists), .batchcount = 1, .limit = BOOT_CPUCACHE_ENTRIES, .objsize = sizeof(kmem_cache_t), .flags = SLAB_NO_REAP, .spinlock = SPIN_LOCK_UNLOCKED, .name = \u0026#34;kmem_cache\u0026#34;, #if DEBUG  .reallen = sizeof(kmem_cache_t), #endif };   另外的高速缓存包含用作普通用途的内存区，内存范围一般包括 13 个几何分布的内存区，大小分别为 32、64、128、256、512、1024、2048、4096、8192、16384、32768、65536 和 131072 字节。 malloc_size 数组的元素指向 26 个高速缓存描述符，因为每个内存区都包含两个高速缓存，一个用于 ISA DMA 分配，另一个用于常规分配。\nmm/slab.c：\n1 2 3 4 5 6 7 8 9  /* These are the default caches for kmalloc. Custom caches can have other sizes. */ struct cache_sizes malloc_sizes[] = { #define CACHE(x) { .cs_size = (x) }, #include \u0026lt;linux/kmalloc_sizes.h\u0026gt; { 0, } #undef CACHE }; EXPORT_SYMBOL(malloc_sizes);   include/linux/kmalloc_sizes.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #if (PAGE_SIZE == 4096)  CACHE(32) #endif  CACHE(64) #if L1_CACHE_BYTES \u0026lt; 64  CACHE(96) #endif  CACHE(128) #if L1_CACHE_BYTES \u0026lt; 128  CACHE(192) #endif  CACHE(256) CACHE(512) CACHE(1024) CACHE(2048) CACHE(4096) CACHE(8192) CACHE(16384) CACHE(32768) CACHE(65536) CACHE(131072) #ifndef CONFIG_MMU  CACHE(262144) CACHE(524288) CACHE(1048576) #ifdef CONFIG_LARGE_ALLOCS  CACHE(2097152) CACHE(4194304) CACHE(8388608) CACHE(16777216) CACHE(33554432) #endif /* CONFIG_LARGE_ALLOCS */#endif /* CONFIG_MMU */  在系统初始化期间调用位于 mm/slab.c 的 kmem_cache_init() 函数来建立普通高速缓存（书上还提到了 kmem_cache_sizes_init() 函数，我并没找到这个函数，我查了一下较早版本的代码，目前版本该函数似乎已经被合并到了 kmem_cache_init() 函数中）。这个函数的代码太长了，我没有细看，先不展开了。\n专用高速缓存 专用高速缓存由位于 mm/slab.c 的 kmem_cache_create() 函数创建。同样，这个函数的代码太长了，我没有细看，先不展开了。\nslab 分配器与分区页框分配器 向页框分配器请求页框 mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /* * Interface to system\u0026#39;s page allocator. No need to hold the cache-lock. * * If we requested dmaable memory, we will get it. Even if we * did not request dmaable memory, we might get it, but that * would be relatively rare and ignorable. */ static void *kmem_getpages(kmem_cache_t *cachep, int flags, int nodeid) { struct page *page; void *addr; int i; flags |= cachep-\u0026gt;gfpflags; if (likely(nodeid == -1)) { page = alloc_pages(flags, cachep-\u0026gt;gfporder); } else { page = alloc_pages_node(nodeid, flags, cachep-\u0026gt;gfporder); } if (!page) return NULL; addr = page_address(page); i = (1 \u0026lt;\u0026lt; cachep-\u0026gt;gfporder); if (cachep-\u0026gt;flags \u0026amp; SLAB_RECLAIM_ACCOUNT) atomic_add(i, \u0026amp;slab_reclaim_pages); add_page_state(nr_slab, i); while (i--) { SetPageSlab(page); page++; } return addr; }   释放分配给 slab 的页框 mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /* * Interface to system\u0026#39;s page release. */ static void kmem_freepages(kmem_cache_t *cachep, void *addr) { unsigned long i = (1\u0026lt;\u0026lt;cachep-\u0026gt;gfporder); struct page *page = virt_to_page(addr); const unsigned long nr_freed = i; while (i--) { if (!TestClearPageSlab(page)) BUG(); page++; } sub_page_state(nr_slab, nr_freed); if (current-\u0026gt;reclaim_state) current-\u0026gt;reclaim_state-\u0026gt;reclaimed_slab += nr_freed; free_pages((unsigned long)addr, cachep-\u0026gt;gfporder); if (cachep-\u0026gt;flags \u0026amp; SLAB_RECLAIM_ACCOUNT) atomic_sub(1\u0026lt;\u0026lt;cachep-\u0026gt;gfporder, \u0026amp;slab_reclaim_pages); }   slab 分配器与高速缓存 给高速缓存分配 slab mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  /* * Grow (by 1) the number of slabs within a cache. This is called by * kmem_cache_alloc() when there are no active objs left in a cache. */ static int cache_grow (kmem_cache_t * cachep, int flags, int nodeid) { struct slab *slabp; void *objp; size_t offset; int local_flags; unsigned long ctor_flags; /* Be lazy and only check for valid flags here, * keeping it out of the critical path in kmem_cache_alloc(). */ if (flags \u0026amp; ~(SLAB_DMA|SLAB_LEVEL_MASK|SLAB_NO_GROW)) BUG(); if (flags \u0026amp; SLAB_NO_GROW) return 0; ctor_flags = SLAB_CTOR_CONSTRUCTOR; local_flags = (flags \u0026amp; SLAB_LEVEL_MASK); if (!(local_flags \u0026amp; __GFP_WAIT)) /* * Not allowed to sleep. Need to tell a constructor about * this - it might need to know... */ ctor_flags |= SLAB_CTOR_ATOMIC; /* About to mess with non-constant members - lock. */ check_irq_off(); spin_lock(\u0026amp;cachep-\u0026gt;spinlock); /* Get colour for the slab, and cal the next value. */ offset = cachep-\u0026gt;colour_next; cachep-\u0026gt;colour_next++; if (cachep-\u0026gt;colour_next \u0026gt;= cachep-\u0026gt;colour) cachep-\u0026gt;colour_next = 0; offset *= cachep-\u0026gt;colour_off; spin_unlock(\u0026amp;cachep-\u0026gt;spinlock); if (local_flags \u0026amp; __GFP_WAIT) local_irq_enable(); /* * The test for missing atomic flag is performed here, rather than * the more obvious place, simply to reduce the critical path length * in kmem_cache_alloc(). If a caller is seriously mis-behaving they * will eventually be caught here (where it matters). */ kmem_flagcheck(cachep, flags); /* Get mem for the objs. */ if (!(objp = kmem_getpages(cachep, flags, nodeid))) goto failed; /* Get slab management. */ if (!(slabp = alloc_slabmgmt(cachep, objp, offset, local_flags))) goto opps1; set_slab_attr(cachep, slabp, objp); cache_init_objs(cachep, slabp, ctor_flags); if (local_flags \u0026amp; __GFP_WAIT) local_irq_disable(); check_irq_off(); spin_lock(\u0026amp;cachep-\u0026gt;spinlock); /* Make slab active. */ list_add_tail(\u0026amp;slabp-\u0026gt;list, \u0026amp;(list3_data(cachep)-\u0026gt;slabs_free)); STATS_INC_GROWN(cachep); list3_data(cachep)-\u0026gt;free_objects += cachep-\u0026gt;num; spin_unlock(\u0026amp;cachep-\u0026gt;spinlock); return 1; opps1: kmem_freepages(cachep, objp); failed: if (local_flags \u0026amp; __GFP_WAIT) local_irq_disable(); return 0; }   这个函数我没有细看，很多细节现在也看不懂，大致流程是首先调用 kmem_getpages() 获得一组页框来存放一个新的 slab，其次调用 alloc_slabmgmt() 获得一个新的 slab 描述符，然后调用 cache_init_jobs() 讲构造方法应用到新 slab 包含的所有对象上，最后调用 list_add_tail() 来将新得到的 slab 描述符 *slabp 添加到高速缓存描述符 *cachep 的全空 slab 链表的末端并更新高速缓存中的空闲对象计数器。\n从高速缓存释放 slab mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /* Destroy all the objs in a slab, and release the mem back to the system. * Before calling the slab must have been unlinked from the cache. * The cache-lock is not held/needed. */ static void slab_destroy (kmem_cache_t *cachep, struct slab *slabp) { void *addr = slabp-\u0026gt;s_mem - slabp-\u0026gt;colouroff; #if DEBUG  ... #else  if (cachep-\u0026gt;dtor) { int i; for (i = 0; i \u0026lt; cachep-\u0026gt;num; i++) { void* objp = slabp-\u0026gt;s_mem+cachep-\u0026gt;objsize*i; (cachep-\u0026gt;dtor)(objp, cachep, 0); } } #endif  if (unlikely(cachep-\u0026gt;flags \u0026amp; SLAB_DESTROY_BY_RCU)) { struct slab_rcu *slab_rcu; slab_rcu = (struct slab_rcu *) slabp; slab_rcu-\u0026gt;cachep = cachep; slab_rcu-\u0026gt;addr = addr; call_rcu(\u0026amp;slab_rcu-\u0026gt;head, kmem_rcu_free); } else { kmem_freepages(cachep, addr); if (OFF_SLAB(cachep)) kmem_cache_free(cachep-\u0026gt;slabp_cache, slabp); } }   这个函数检查高速缓存是否为它的对象提供了析构方法，如果是，就用析构方法释放 slab 中的所有对象。接着调用 kmem_freepages() 把页框返回给伙伴系统。 关于设置了 SLAB_DESTROY_BY_RCU 标志的代码，见 TODO，这里不展开。\n对齐内存中的对象 对齐对象由 kmem_cache_create() 函数完成，这里不展开。\nslab 着色 简单概括，slab 着色就是对 slab 使用不同的颜色（不同的偏移量），尽量使得不同的对象的映射到不同的硬件高速缓存行上。着色相关的内容最终被摒弃了（slub 分配器），所以我不打算细看了。\n空闲 slab 对象的本地高速缓存 类似 per-CPU 高速缓存，slab 分配器也包含每个 CPU 上的本地高速缓存，只在本地数组溢出时才涉及 slab 数据结构。高速缓存描述符的 array 字段就是一组指向 array_cache 数据结构的指针。本地高速缓存的描述符并不包含本地高速缓存本身的地址，它正好位于描述符之后。\nmm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /* * struct array_cache * * Per cpu structures * Purpose: * - LIFO ordering, to hand out cache-warm objects from _alloc * - reduce the number of linked list operations * - reduce spinlock operations * * The limit is stored in the per-cpu structure to reduce the data cache * footprint. * */ struct array_cache { unsigned int avail; // 指向本地高速缓存中可使用对象的指针的个数，同时作为高速缓存中第一个空槽的下标  unsigned int limit; // 本地高速缓存中指针的最大个数  unsigned int batchcount; // 本地高速缓存重新填充或腾空时使用的大小  unsigned int touched; // 如果本地高速缓存最近已经被使用过，该标志为 1 };   分配和释放内存 分配 slab 对象 mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  static inline void ** ac_entry(struct array_cache *ac) { return (void**)(ac+1); } static inline struct array_cache *ac_data(kmem_cache_t *cachep) { return cachep-\u0026gt;array[smp_processor_id()]; } /** * kmem_cache_alloc - Allocate an object * @cachep: The cache to allocate from. * @flags: See kmalloc(). * * Allocate an object from this cache. The flags are only relevant * if the cache has no available objects. */ void * kmem_cache_alloc (kmem_cache_t *cachep, int flags) { return __cache_alloc(cachep, flags); } static inline void * __cache_alloc (kmem_cache_t *cachep, int flags) { unsigned long save_flags; void* objp; struct array_cache *ac; cache_alloc_debugcheck_before(cachep, flags); local_irq_save(save_flags); ac = ac_data(cachep); if (likely(ac-\u0026gt;avail)) { STATS_INC_ALLOCHIT(cachep); ac-\u0026gt;touched = 1; objp = ac_entry(ac)[--ac-\u0026gt;avail]; } else { STATS_INC_ALLOCMISS(cachep); objp = cache_alloc_refill(cachep, flags); } local_irq_restore(save_flags); objp = cache_alloc_debugcheck_after(cachep, flags, objp, __builtin_return_address(0)); return objp; }   首先试图从本地高速缓存获得一个空闲对象，如果没有，则调用 cache_alloc_refill() 函数重新填充本地高速缓存并获得一个空闲对象。cache_alloc_refill() 函数比较复杂，这里不展开。\n释放 slab 对象 mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /** * kmem_cache_free - Deallocate an object * @cachep: The cache the allocation was from. * @objp: The previously allocated object. * * Free an object which was previously allocated from this * cache. */ void kmem_cache_free (kmem_cache_t *cachep, void *objp) { unsigned long flags; local_irq_save(flags); __cache_free(cachep, objp); local_irq_restore(flags); } /* * __cache_free * Release an obj back to its cache. If the obj has a constructed * state, it must be in this state _before_ it is released. * * Called with disabled ints. */ static inline void __cache_free (kmem_cache_t *cachep, void* objp) { struct array_cache *ac = ac_data(cachep); check_irq_off(); objp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0)); if (likely(ac-\u0026gt;avail \u0026lt; ac-\u0026gt;limit)) { STATS_INC_FREEHIT(cachep); ac_entry(ac)[ac-\u0026gt;avail++] = objp; return; } else { STATS_INC_FREEMISS(cachep); cache_flusharray(cachep, ac); ac_entry(ac)[ac-\u0026gt;avail++] = objp; } }   首先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针，如果有，该指针被加到本地高速缓存然后返回。否则，调用 cache_flusharray() 函数来清空本地高速缓存，再将指针加到本地高速缓存。 同样，cache_alloc_refill() 函数比较复杂，这里不展开。\n分配通用对象 include/linux/slab.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static inline void *kmalloc(size_t size, int flags) { if (__builtin_constant_p(size)) { int i = 0; #define CACHE(x) \\ if (size \u0026lt;= x) \\ goto found; \\ else \\ i++; #include \u0026#34;kmalloc_sizes.h\u0026#34;#undef CACHE  { extern void __you_cannot_kmalloc_that_much(void); __you_cannot_kmalloc_that_much(); } found: return kmem_cache_alloc((flags \u0026amp; GFP_DMA) ? malloc_sizes[i].cs_dmacachep : malloc_sizes[i].cs_cachep, flags); } return __kmalloc(size, flags); }   mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  /** * kmalloc - allocate memory * @size: how many bytes of memory are required. * @flags: the type of memory to allocate. * * kmalloc is the normal method of allocating memory * in the kernel. * * The @flags argument may be one of: * * %GFP_USER - Allocate memory on behalf of user. May sleep. * * %GFP_KERNEL - Allocate normal kernel ram. May sleep. * * %GFP_ATOMIC - Allocation will not sleep. Use inside interrupt handlers. * * Additionally, the %GFP_DMA flag may be set to indicate the memory * must be suitable for DMA. This can mean different things on different * platforms. For example, on i386, it means that the memory must come * from the first 16MB. */ void * __kmalloc (size_t size, int flags) { struct cache_sizes *csizep = malloc_sizes; for (; csizep-\u0026gt;cs_size; csizep++) { if (size \u0026gt; csizep-\u0026gt;cs_size) continue; #if DEBUG  /* This happens if someone tries to call * kmem_cache_create(), or kmalloc(), before * the generic caches are initialized. */ BUG_ON(csizep-\u0026gt;cs_cachep == NULL); #endif  return __cache_alloc(flags \u0026amp; GFP_DMA ? csizep-\u0026gt;cs_dmacachep : csizep-\u0026gt;cs_cachep, flags); } return NULL; } EXPORT_SYMBOL(__kmalloc);   释放通用对象 mm/slab.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * kfree - free previously allocated memory * @objp: pointer returned by kmalloc. * * Don\u0026#39;t free memory not originally allocated by kmalloc() * or you will run into trouble. */ void kfree (const void *objp) { kmem_cache_t *c; unsigned long flags; if (!objp) return; local_irq_save(flags); kfree_debugcheck(objp); c = GET_PAGE_CACHE(virt_to_page(objp)); __cache_free(c, (void*)objp); local_irq_restore(flags); }   ","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/slab/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍 slab 分配器。\u003c/p\u003e","title":"slab 分配器"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍 per-CPU 高速缓存。\n“hot-n-cold pages” 补丁 这部分内容好多专业名词的翻译感觉特别变扭，就直接使用英文了。该补丁是在 2.5.45 版本加入内核的，具体可以参考社区新闻 Hot and cold pages。\n下面简单概括一下这篇新闻的内容。\n通常认为 RAM 是保存数据最快的地方，然而真正快的是处理器（processor）板载的硬件高速缓存（cache），所以多年来，人们都在尝试优化内核的缓存行为来避免数据进到内存。新的页分配系统只是朝这个方向迈出的又一步。\n内核通常知道哪些页面最近被使用过，它们大概率在硬件高速缓存中。新加入的 “hot-n-cold pages” 补丁，尝试利用这些信息，在每个内存区（zone）加入两个 per-CPU 空闲页链表。当处理器释放怀疑为 “hot” 的页面（即该页面在处理器的硬件高速缓存中）时，该页面将被推送到 hot 链表；其他则进入 cold 链表。当然，这个链表存在上界和下界。\n当内核需要一页内存时，新的分配器通常会尝试从处理器的 hot 链表中获取页。即使页面将要被改写，还是使用缓存的页更好。不过有时候使用 cold 的页更有意义的，比如用于 DMA 读取操作时，此时可以使用 GPF_COLD 页面分配标志。\n使用 per-CPU 页链表还可以减少锁的竞争。因为当页必须在 hot/cold 链表和主内存分配器之间移动时，它们以多个页的块进行传输。\n注意，在此处，“处理器”的概念是广义的，即“处理器”包含 CPU，寄存器堆（register file），浮点协处理器等部件。日常生活中的“处理器”通常就是指 CPU。\n书中介绍的“每 CPU 页框高速缓存” 《深入理解 Linux 内核》第八章“每 CPU 页框高速缓存”一节中的好多语句，我初次读的时候都没看明白。现在结合上面的新闻，再去阅读。\n 正如我们将在本在稍后看到的，内核经常请求和释放单个页框：为了提升系统性能，每个内存管理区定义了一个“每 CPU” 页框高速缓存。所有“每 CPU” 高速缓存包含一些预先分配的页框。它们被用于满足本地 CPU 发出的单一内存请求。\n 现在的处理器，通常是多核的，而且带有多级缓存，一级缓存是每个核私有的，二级缓存开始可能就是共享的了。“为了满足本地 CPU 发出的单一内存请求”，这就是为什么下文说的要为每个 CPU 提供两个高速缓存（两个链表）。\n 实际上，这里为每个内存管理区和每个 CPU 提供了两个高速缓存：一个热高速缓存，它存放的页框中所包含的内容很可能就在 CPU 硬件高速缓存中；还有一个冷高速缓存。\n 这里讲的就是 hot/cold 链表。其中，hot 链表存放的是大概率在高速缓存中的页。\n 如果内核或用户态进程在刚分配到页框后就立即向页框写，那么从热高速缓存中获得页框就对系统性能有利。实际上，每次对页框存储单元的访问将都会导致从另一个页框给硬件高速缓存“窃取”一行——当然，除非硬件高速缓存包含有一行：它映射刚被访问的“热”页框单元。\n 刚分配的页框通常在高速缓存中，即会被存放于 hot 链表。后面那句话有点迷，我的理解是除非高速缓存中已经有了那行数据，否则高速缓存会从内存加载那行数据，就是解释了一下高速缓存的工作方式。\n 反过来，如果页框将要被 DMA 操作填充，那么从冷高速缓存中获得页框是方便的。在这种情况下，不会涉及到 CPU，并且硬件高速缓存的行不会被修改。从冷高速缓存获得页框为其他类型的内存分配保存了热页框储备。\n 这里解释了在需要 DMA 操作的情况下，用 cold 链表的好处。\nper-CPU 页框高速缓存的实现 pageset include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  struct per_cpu_pages { int count; /* number of pages in the list */ int low; /* low watermark, refill needed */ int high; /* high watermark, emptying needed */ int batch; /* chunk size for buddy add/remove */ struct list_head list; /* the list of pages */ }; struct per_cpu_pageset { struct per_cpu_pages pcp[2]; /* 0: hot. 1: cold */ #ifdef CONFIG_NUMA  unsigned long numa_hit; /* allocated in intended node */ unsigned long numa_miss; /* allocated in non intended node */ unsigned long numa_foreign; /* was intended here, hit elsewhere */ unsigned long interleave_hit; /* interleaver prefered this zone */ unsigned long local_node; /* allocation from local node */ unsigned long other_node; /* allocation from other node */ #endif } ____cacheline_aligned_in_smp; struct zone { ... struct per_cpu_pageset pageset[NR_CPUS]; ... }   通过 per-CPU 页框高速缓存分配页框 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  /* * Obtain a specified number of elements from the buddy allocator, all under * a single hold of the lock, for efficiency. Add them to the supplied list. * Returns the number of new pages which were placed at *list. */ static int rmqueue_bulk(struct zone *zone, unsigned int order, unsigned long count, struct list_head *list) { unsigned long flags; int i; int allocated = 0; struct page *page; spin_lock_irqsave(\u0026amp;zone-\u0026gt;lock, flags); for (i = 0; i \u0026lt; count; ++i) { page = __rmqueue(zone, order); // 从伙伴系统分配要补充的页框  if (page == NULL) break; allocated++; list_add_tail(\u0026amp;page-\u0026gt;lru, list); // 添加到 hot/cold 链表  } spin_unlock_irqrestore(\u0026amp;zone-\u0026gt;lock, flags); return allocated; } /* * Really, prep_compound_page() should be called from __rmqueue_bulk(). But * we cheat by calling it from here, in the order \u0026gt; 0 path. Saves a branch * or two. */ static struct page * buffered_rmqueue(struct zone *zone, int order, int gfp_flags) { unsigned long flags; struct page *page = NULL; int cold = !!(gfp_flags \u0026amp; __GFP_COLD); if (order == 0) { // 请求一个页框  struct per_cpu_pages *pcp; pcp = \u0026amp;zone-\u0026gt;pageset[get_cpu()].pcp[cold]; // 获取 per_cpu_pages  local_irq_save(flags); if (pcp-\u0026gt;count \u0026lt;= pcp-\u0026gt;low) // 需要添加 per-CPU 页框高速缓存  pcp-\u0026gt;count += rmqueue_bulk(zone, 0, // 从伙伴系统分配要补充的页框  pcp-\u0026gt;batch, \u0026amp;pcp-\u0026gt;list); if (pcp-\u0026gt;count) { // per-CPU 页框高速缓存中存在页框，直接分配  page = list_entry(pcp-\u0026gt;list.next, struct page, lru); list_del(\u0026amp;page-\u0026gt;lru); // 从 hot/cold 链表中删除  pcp-\u0026gt;count--; } local_irq_restore(flags); put_cpu(); } if (page == NULL) { // 请求未满足  spin_lock_irqsave(\u0026amp;zone-\u0026gt;lock, flags); page = __rmqueue(zone, order); // 从伙伴系统分配请求的页框  spin_unlock_irqrestore(\u0026amp;zone-\u0026gt;lock, flags); } if (page != NULL) { // 请求得到满足  BUG_ON(bad_range(zone, page)); mod_page_state_zone(zone, pgalloc, 1 \u0026lt;\u0026lt; order); // 修改 page_state  prep_new_page(page, order); // 初始化页描述符  if (gfp_flags \u0026amp; __GFP_ZERO) // 内存区域填充 0  prep_zero_page(page, order, gfp_flags); if (order \u0026amp;\u0026amp; (gfp_flags \u0026amp; __GFP_COMP)) // 复合页  prep_compound_page(page, order); } return page; // 返回页描述符地址 }    部分内容涉及伙伴系统，此处不展开了。 复合页：将物理上连续的两个或多个页看成一个独立的大页，具体可以参考社区新闻 An introduction to compound pages。。  释放页框到 per-CPU 页框高速缓存 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  /* * Frees a list of pages. * Assumes all pages on list are in same zone, and of same order. * count is the number of pages to free, or 0 for all on the list. * * If the zone was previously in an \u0026#34;all pages pinned\u0026#34; state then look to * see if this freeing clears that state. * * And clear the zone\u0026#39;s pages_scanned counter, to hold off the \u0026#34;all pages are * pinned\u0026#34; detection logic. */ static int free_pages_bulk(struct zone *zone, int count, struct list_head *list, unsigned int order) { unsigned long flags; struct page *base, *page = NULL; int ret = 0; base = zone-\u0026gt;zone_mem_map; spin_lock_irqsave(\u0026amp;zone-\u0026gt;lock, flags); zone-\u0026gt;all_unreclaimable = 0; zone-\u0026gt;pages_scanned = 0; while (!list_empty(list) \u0026amp;\u0026amp; count--) { page = list_entry(list-\u0026gt;prev, struct page, lru); /* have to delete it as __free_pages_bulk list manipulates */ list_del(\u0026amp;page-\u0026gt;lru); // 从 hot/cold 链表中删除  __free_pages_bulk(page, base, zone, order); // 从伙伴系统释放页框  ret++; } spin_unlock_irqrestore(\u0026amp;zone-\u0026gt;lock, flags); return ret; } /* * Free a 0-order page */ static void FASTCALL(free_hot_cold_page(struct page *page, int cold)); static void fastcall free_hot_cold_page(struct page *page, int cold) { struct zone *zone = page_zone(page); // 获取页框所在的区  struct per_cpu_pages *pcp; unsigned long flags; arch_free_page(page, 0); // 取消映射，如果有的话  kernel_map_pages(page, 1, 0); // 需要开启 CONFIG_DEBUG_PAGEALLOC 选项  inc_page_state(pgfree); // 修改 page_state  if (PageAnon(page)) // 匿名页  page-\u0026gt;mapping = NULL; free_pages_check(__FUNCTION__, page); // 检查该页的释放条件  pcp = \u0026amp;zone-\u0026gt;pageset[get_cpu()].pcp[cold]; // 获取 per_cpu_pages  local_irq_save(flags); if (pcp-\u0026gt;count \u0026gt;= pcp-\u0026gt;high) // 需要移除 per-CPU 页框高速缓存  pcp-\u0026gt;count -= free_pages_bulk(zone, pcp-\u0026gt;batch, \u0026amp;pcp-\u0026gt;list, 0); // 从伙伴系统释放页框  list_add(\u0026amp;page-\u0026gt;lru, \u0026amp;pcp-\u0026gt;list); // 添加到 hot/cold 链表  pcp-\u0026gt;count++; local_irq_restore(flags); put_cpu(); } void fastcall free_hot_page(struct page *page) { free_hot_cold_page(page, 0); // 释放至 hot 链表 } void fastcall free_cold_page(struct page *page) { free_hot_cold_page(page, 1); // 释放至 cold 链表 }    CONFIG_DEBUG_PAGEALLOC：页面被释放时是整个的从内核地址空间中移除的。该选项显著地降低了速度，但它也能迅速指出特定类型的内存崩溃错误。 匿名页：指应用程序动态分配的堆内存，此处不做具体阐述。  在 2.6 版本的内核中，页框全部被释放至 hot 链表，但这不意味着 cold 链表是空的，当它达到下界时会通过 buffered_rmqueue() 添加。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/per-cpu/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍 per-CPU 高速缓存。\u003c/p\u003e","title":"per-CPU 高速缓存"},{"content":"Linux 内核学习笔记系列，内存管理部分，简单介绍伙伴系统。\n伙伴系统简介 伙伴（Buddy）系统是为了解决外碎片问题而设计的。\n伙伴系统算法把所有的空闲页框分为 11 个块链表，每个块链表分别包含 1、2、4、8、16、32、64、128、256、512 和 1024 个连续的页框。每个块的第一个页框的物理地址是该块大小的整数倍。由于内核页大小是 4 KB，所以最大请求为 4 MB 大小连续的 RAM 块。\n在请求块时，算法会先在请求页框大小块的链表中检查是否有一个空闲块，如果没有，就查找下一个更大的块，把这个块分裂为两个小块。如果还是没有找到，就继续查找更大块，直到最大的 1024 个页框的块。如果 1024 个页框的链表还是空的，算法就放弃并发出错误信号。\n在释放块时，算法会试图把一对空闲伙伴合并为一个单独的块，且算法是迭代的，即算法会再次试图合成的生成的块。满足以下条件的两个块被称为伙伴：\n 两个块具有相同的大小，记作 $b$。 它们的物理地址连续。 第一个块的第一个页框的物理地址是 $2 \\times b \\times 2^{12}$。  由于块的大小都是 2 的幂，所以被称为伙伴的块只有一位二进制位不同。对于一个块，只需要与掩码（1 \u0026lt;\u0026lt; order）进行异或操作，就能找到它的伙伴。\n伙伴系统分配器 数据结构 include/linux/mmzone.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  struct zone { ... /* * free areas of different sizes */ spinlock_t lock; struct free_area free_area[MAX_ORDER]; ... /* * Discontig memory support fields. */ struct pglist_data *zone_pgdat; struct page *zone_mem_map; /* zone_start_pfn == zone_start_paddr \u0026gt;\u0026gt; PAGE_SHIFT */ unsigned long zone_start_pfn; unsigned long spanned_pages; /* total size, including holes */ unsigned long present_pages; /* amount of memory (excluding holes) */ ... }   对每个管理区，Linux 采用不同的伙伴系统，每个伙伴系统使用的主要数据结构如下：\n mem_map 数组。每个区都关系到该数组的子集，由 zone_mem_map 指定子集的第一个元素。 free_area 数组。该数组的元素类型为 free_area，每个元素对应一种块大小。  分配块 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  static inline struct page * expand(struct zone *zone, struct page *page, int low, int high, struct free_area *area) { unsigned long size = 1 \u0026lt;\u0026lt; high; while (high \u0026gt; low) { // current_order \u0026gt; order  area--; high--; size \u0026gt;\u0026gt;= 1; BUG_ON(bad_range(zone, \u0026amp;page[size])); list_add(\u0026amp;page[size].lru, \u0026amp;area-\u0026gt;free_list); // 添加到空闲链表  area-\u0026gt;nr_free++; set_page_order(\u0026amp;page[size], high); // 设置 private  } return page; } /* * Do the hard work of removing an element from the buddy allocator. * Call me with the zone-\u0026gt;lock already held. */ static struct page *__rmqueue(struct zone *zone, unsigned int order) { struct free_area * area; unsigned int current_order; struct page *page; for (current_order = order; current_order \u0026lt; MAX_ORDER; ++current_order) { area = zone-\u0026gt;free_area + current_order; if (list_empty(\u0026amp;area-\u0026gt;free_list)) continue; page = list_entry(area-\u0026gt;free_list.next, struct page, lru); list_del(\u0026amp;page-\u0026gt;lru); // 从空闲链表中删除  rmv_page_order(page); // 清除 private  area-\u0026gt;nr_free--; zone-\u0026gt;free_pages -= 1UL \u0026lt;\u0026lt; order; return expand(zone, page, order, current_order, area); } return NULL; }   释放块 mm/page_alloc.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  static inline void __free_pages_bulk (struct page *page, struct page *base, struct zone *zone, unsigned int order) { unsigned long page_idx; struct page *coalesced; int order_size = 1 \u0026lt;\u0026lt; order; if (unlikely(order)) // 复合页  destroy_compound_page(page, order); page_idx = page - base; // 当前块的下标  BUG_ON(page_idx \u0026amp; (order_size - 1)); BUG_ON(bad_range(zone, page)); zone-\u0026gt;free_pages += order_size; while (order \u0026lt; MAX_ORDER-1) { // 合并一个块和它的伙伴  struct free_area *area; struct page *buddy; int buddy_idx; buddy_idx = (page_idx ^ (1 \u0026lt;\u0026lt; order)); // 当前块的伙伴的下标  buddy = base + buddy_idx; if (bad_range(zone, buddy)) break; if (!page_is_buddy(buddy, order)) break; /* Move the buddy up one level. */ list_del(\u0026amp;buddy-\u0026gt;lru); area = zone-\u0026gt;free_area + order; area-\u0026gt;nr_free--; rmv_page_order(buddy); // 清除 private  page_idx \u0026amp;= buddy_idx; // 恢复当前块的下标  order++; } coalesced = base + page_idx; set_page_order(coalesced, order); list_add(\u0026amp;coalesced-\u0026gt;lru, \u0026amp;zone-\u0026gt;free_area[order].free_list); // 添加到空闲链表  zone-\u0026gt;free_area[order].nr_free++; }   复合页：将物理上连续的两个或多个页看成一个独立的大页，具体可以参考社区新闻 An introduction to compound pages。\n","permalink":"https://freeflyingsheep.github.io/posts/kernel/memory/buddy-system/","summary":"\u003cp\u003e\u003ca href=\"/posts/kernel/kernel\"\u003eLinux 内核学习笔记系列\u003c/a\u003e，内存管理部分，简单介绍伙伴系统。\u003c/p\u003e","title":"伙伴系统"},{"content":"阅读 MIPS 启动部分的代码，从内核入口 kernel_entry 到 start_kernel 的第一个子函数 lock_kernel，很多细节我并没理解，所以不进行展开。基于 Linux kernel release 2.6.11.12。由于 Markdown 代码块语法高亮不支持汇编，此处统一用 C 标注。\n函数 kernel_entry arch/mips/kernel/head.S：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  NESTED(kernel_entry, 16, sp) # kernel entry point setup_c0_status_pri #ifdef CONFIG_SGI_IP27  GET_NASID_ASM t1 move t2, t1 # text and data are here // t2 = t1  MAPPED_KERNEL_SETUP_TLB #endif /* IP27 */ ARC64_TWIDDLE_PC PTR_LA t0, __bss_start # clear .bss // t0 = __bss_start  LONG_S zero, (t0) // *(t0) = 0  PTR_LA t1, __bss_stop - LONGSIZE // t1 = __bss_stop - LONGSIZE 1: PTR_ADDIU t0, LONGSIZE // t0 += LONGSIZE  LONG_S zero, (t0) // *(t0) = 0  bne t0, t1, 1b // if (t0 != t1) goto 1b  LONG_S a0, fw_arg0 # firmware arguments LONG_S a1, fw_arg1 LONG_S a2, fw_arg2 LONG_S a3, fw_arg3 PTR_LA $28, init_thread_union // gp = init_thread_union  PTR_ADDIU sp, $28, _THREAD_SIZE - 32 // sp = gp + _THREAD_SIZE - 32  set_saved_sp sp, t0, t1 PTR_SUBU sp, 4 * SZREG # init stack pointer // sp = 4 * SZREG  j start_kernel END(kernel_entry)   init_thread_union 定义于 arch/mips/kernel/init_task.c。\nstart_kernel init/main.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * Activate the first processor. */ asmlinkage void __init start_kernel(void) { char * command_line; extern struct kernel_param __start___param[], __stop___param[]; /* * Interrupts are still disabled. Do necessary setups, then * enable them */ lock_kernel(); ...   lock_kernel include/linux/smp_lock.h：\n1 2 3 4 5 6 7 8 9 10 11  #ifdef CONFIG_LOCK_KERNEL  extern void __lockfunc lock_kernel(void) __acquires(kernel_lock); extern void __lockfunc unlock_kernel(void) __releases(kernel_lock); #else  #define lock_kernel() do { } while(0) #define unlock_kernel() do { } while(0)  #endif /* CONFIG_LOCK_KERNEL */  lock_kernel 和 unlock_kernel 的具体实现在 lib/kernel_lock.c 中。\n汇编器指令 主要参考文档 Using as。\n.set noreorder 设置汇编器不移动指令来填充延迟槽。\n.set push 和 .set pop 见 Directives to save and restore options。\n可以先用 .set push 保存汇编器配置，然后执行一些修改 (比如配置 .set noreorder)，最后用 .set pop 恢复之前的汇编器配置。\n.comm 见 .comm symbol , length。\n在大部分情况下，可以简单理解为定义一个变量，变量名为 symbol ，占 length 字节，可选的第三个参数代表对齐字节数。\n.align [abs-expr[, abs-expr[, abs-expr]]] 见 .align [abs-expr[, abs-expr[, abs-expr]]]。\n通常只用到第一个表达式，如 .align 8 代表 8 字节对齐。\n.type 见 .type。\n在内核中，基本只用到了 .type \u0026lt;name\u0026gt;,@\u0026lt;type\u0026gt; 的形式，用于表明函数类型。\n.globl 见 .globl。\n声明变量 (供链接器使用)。\n.ent 声明变量 (供调试器使用)。\n.frame .frame sp, size, ra，提供给调试器关于栈帧的信息，sp 代表指向栈帧的地址、寄存器，size 代表栈帧的大小，ra 代表保存返回地址的寄存器。\n.section 见 .section name。\n.previous 见 .previous。\n.macro 和 .endm 见 .macro。\n宏 EXPORT include/asm-mips/asm.h：\n1 2 3 4 5 6  /* * EXPORT - export definition of symbol */ #define EXPORT(symbol) \\ .globl symbol; \\ symbol:   声明一个全局变量。\n__INIT 和 __FINIT include/linux/init.h：\n1 2  #define __INIT .section \u0026#34;.init.text\u0026#34;,\u0026#34;ax\u0026#34; #define __FINIT .previous   .section 和 .previous 见汇编器指令章节的相关内容。\n32 位和 64 位的兼容 32 位和 64 位情况下的数据长度和指令不同，具体见 include/asm-mips/asm.h，该文件中的部分宏定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /* * Size of a register */ #ifdef __mips64 #define SZREG 8 #else #define SZREG 4 #endif  /* * How to add/sub/load/store/shift C long variables. */ #if (_MIPS_SZLONG == 32) #define LONG_S sw #endif  #if (_MIPS_SZLONG == 64) #define LONG_S sd #endif  /* * How to add/sub/load/store/shift pointers. */ #if (_MIPS_SZPTR == 32) #define PTR_ADDIU addiu #define PTR_SUBU subu #define PTR_LA la #endif  #if (_MIPS_SZPTR == 64) #define PTR_ADDU daddu #define PTR_SUBU dsubu #define PTR_LA dla #endif   NESTED include/asm-mips/asm.h：\n1 2 3 4 5 6 7 8 9  /* * NESTED - declare nested routine entry point */ #define NESTED(symbol, framesize, rpc) \\ .globl symbol; \\ .align 2; \\ .type symbol,@function; \\ .ent symbol,0; \\ symbol: .frame sp, framesize, rpc   定义一个函数的头部。\nsetup_c0_status_pri arch/mips/kernel/head.S：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /* * For the moment disable interrupts, mark the kernel mode and * set ST0_KX so that the CPU does not spit fire when using * 64-bit addresses. A full initialization of the CPU\u0026#39;s status * register is done later in per_cpu_trap_init(). */ .macro setup_c0_status set clr .set push mfc0 t0, CP0_STATUS // t0 = $12  or t0, ST0_CU0|\\set|0x1f|\\clr // t0 |= ST0_CU0 | set | 0x1f | clr  xor t0, 0x1f|\\clr // t0 ^= 0x1f | clr  mtc0 t0, CP0_STATUS // $12 = t0  .set noreorder sll zero,3 # ehb .set pop .endm .macro setup_c0_status_pri #ifdef CONFIG_MIPS64  setup_c0_status ST0_KX 0 // setup_c0_status 0x00000080 0，见宏章节的 CP0 寄存器 #else  setup_c0_status 0 0 // setup_c0_status 0 0 #endif  .endm   如果配置了 CONFIG_MIPS64，setup_c0_status 会把 CP0 的 $12 设置为 0x80；反之则设置为 0。具体作用注释已经给出，建议参考 The MIPS64 and microMIPS64 Privileged Resource Architecture v6.03 的 Table 9.49。\nCP0 寄存器 include/asm-mips/mipsregs.h：\n1 2 3 4 5 6 7 8 9  /* * Coprocessor 0 register names */ #define CP0_STATUS $12  /* * Bitfields in the R4xx0 cp0 status register */ #define ST0_KX 0x00000080   GET_NASID_ASM arch/mips/kernel/head.S：\n1 2 3 4 5 6 7 8 9 10 11  #ifdef CONFIG_SGI_IP27  /* * outputs the local nasid into res. IP27 stuff. */ .macro GET_NASID_ASM res dli \\res, LOCAL_HUB_ADDR(NI_STATUS_REV_ID) ld \\res, (\\res) and \\res, NSRI_NODEID_MASK dsrl \\res, NSRI_NODEID_SHFT .endm #endif /* CONFIG_SGI_IP27 */  MAPPED_KERNEL_SETUP_TLB 定义于 arch/mips/kernel/head.S。\nARC64_TWIDDLE_PC arch/mips/kernel/head.S：\n1 2 3 4 5 6 7 8 9  .macro ARC64_TWIDDLE_PC #if defined(CONFIG_ARC64) || defined(CONFIG_MAPPED_KERNEL)  /* We get launched at a XKPHYS address but the kernel is linked to run at a KSEG0 address, so jump there. */ PTR_LA t0, \\@f jr t0 \\@: #endif  .endm   _THREAD_SIZE 定义于 arch/mips/kernel/offset.c ，该文件会根据 arch/mips/Makefile 中的规则，生成 asm/offset.h。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  # Generate \u0026lt;asm/offset.h\u0026gt; # # The default rule is suffering from funny problems on MIPS so we using our # own ... # # ---------------------------------------------------------------------------  define filechk_gen-asm-offset.h (set -e; \\ echo \u0026#34;#ifndef _ASM_OFFSET_H\u0026#34;; \\ echo \u0026#34;#define _ASM_OFFSET_H\u0026#34;; \\ echo \u0026#34;/*\u0026#34;; \\ echo \u0026#34; * DO NOT MODIFY.\u0026#34;; \\ echo \u0026#34; *\u0026#34;; \\ echo \u0026#34; * This file was generated by arch/$(ARCH)/Makefile\u0026#34;; \\ echo \u0026#34; *\u0026#34;; \\ echo \u0026#34; */\u0026#34;; \\ echo \u0026#34;\u0026#34;; \\ sed -ne \u0026#34;/^@@@/s///p\u0026#34;; \\ echo \u0026#34;#endif /* _ASM_OFFSET_H */\u0026#34; ) endef prepare: include/asm-$(ARCH)/offset.h arch/$(ARCH)/kernel/offset.s: include/asm include/linux/version.h \\ include/config/MARKER include/asm-$(ARCH)/offset.h: arch/$(ARCH)/kernel/offset.s $(call filechk,gen-asm-offset.h)   Makefile：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # filechk is used to check if the content of a generated file is updated. # Sample usage: # define filechk_sample # echo $KERNELRELEASE # endef # version.h : Makefile # $(call filechk,sample) # The rule defined shall write to stdout the content of the new file. # The existing file will be compared with the new one. # - If no file exist it is created # - If the content differ the new file is used # - If they are equal no change, and no timestamp update  define filechk @set -e; \\ echo \u0026#39; CHK $@\u0026#39;; \\ mkdir -p $(dir $@); \\ $(filechk_$(1)) \u0026lt; $\u0026lt; \u0026gt; $@.tmp; \\ if [ -r $@ ] \u0026amp;\u0026amp; cmp -s $@ $@.tmp; then \\ rm -f $@.tmp; \\ else \\ echo \u0026#39; UPD $@\u0026#39;; \\ mv -f $@.tmp $@; \\ fi endef   查看文件中 _THREAD_SIZE 相关代码，最终该宏相当于 #define _THREAD_SIZE THREAD_SIZE。\nTHREAD_SIZE include/asm-mips/thread_info.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* thread information allocation */ #if defined(CONFIG_PAGE_SIZE_4KB) \u0026amp;\u0026amp; defined(CONFIG_MIPS32) #define THREAD_SIZE_ORDER (1) #endif #if defined(CONFIG_PAGE_SIZE_4KB) \u0026amp;\u0026amp; defined(CONFIG_MIPS64) #define THREAD_SIZE_ORDER (2) #endif #ifdef CONFIG_PAGE_SIZE_8KB #define THREAD_SIZE_ORDER (1) #endif #ifdef CONFIG_PAGE_SIZE_16KB #define THREAD_SIZE_ORDER (0) #endif #ifdef CONFIG_PAGE_SIZE_64KB #define THREAD_SIZE_ORDER (0) #endif  #define THREAD_SIZE (PAGE_SIZE \u0026lt;\u0026lt; THREAD_SIZE_ORDER)   include/asm-mips/page.h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* * PAGE_SHIFT determines the page size */ #ifdef CONFIG_PAGE_SIZE_4KB #define PAGE_SHIFT 12 #endif #ifdef CONFIG_PAGE_SIZE_8KB #define PAGE_SHIFT 13 #endif #ifdef CONFIG_PAGE_SIZE_16KB #define PAGE_SHIFT 14 #endif #ifdef CONFIG_PAGE_SIZE_64KB #define PAGE_SHIFT 16 #endif #define PAGE_SIZE (1UL \u0026lt;\u0026lt; PAGE_SHIFT)   set_saved_sp 定义于 include/asm-mips/stackframe.h，见后续笔记。\nEND 1 2 3 4 5 6  /* * END - mark end of function */ #define END(function) \\ .end function; \\ .size function,.-function   定义一个函数的尾部。\nCP0_STATUS include/asm-mips/mipsregs.h：\n1  #define CP0_STATUS $12   CONFIG_SGI_IP27 arch/mips/Makefile:\n1 2 3 4 5 6 7  # # SGI-IP27 (Origin200/2000) # # Set the load address to \u0026gt;= 0xc000000000300000 if you want to leave space for # symmon, 0xc00000000001c000 for production kernels. Note that the value must # be 16kb aligned or the handling of the current variable will break. #   asmlinkage include/linux/linkage.h：\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;asm/linkage.h\u0026gt; #ifdef __cplusplus #define CPP_ASMLINKAGE extern \u0026#34;C\u0026#34; #else #define CPP_ASMLINKAGE #endif  #ifndef asmlinkage #define asmlinkage CPP_ASMLINKAGE #endif   include/asm-mips/linkage.h：\n1  /* Nothing to see here... */   在 MIPS 下，asmlinkage 只是为了兼容 C++。\n__init include/linux/init.h：\n1  #define __init __attribute__ ((__section__ (\u0026#34;.init.text\u0026#34;)))   把函数放到 .init.text 段。\n__acquires 和 __releases include/linux/compiler.h：\n1 2  # define __acquires(x) __attribute__((context(0,1))) # define __releases(x) __attribute__((context(1,0)))   给 Sparse 做代码静态检查，用于保证 __acquires 和 __releases 成对使用。Sparse 的相关内容可以参考 The Linux Kernel documentation。\n__lockfunc include/linux/spinlock.h：\n1  #define __lockfunc fastcall __attribute__((section(\u0026#34;.spinlock.text\u0026#34;)))   include/linux/linkage.h：\n1 2 3 4  #ifndef FASTCALL #define FASTCALL(x) x #define fastcall #endif   include/asm-mips/linkage.h：\n1  /* Nothing to see here... */   在 MIPS 下，fastcall 为空，__lockfunc 只是为了把函数放到 .spinlock.text 段。\n","permalink":"https://freeflyingsheep.github.io/posts/tips/mips-boot/","summary":"\u003cp\u003e阅读 MIPS 启动部分的代码，从内核入口 \u003ccode\u003ekernel_entry\u003c/code\u003e 到 \u003ccode\u003estart_kernel\u003c/code\u003e 的第一个子函数 \u003ccode\u003elock_kernel\u003c/code\u003e，很多细节我并没理解，所以不进行展开。基于 Linux kernel release 2.6.11.12。由于 Markdown 代码块语法高亮不支持汇编，此处统一用 \u003ccode\u003eC\u003c/code\u003e 标注。\u003c/p\u003e","title":"Linux/MIPS 启动"},{"content":"根据 Pro Git (2nd Edition)（中文版）整理。\nGit 基础 初次运行 Git 前的配置 1 2  git config --global user.name \u0026#34;FreeFlyingSheep\u0026#34; git config --global user.email \u0026#34;chris.chenfeiyang@outlook.com\u0026#34;   代理配置 设置代理 1 2 3 4  git config --global https.proxy \u0026#34;http://127.0.0.1:xxxx\u0026#34; git config --global https.proxy \u0026#34;https://127.0.0.1:xxxx\u0026#34; git config --global http.proxy \u0026#34;socks5://127.0.0.1:xxxx\u0026#34; git config --global https.proxy \u0026#34;socks5://127.0.0.1:xxxx\u0026#34;   取消代理 1 2  git config --global --unset http.proxy git config --global --unset https.proxy   获取 Git 仓库 在已存在目录中初始化仓库 1 2  cd \u0026lt;my_project\u0026gt; git init   克隆现有的仓库 1  git clone \u0026lt;url\u0026gt; [my_name]   查看文件状态 1  git status   查看修改内容 1  git diff   git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。\n跟踪新文件 1  git add \u0026lt;file\u0026gt; ...   提交更新 1  git commit -m \u0026#39;\u0026lt;message\u0026gt;\u0026#39;   忽略文件 文件 .gitignore 的格式规范如下：\n 所有空行或者以 # 开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中 匹配模式可以以（/）开头防止递归 匹配模式可以以（/）结尾指定目录 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反  所谓的 glob 模式是指 shell 所使用的简化了的正则表达式：\n 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c） 问号（?）只匹配一个任意字符 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字） 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z、a/b/z 或 a/b/c/z 等  GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表。\n在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。\n移除文件 1  git rm \u0026lt;file\u0026gt; ...   如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f。\n另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用 --cached 选项。\n移动文件 1  git mv \u0026lt;file_from\u0026gt; \u0026lt;file_to\u0026gt;   查看提交历史 1  git log   撤消操作 补上遗漏的文件 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了，此时，可以运行带有 --amend 选项的提交命令来重新提交：\n1 2 3  git commit -m \u0026#39;initial commit\u0026#39; git add forgotten_file git commit --amend   取消暂存的文件 1  git reset HEAD \u0026lt;file\u0026gt; ...   撤消对文件的修改 1  git checkout -- \u0026lt;file\u0026gt;   请务必记得这是一个危险的命令，你对那个文件在本地的任何修改都会消失—— Git 会用最近提交的版本覆盖掉它。除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。\n远程仓库的使用 查看远程仓库 1  git remote -v   添加远程仓库 1  git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt;   从远程仓库中抓取 1  git fetch [\u0026lt;remote\u0026gt;]   这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n必须注意该命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。\n从远程仓库中拉取 1  git pull [\u0026lt;remote\u0026gt;]   如果你的当前分支设置了跟踪远程分支，那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。\n默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n推送到远程仓库 1  git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;   查看某个远程仓库 1  git remote show \u0026lt;remote\u0026gt;   远程仓库的重命名 1  git remote rename \u0026lt;old\u0026gt; \u0026lt;new\u0026gt;   远程仓库的移除 1  git remote remove \u0026lt;remote\u0026gt;   标签 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n附注标签是存储在 Git 数据库中的一个完整对象，它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间，此外还有一个标签信息，并且可以使用 GNU Privacy Guard（GPG）签名并验证。通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n列出标签 1  git tag   创建标签 创建附注标签：\n1  git tag -a \u0026lt;tagname\u0026gt; -m \u0026#34;\u0026lt;message\u0026gt;\u0026#34;   创建轻量标签：\n1  git tag \u0026lt;tagname\u0026gt;   轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字。\n显示标签信息 1  git show \u0026lt;tagname\u0026gt;   在附注标签上运行 git show，输出会显示打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。\n在轻量标签上运行 git show，你不会看到额外的标签信息，命令只会显示出提交信息。\n后期打标签 你也可以对过去的提交打标签，只需要在命令的末尾指定提交的校验和（或部分校验和）。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  $ git log --pretty=oneline 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch \u0026#39;experiment\u0026#39; a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support 0d52aaab4479697da7686c15f77a3d64d9165190 one more thing 6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch \u0026#39;experiment\u0026#39; 0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function 4682c3261057305bdd616e23b64b0857d832627b added a todo file 166ae0c4d3f420721acbb115cc33848dfcc2121a started write support 9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile 964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo 8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme $ git tag -a v1.2 9fceb02 $ git tag v0.1 v1.2 v1.3 v1.4 v1.4-lw v1.5 $ git show v1.2 tag v1.2 Tagger: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Feb 9 15:32:16 2009 -0800 version 1.2 commit 9fceb02d0ae598e95dc970b74767f19372d61af8 Author: Magnus Chacon \u0026lt;mchacon@gee-mail.com\u0026gt; Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile ...   共享标签 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行 git push origin \u0026lt;tagname\u0026gt;。\n如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。\n删除标签 要删除掉你本地仓库上的标签，可以使用命令 git tag -d \u0026lt;tagname\u0026gt;。\n一种直观的删除远程标签的方式是使用命令 git push origin --delete \u0026lt;tagname\u0026gt;。\n检出标签 1  git checkout \u0026lt;tagname\u0026gt;   Git 别名 1  git config --global alias.\u0026lt;alias\u0026gt; \u0026lt;commond\u0026gt;   例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n1  git config --global alias.unstage \u0026#39;reset HEAD --\u0026#39;   这会使下面的两个命令等价：\n1 2  git unstage fileA git reset HEAD -- fileA   这样看起来更清楚一些。通常也会添加一个 last 命令，像这样：\n1  git config --global alias.last \u0026#39;log -1 HEAD\u0026#39;   这样，可以轻松地看到最后一次提交。\nGit 分支 创建分支 1  git branch \u0026lt;branch\u0026gt;   切换分支 1  git checkout \u0026lt;branch\u0026gt;   创建并切换分支 1  git checkout -b \u0026lt;branch\u0026gt;   合并分支 切换（checkout）到想要合并入的分支，如 master，然后执行：\n1  git merge \u0026lt;branch\u0026gt;   如何解决合并冲突，举个例子，如果你对 #53 问题的修改和有关 hotfix 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：\n1 2 3 4  $ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.   你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：\n1 2 3 4 5 6 7 8  $ git status On branch master You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) Unmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: index.html no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;)   Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n1 2 3 4 5 6 7  \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD:index.html \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt;contact : email.support@github.com\u0026lt;/div\u0026gt; ======= \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; please contact us at support@github.com \u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; iss53:index.html   这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。例如，你可以通过把这段内容换成下面的样子来解决冲突：\n1 2 3  \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; please contact us at email.support@github.com \u0026lt;/div\u0026gt;   上述的冲突解决方案仅保留了其中一个分支的修改，并且 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;，=======，和 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这些行被完全删除了。在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\n删除分支 1  git branch -d \u0026lt;branch\u0026gt;   若要删除包含了还未合并的工作的分支，-d 选项需要改为 -D。\n查看分支历史 1  git log --oneline --decorate --graph --all   查看分支列表 1  git branch   加 -v 选项查看每一个分支的最后一次提交，--merged 与 --no-merged 选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。\n远程分支 跟踪远程分支 远程分支以 \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; 命名，跟踪远程分支可以用如下命令：\n1  git checkout -b \u0026lt;branch\u0026gt; \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt;   或者可以使用如下命令：\n1  git checkout --track \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt;   如果你尝试检出的分支不存在且刚好只有一个名字与之匹配的远程分支，那么 Git 就会自动为你创建一个跟踪分支：\n1  git checkout \u0026lt;branch\u0026gt;   设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置：\n1  git branch -u \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt;   查看跟踪分支 1  git branch -vv   拉取远程分支 见从远程仓库中抓取和从远程仓库中拉取。\n不管设置好的跟踪分支是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n推送远程分支 见推送到远程仓库。\n删除远程分支 1  git push \u0026lt;remote\u0026gt; --delete \u0026lt;branch\u0026gt;   变基 1  git rebase \u0026lt;branch\u0026gt;   变基的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码进行变基，然后再向主模块提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n以一个例子说明合并（merge）和变基（rebase）的区别，假设现在分支如下：\n把 experiment 合并到 master：\n对应的操作如下：\n1 2  git checkout master git merge experiment   可以看到，历史记录不是一条直线 。\n如果先把 experiment 变基到 master：\n然后再进行合并操作：\n对应的操作如下：\n1 2 3 4  git checkout experiment git rebase master git checkout master git merge experiment   这样历史记录就是一条直线了。\n变基的准则：如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\nGithub 生成 SSH 公钥 1  ssh-keygen -t rsa -C \u0026#34;chris.chenfeiyang@outlook.com\u0026#34;   添加 SSH 公钥 1  cat ~/.ssh/id_rsa.pub   将内容添加到 Github 相应页面添加公钥。\n验证 1  ssh -T git@github.com   首次使用需要确认并添加主机到本机SSH可信列表。若返回 Hi FreeFlyingSheep! You've successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。\n子模块 添加子模块 1  git submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt;   生成的 .gitmodules 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射。\n克隆含有子模块的项目 1 2 3  git clone \u0026lt;url\u0026gt; git submodule init git submodule update   其中，后两行命令可以合并为如下命令：\n1  git submodule update --init   或者，直接使用如下命令一步到位：\n1  git clone --recurse-submodules \u0026lt;url\u0026gt;   从项目远端拉取上游更改 可以进入到目录中运行 git fetch 与 git merge，或者执行以下命令：\n1  git submodule update --remote   Git 默认会尝试更新所有子模块，你也可以传递想要更新的子模块的名字。\n为了安全起见，如果主模块提交了你刚拉取的新子模块，那么应该在 git submodule update 后面添加 --init 选项，如果子模块有嵌套的子模块，则应使用 \u0026ndash;recursive 选项。 如果你想自动化此过程，那么可以为 git pull 命令添加 --recurse-submodule。\n在子模块上工作 首先，进入每个子模块并检出其相应的工作分支。\n接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 git submodule update --remote 来从上游拉 取新工作。你可以选择将它们合并（--merge）到你的本地工作中，也可以尝试将你的工作变基（--rebase）到新的更改上。\n如果你忘记 --rebase 或 --merge，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支然后手动地合并或变基任何一个你想要的远程分支就行了。\n查看子模块修改内容 1  git diff --submodule   查看子模块提交历史 1  git log -p --submodule   提交子模块更新 1  git commit -am \u0026#39;\u0026lt;message\u0026gt;\u0026#39;   发布子模块改动 在推送主模块前，应该先推送所有子模块。\n可以使用 check 选项，这样如果任何提交的子模块改动没有推送，push 操作会直接失败：\n1  git push --recurse-submodules=check   或者在主模块推送时采用 on-demand 选项，让 Git 自己尝试这么做：\n1  git push --recurse-submodules=on-demand   切换带子模块的项目的分支 1  git checkout --recurse-submodules \u0026lt;branch\u0026gt;   删除子模块  执行 git rm \u0026lt;submodule\u0026gt; 删除子模块目录。 删除 .git/modules 下子模块相关内容。 编辑 .git/config 删除子模块相关内容。 执行 git commit 提交更新。  贮藏 贮藏工作 1  git stash [push]   查看贮藏的工作 1  git stash list   应用贮藏 将刚刚贮藏的工作重新应用：\n1  git stash apply   应用一个更旧的贮藏，可以通过名字指定它：\n1  git stash apply \u0026lt;stashname\u0026gt;   比如：\n1  git stash apply stash@{2}   应用选项只会尝试应用贮藏的工作，不会把贮藏从堆栈上移除。\n移除贮藏 1  git stash drop \u0026lt;stashname\u0026gt;   应用并移除贮藏 1  git stash pop   ","permalink":"https://freeflyingsheep.github.io/posts/git/command/","summary":"\u003cp\u003e根据 \u003cem\u003e\u003ca href=\"https://git-scm.com/book/zh/v2\"\u003ePro Git (2nd Edition)\u003c/a\u003e\u003c/em\u003e（中文版）整理。\u003c/p\u003e","title":"Git 常用命令"},{"content":"针对 MIPS 汇编 和 MIPS 体系结构 的补充内容。\nABI 以下内容来自 MIPS Assembly Language Programmer’s Guide 。\n对于 n64，部分整数寄存器的约定见下表：\n   寄存器名称 助记符 用途 保存者     $0 zero 永远返回0    $1 at 汇编器保留 调用者   $2-$3 v0-v1 函数返回值 调用者   $4-$11 a0-a7 子程序参数 调用者   $12-$15 t4-t7 临时寄存器 调用者   $16-$23 s0-s7 保存寄存器 被调用者   $24 t8 临时寄存器 调用者   $25 t9 临时寄存器 调用者   $26-$27 k0-k1 内核保留    $28 gp 全局指针 被调用者   $29 sp 栈指针 被调用者   $30 s8 帧指针 被调用者   $31 ra 返回地址 调用者    对于整数寄存器，o32 和 n64 的部分区别见下表：\n   属性 o32 n64     寄存器长度 32 位 64 位   当参数为结构体时，通过寄存器传递的大小 32 位 64 位   参数寄存器保存者 调用者 被调用者（只在需要时保存）   当返回值为结构体时，通过寄存器返回的大小 不保存 最多 128 位   当返回值为结构体时，第一个参数由 $2 返回 是 否   返回地址存放位置 $31，支持 .mask 指令 任意寄存器   全局指针保存者 调用者保存 被调用者保存    虚拟地址空间 以下内容来自 The MIPS64 and microMIPS64 Privileged Resource Architecture v6.03 。\n虚拟地址空间如下图所示：\n特别地，对于 xkphys 空间，虚拟地址的格式如下：\n针对 CCA 部分，具体描述如下：\n根据上表描述的属性，xkphys 空间包括八个地址范围，每个地址范围提供了进入物理内存的 $2^{PABITS}$ 字节的窗口，因此不会使用TLB转换地址。\nLinux/MIPS 的内存管理  32 位的 Linux/MIPS 内核假定整个低内存可通过 kseg0 访问，这一空间但最多 512MB。通常会保留该地址空间的一部分供其他使用，因此把低端内存限制为256MB，超出此范围的内存通过高端内存来访问。 64位的 Linux/MIPS 内核通过xkphys访问低端内存。由于 xkphys 的大小足够，整个物理内存是可以直接访问的，因此不需要高端内存。  参考文档 MIPS 体系结构的文档可在官网上找到：\n MIPS32 Architecture MIPS64 Architecture ","permalink":"https://freeflyingsheep.github.io/posts/mips/supplement/","summary":"\u003cp\u003e针对 \u003ca href=\"/posts/mips/mips_assembly\"\u003eMIPS 汇编\u003c/a\u003e 和 \u003ca href=\"/posts/mips/see_mips_run\"\u003eMIPS 体系结构\u003c/a\u003e 的补充内容。\u003c/p\u003e","title":"MIPS（补充内容）"},{"content":"根据 See MIPS Run (Second Edition)（中文版）整理。\n流水线 MIPS 的流水线对程序员不完全透明，由此带来了延迟槽问题：\n 分支延迟槽：紧跟在分支指令后的那条指令将被执行，对于条件分支问题需要特别小心 加载延迟槽：紧跟在加载指令后的那条指令不能使用刚刚加载的数据  利用该特性，可以把其他有用的指令移到在延迟槽运行，但现在这些步骤通常由汇编器完成。\n虚拟地址空间 32 位虚拟地址空间 32 位地址空间如下图所示：\n下面只考虑带 MMU 的机器，其余情况需要查相应机器的手册。\n  kuseg（0x0000 0000-0x7FFF FFFF）：作为用户态可用的地址，这些地址将被 MMU 转换，不能在 MMU 设置好前使用。部分文档也将这部分空间称为 useg，但不建议这么称呼。\n  kseg0（0x8000 0000-0x9FFF FFFF）：映射低 512 MB 物理地址，用于存放操作系统核心。通过把最高位清零转换成物理地址，但会经过高速缓存，因此需要先初始化高速缓存。\n  kseg1（0xA000 0000-0xBFFF FFFF）：重复映射低 512 MB 物理地址，用于存取初始的程序的 ROM以及作为 I/O 寄存器。通过把最高 3 位清零转换成物理地址，不会经过告诉缓存，因此是系统重启时唯一能正常工作的地址空间。复位入口点存放于 0xBFC0 0000，对应物理地址 0x1FC0 0000.\n  kseg2（0xC000 0000-0xFFFF FFFF）：由操作系统内核使用，只能在内核态访问，需要被 MMU 转换，不能在 MMU 设置好前使用。\n  64 位虚拟地址空间 64 位地址空间被包在32 位地址空间中，如下图所示：\n高速缓存的重影问题/别名（alias）问题 MIPS 的一级高速缓存通常采用虚拟地址生成索引，而采用物理地址作为标签，即 VIPT（Virtually Indexed Physically Tagged）。当页面大小 $\u0026lt;$ 高速缓存索引范围时，就可能出现重影，如下图所示：\n假设 32 位虚拟地址，使用 4K 的页面大小和 32K 四路组相联的高速缓存（8K 的高速缓存索引范围），且某个物理地址被同时映射到了连续的页——虚拟地址 0 和 4K 处。\n当访问虚拟地址 0（0x0000 0000）处的数据时，该处的数据被加载到高速缓存的某个位置。之后访问虚拟地址 4K（0x0000 1000）处的数据，由于页面大小（4K，占 12 位）$\u0026lt;$ 索引范围（8K，占 13 位），此时生成的索引与访问 0 处生成的索引不同（虚拟地址和物理地址的位 0-11 相同，位 12 不同），因此该数据被认为不在缓存中（未命中），然后被加载到高速缓存的另一个位置。现在在高速缓存中存在数据的两个副本，产生了重影。\nMIPS 的二级缓存开始，通常采用物理地址作为索引和标签，即 PIPT（Physically Indexed Physically Tagged），因而不会产生重影问题。\n异常 精确异常 在具备精确异常特性的 CPU 上，任何异常发生时，EPC 都指向异常受害指令。在该指令之前的指令全部执行完毕，之后的指令就好像没执行过一样（重新执行时要保证和没发生异常时的行为一样）。\n在早期非精确异常的 CPU 上，乘除法运算不可停止（即使在异常发生时），乘除法指令和 mflo/mfhi 指令之间，必须插入两条非乘除法指令，来避免因改写 lo 和 hi 寄存器而得到错误的结果。\n异常处理流程 当 MIPS CPU 决定处理异常时，会执行下列操作：\n 设置 EPC 指向重新开始的地址。 设置 SR(EXL) 位，强制 CPU 进入内核态并禁止中断； 设置 Cause 寄存器、BadVaddr（当地址异常时）、某些 MMU 寄存器（当存储系统异常时）。 从异常入口点取指，转到异常处理程序。  异常处理程序执行以下操作：\n 腾出空间完成引导。 查询 Cause(ExcCode) 分派不同的异常。 分配栈空间并保存相应寄存器来构造异常处理环境（可以在分派不同的异常前完成这项工作）。 处理异常。 恢复保存的寄存器，修改SR寄存器来准备返回。 执行 eret 指令（该指令会清楚 SR(EXL) 位并返回到 EPC 保存的地址）从异常返回。  汇编 分类 指令按功能可以分为 12 类：\n 空操作（No-op） 寄存器/寄存器传输（包括条件传送） 常数加载 算数/逻辑指令 整数乘法、除法和求余数 整数乘加 加载和存储 跳转、子程序调用和分支 断点和自陷 CP0 功能（CPU 控制指令） 浮点 用户态下对底层特性的受限访问（rdhwr 和 synci）  特殊指令及其用途 已经在其他章节介绍过的指令不再介绍，此处只列举部分常用的指令。\n连锁加载/条件存储 指令 ll（load linked）和 sc（store conditional）提供“测试——设置”序列，在运行时不保证原子性，但仅当结果恰好是原子性的时候才能返回成功。\n   指令格式 含义     ll d,o(b) d = memory[o + b]，在 CPU 内设置不可见的连锁状态位，同时把加载地址保存在 LLAddr 寄存器中   sc t,o(b) 检查从上次执行的 ll 指令开始以来的“读——改——写”序列是否能原子性的完成，若能，memory[o + b] = t; t = 1；若不能，t = 0    指令 sc 的失败有两种可能的原因：\n 发生了异常 多处理器下另一个 CPU 写入了附近的位置  以下是用该对指令实现“原子加一”操作的示例，对应 Linux 内核调用 atomic_inc(\u0026amp;mycount)：\natomic_inc: ll v0, 0(a0) # a0 指向 mycount addu v0, 1 sc v0, 0(a0) beq v0, zero, atomic_inc # 当 sc 失败时重试 nop jr ra nop  条件传送    指令格式 含义     movz d,s,t if (!t) d = s    数据存储防护    指令格式 含义     sync 存取防护，所有在该指令前发起的存取操作的结果，在该指令后的任何存取操作中都能“见到”    注意，该指令只保证后续指令能“见到”，但对存取操作和 sync 本身执行的相对时序没有保证，仅仅是把该指令和之后的指令存取操作分开，不能保证解决 CPU 的程序执行和外部写之间的时序关系问题。\n用户态下对底层特性的受限访问    指令格式 含义     rdhwr 读取硬件寄存器   synci 为改写指令的程序做高速缓存管理   ","permalink":"https://freeflyingsheep.github.io/posts/mips/see-mips-run/","summary":"\u003cp\u003e根据 \u003cem\u003eSee MIPS Run (Second Edition)\u003c/em\u003e（中文版）整理。\u003c/p\u003e","title":"MIPS 体系结构"},{"content":"根据 Programmed Introduction to MIPS Assembly Language 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。\n寄存器 通用寄存器 MIPS 提供 32 个 32 位的通用寄存器。\n   寄存器 助记符 用途     $0 zero 常数零   $1 $at 汇编器保留   $2，$3 $v0，$v1 子程序返回值   $4-$7 $a0-$a3 子程序参数   $8-$15 $t0-$t7 临时寄存器（调用者保存）   $16-$23 $s0-$s7 保存寄存器（被调用者保存）   $24，$25 $t8，$t9 临时寄存器（调用者保存）   $26，$27 $k0，$k1 操作系统保留   $28 $gp 全局指针   $29 $sp 栈指针   $30 $fp 帧指针   $31 $ra 返回地址    特殊寄存器 MIPS 提供一对 32 位寄存器 hi 和 lo 来帮助完成乘法、除法运算。\n浮点寄存器 MIPS 有 32 个 32 位的浮点寄存器 $f0 – $f31。\n指令格式 R 型（用于寄存器）    字段名 op rs rt rd shamt funct     含义 操作码 第一个源操作数寄存器 第二个源操作数寄存器 目的寄存器 位移量 功能码   长度 6 5 5 5 5 6    由于 shamt 用 5 位表示，所以 $0 \\le$ shamt $\u0026lt; 2^{5}$。\nI 型（用于立即数）    字段名 op rs rt immediate     含义 操作码 源操作数寄存器 目的寄存器 立即数   长度 6 5 5 16    由于 immediate 用 16 位表示，所以 $-2^{15} \\le$ immediate $\u0026lt; 2^{15}$ 。\n注意，此处 rt 的含义与上面不同，且后面的指令如不注明，immediate 默认被符号扩展为 32 位！\nJ 型（用于分支和跳转）    字段名 op address     含义 操作码 地址   长度 6 26    特别的，对于条件分支指令，地址字段可能又被划分为了多个部分。\n基本汇编指令 算术运算指令 加法指令    指令格式 含义     addu rd,rs,rt rd = rs + rt（溢出时不产生异常）   add rd,rs,rt rd = rs + rt（溢出时产生异常）   addiu rt,rs,immediate rt = rs + immediate（溢出时不产生异常）   addi rt,rs,immediate rt = rs + immediate（溢出时产生异常）    注意，MIPS 只有 32 位算术运算，在高级语言中需要进行 16 位或 8 位算术运算时，编译器可能产生更多的指令来模拟这些运算，这意味这 32 位算术运算的速度往往会快于其他情况，而不是数据长度越短运算越快。\n减法指令    指令格式 含义     subu rd,rs,rt d = rs-rt（溢出时不产生异常）   sub rd,rs,t d = rs-rt（溢出时产生异常）   subiu rd,rs,immediate d = rs-immediate （溢出时不产生异常）   subi rd,rs,immediate d = rs-immediate（溢出时产生异常）    乘法指令    指令格式 含义     mult rd,rt hilo = rd * rt（有符号数）   multu rd,rt hilo = rd * rt（无符号数）     hi：结果的高 32 位 lo：结果的低 32 位  注意，此处指令中带的 u 和加减法指令含义不同。对于加减法，有符号和无符号数的运算相同，区别仅在带 u 的版本溢出时不产生异常；而对于乘除法，有符号和无符号数的运算不同，且无论是否溢出，都不产生异常，区别仅在带 u 的版本特指无符号数运算。\n除法指令    指令格式 含义     div rd,rt lo = rd / rt; hi = rd % rt（有符号数）   divu rd,rt lo = rd / rt; hi = rd % rt（无符号数）     lo：商 hi：余数  逻辑运算指令 位运算指令    指令格式 含义     ori rt,rs,immediate `rt = rs   andi rt,rs,immediate rt = rs \u0026amp; immediate   xori d,s,immediate rt = rs ^ immediate   or rd,rs,rt `rd = rs   and rd,rs,rt rd = rs \u0026amp; rt   xor rd,rs,rt rd = rs ^ rt   nor rd,rs,rt `rd = ~(rs    移位指令    指令格式 含义     sll rd,rt,shamt rd = rt \u0026lt;\u0026lt; shamt   srl rd,rt,shamt rd = rt \u0026gt;\u0026gt; shamt（逻辑右移）   sra rd,rt,shamt rd = rt \u0026gt;\u0026gt; shamt（算术右移）    特殊用法    指令格式 含义     nor rd,rs,$0 rd = ~rs   or rd,rs,$0 rd = rs   sll $0,$0,0 空操作    由于对 $0 的改写无实际意义，所以可以借助 $0 实现空操作。\n数据传输指令    指令格式 含义     lw rt,immediate(rs) rt = memory[rs + immediate]   sw rt,immediate(rs) memory[rs + immediate] = rt   lh rt,immediate(rs) rt = memory[rs + immediate]   lhu rt,immediate(rs) rt = memory[rs + immediate]（零扩展）   sh rt,immediate(rs) memory[rs + immediate] = rt   lb rt,immediate(rs) rt = memory[rs + immediate]   lbu rt,immediate(rs) rt = memory[rs + immediate]（零扩展）   sb rt,immediate(rs) memory[rs + immediate] = rt   lui rt,immediate rt = immediate * 2^16     w：字，32 位 h：半字，16位 b：字节，8 位  MIPS 可以使用大端序和小端序，具体由系统设计人员决定。\n若要生成 32 位立即数用于寄存器基址寻址，可以先用 lui 指令加载高位，再用 ori 或者 lw 指令填充低位，以完成 $12 = memory[$13 + 0xC] 为例，有以下两种方式：\n# 方式一 lui $13,0x0060 ori $13,0x5000 # 简化版 ori 指令，同 ori $13,$13,0x5000 lw $12,0xC($13) # 方式二 lui $13,0x0060 lw $12,0x500C($13)  无条件跳转指令    指令格式 含义     j address goto address * 4   jal address $ra = PC + 4; goto address * 4   jr register goto register    MIPS 的指令总是 32 位的，因此指令是 4 字节对齐的，32 位地址的低 2 位永远为 0。将 32 位目标地址右移 2 位，然后存储低 26 位，这 26 位的地址实际可以替代 PC 的低 28 位。\n注意，使用 j 指令时，PC 的高 4 位是不变的，这意味着寻址界限为 256 MB，超过该界限时，应该使用寄存器跳转指令 （通常编译器会完成这些操作）。\n可以使用符号地址来简化编程：\nmain: ... j main  条件分支指令 条件跳转指令    指令格式 含义     beq register1,register2,address if (register1 == register2) goto PC + 4 + address * 4   bne register1,register2,address if (register1 != register2) goto PC + 4 + address * 4   bltz register,label if (register \u0026lt; 0) goto PC + 4 + address * 4   bgez register,label if (register \u0026gt;= 0) goto PC + 4 + address * 4    条件跳转指令使用 PC 相对寻址。\n条件置位指令    指令格式 含义     slt rd,rs,rt if (rs \u0026lt; rt) rd = 1; else rd = 0（有符号数）   sltu rd,rs,rt if (rs \u0026lt; rt) rd = 1; else rd = 0（无符号数）   slti rt,rs,immediate if (rs \u0026lt; immediate) rt = 1; else rt = 0（有符号数）   sltiu rt,rs,immediate if (rs \u0026lt; immediate) rt = 1; else rt = 0（无符号数）    再次强调，虽然 sltiu 代表无符号版本，但立即数会先被符号展开，然后再作为无符号数比较。\n其他指令    指令格式 含义     mfhi rd rd = hi   mflo rd rd = lo   syscall 系统调用    注意，在早期的 MIPS 处理器上，mfhi 和 mflo 指令后的两条指令，不得出现乘法和除法指令，其原因涉及 MIPS 流水线的工作方式。\n伪指令 算术运算伪指令    指令格式 含义     addu d,s,x d = s + x   subu d,s,x d = s-x   negu d,s d = -s   mul d,s,t d = s * t（结果不超过 32 位）   div d,s,t d = s / t（有符号数）   divu d,s,t d = s / t（无符号数）   remu d,s,t d = s % t（无符号数）   abs d,s `d =    其中，x 可以是寄存器、 16 位立即数或 32 位立即数，后面的 x 含义相同，不再重复。\n逻辑运算伪指令    指令格式 含义     not d,s d = ~s   or d,s,x `d = s   and d,s,x d = s \u0026amp; x   rol d,s,t d = s \u0026lt;\u0026lt; t（循环左移）   ror d,s,t d = s \u0026gt;\u0026gt; t（循环右移）    数据传输伪指令    指令格式 含义     move d,s d = s   li d,value d = value（value 可以是 16 位或 32 位）   la d,exp d = address(exp)（exp 通常是一个符号地址）   lw d,exp d = memory[exp]   sw d,exp memory[exp] = d    伪指令还允许借助符号地址来寻址，示例如下：\nli $t1,2 # index 2 lb $v0,data($t1) # $v0 = data[$t1] ... data: .byte 6,34,12,-32, 90  条件分支伪指令 条件跳转伪指令    指令格式 含义     b label goto label   beq s,x,label if (s == x) goto label   beqz s,label if (s == 0) goto label   bge s,x,label if (s \u0026gt;= x) goto label (有符号数)   bgeu s,x,label if (s \u0026gt;= x) goto label (无符号数)   bgez s,label if (s \u0026gt;= 0) goto label (有符号数)   bgt s,x,label if (s \u0026gt; x) goto label (有符号数)   bgtu s,x,label if (s \u0026gt; x) goto label (无符号数)   bgtz s,label if (s \u0026gt; 0) goto label (有符号数)   ble s,x,label if (s \u0026lt;= x) goto label (有符号数)   bleu s,x,label if (s \u0026lt;= x) goto label (无符号数)   blez s,label if (s \u0026lt;= 0) goto label (有符号数)   blt s,x,label if (s \u0026lt; x) goto label (有符号数)   bltu s,x,label if (s \u0026lt; x) goto label (无符号数)   bltz s,label if (s \u0026lt; 0) goto label (有符号数)   bnez s,label if (s != 0) goto label   bne s,x,label if (s != x) goto label    注意，所有的分支指令都只能跳转到分支附近的位置，它只使用 16 位来表示地址。\n条件置位伪指令    指令格式 含义     slt d,s,x if (s \u0026lt; x) d = 1; else d = 0   seq d,s,x if (s == x) d = 1; else d = 0   sge d,s,x if (s \u0026gt;= x) d = 1; else d = 0 (有符号数)   sgeu d,s,x if (s \u0026gt;= x) d = 1; else d = 0 (无符号数)   sgt d,s,x if (s \u0026gt; x) d = 1; else d = 0 (有符号数)   sgtu d,s,x if (s \u0026gt; x) d = 1; else d = 0 (无符号数)   sle d,s,x if (s \u0026lt;= x) d = 1; else d = 0 (有符号数)   sleu d,s,x if (s \u0026lt;= x) d = 1; else d = 0 (无符号数)   slt d,s,x if (s \u0026lt; x) d = 1; else d = 0 (有符号数)   slti d,s,immediate if (s \u0026lt; immediate) d = 1; else d = 0 (有符号数)   sltu d,s,x if (s \u0026lt; x) d = 1; else d = 0 (无符号数)   sltiu d,s,immediate if (s \u0026lt; immediate) d = 1; else d = 0 (无符号数)   sne d,s,x if (s != x)    浮点伪指令    指令格式 含义     l.s fd,address fd = memory[address]   s.s fd,address memory[address] = fd   li.s fd,value fd = value   abs.s fd,fs `$d =   add.s fd,fs,ft fd = fs + ft   sub.s fd,fs,ft fd = fs-ft   mul.s fd,fs,ft fd = fs * ft   div.s fd,fs,ft fd = fs / ft   neg.s fd,fs fd = -fs   mov.s fd, fs fd = fs   mtc1 rs, fd fd = rs（直接赋值，不进行转换，注意此处目标寄存器和源寄存器顺序）   mfc1 rd, fs rd = fs（直接赋值，不进行转换）   c.eq.s fs, ft if (fs == ft) condition bit = 1; else condition bit = 0   c.lt.s fs, ft if (fs \u0026lt; ft) condition bit = 1; else condition bit = 0   c.le.s fs, ft if (fs \u0026lt;= ft) condition bit = 1; else condition bit = 0   bc1t label if (condition bit = 1) goto label   bc1f label if (condition bit = 0) goto label    部分 MIPS 处理器只允许在单精度浮点指令中使用 $f0、$f2 、 \u0026hellip; 、 $f30 寄存器。以上 .s 结尾的都是单精度浮点指令，对于双精度，将 s 替换为 d 即可，这样 MIPS 将使用寄存器对来进行运算，寄存器对的名称是 $f0、$f2 、 \u0026hellip; 、 $f30。\n其他伪指令    指令格式 含义     nop 空操作    汇编器指令    语法 用途     .text 表明代码段的开始   .globl 表明标识符是一个全局符号   .data 表明数据段的开始   .byte 放置一个 8 位的整数，多个整数用逗号隔开   .word 放置一个 32 位的整数，多个整数用逗号隔开   .space 在内存中保留的字节数   .ascii 放置一个 ASCII 字符串   .asciiz 放置一个 C 风格的字符串 (以 \\0 结尾的 ASCII 字符串)   .float 放置一个 32 位的单精度浮点数，多个浮点数用逗号隔开    栈 在 MIPS 中，栈是向下增长的。\n通过以下代码实现 push 操作：\n# PUSH the item in $t0: subu $sp,$sp,4 # point to the place for the new item, sw $t0,($sp) # store the contents of $t0 as the new top.  通过以下代码实现 pop 操作：\n# POP the item into $t0: lw $t0,($sp) # Copy top item to $t0. addu $sp,$sp,4 # Point to the item beneath the old top.  子程序连接 基于堆栈的连接约定  调用子程序（由调用者完成）： 1.1. 将需要保存的 $t0-$t9 寄存器入栈，子程序可能会修改它们。 1.2. 将参数放入 $a0-$a3。 1.3. 使用 jal 指令调用子程序。 子程序 prolog（由子程序在开头完成）： 2.1. 如果该子程序需要调用其他子程序，将 $ra 入栈。 2.2. 将需要修改的 $s0-$s7 寄存器入栈。 子程序主体: 3.1. 子程序可以修改 $t0-$t9、$a0-$a3 和 2.2 中保存的寄存器。 3.2. 如果子程序需要调用其他子程序，也必须遵守这些约定。 子程序 epilog（由子程序在返回前完成）： 4.1. 将返回值放入 $v0-$v1。 4.2. 将 2.2 中保存的寄存器按与入栈时相反的顺序出栈。 4.3. 如果 $ra 在 2.1 中被保存，将它出栈。 4.4. 使用 ja $ra 指令返回。 从子程序重新获得控制权（由调用者完成）： 5.1. 将 1.1 中保存的寄存器按与入栈时相反的顺序出栈。  基于栈帧的连接约定 以下约定假设栈只存储 32 位的数据。\n 调用子程序（由调用者完成）： 1.1. 按数字顺序将需要保存的 $t0-$t9 寄存器入栈。 1.2. 将参数放入 $a0-$a3。 1.3. 使用 jal 指令调用子程序。 子程序 prolog（由子程序在开头完成）： 2.1. 将 $ra 入栈。 2.2. 将调用者的帧指针 $fp 入栈。 2.3. 将需要修改的 $s0-$s7 寄存器入栈。 2.4. 初始化帧指针： $fp = $sp-space，其中 space 指变量占用空间，此处是变量个数的 4 倍。 2.5. 初始化栈指针： $sp = $fp。 子程序主体： 3.1. 子程序可以修改 $t0-$t9、$a0-$a3 和 2.3 中保存的寄存器。 3.2. 子程序根据 disp($fp) 的形式寻址来使用局部变量。 3.3. 子程序可以通过修改 $sp 在栈上存储数据。 3.4. 如果子程序需要调用其他子程序，也必须遵守这些约定。 子程序 epilog（由子程序在返回前完成）： 4.1. 将返回值放入 $v0-$v1。 4.2. $sp = $fp + space。 4.3. 将 2.3 中保存的寄存器按与入栈时相反的顺序出栈。 4.4. 将调用者的帧指针 $fp 出栈。 4.5. 将 $ra 出栈。 4.6. 使用 ja $ra 指令返回。 从子程序重新获得控制权（由调用者完成）： 5.1. 将 1.1 中保存的寄存器按与入栈时相反的顺序出栈。  进入子程序时栈结构如下图所示：\n","permalink":"https://freeflyingsheep.github.io/posts/mips/assembly/","summary":"\u003cp\u003e根据 \u003cem\u003e\u003ca href=\"http://programmedlessons.org/AssemblyTutorial/index.html\"\u003eProgrammed Introduction to MIPS Assembly Language\u003c/a\u003e\u003c/em\u003e 和《计算机组成与设计——软件/硬件接口》（原书第 5 版）整理。\u003c/p\u003e","title":"MIPS 汇编"},{"content":"欢迎来到 FreeFlyingSheep 的小站。\n关于我  菜鸟一枚，建立本站来记录学习笔记，督促自己学习 暂不准备开启博客的评论功能 如果发现博文存在问题，欢迎邮件或 QQ 联系  关于博文  Git：Git 相关的学习笔记 Kernel：Linux 内核相关的学习笔记 LeetCode：LeetCode 刷题笔记 Linux：不同 Linux 发行版的使用记录 LoongArch：LoongArch 体系结构相关的学习笔记 Mips：Mips 体系结构相关的学习笔记 OpenStack：OpenStack 相关的学习笔记 Virtualization: 虚拟化相关的学习笔记 Tips：零散的知识点  联系方式  邮箱：chris.chenfeiyang@outlook.com QQ：1458250037（发送好友请求时请备注本人博客地址 https://freeflyingsheep.github.io/，否则一律不通过） ","permalink":"https://freeflyingsheep.github.io/about/","summary":"\u003cp\u003e欢迎来到 FreeFlyingSheep 的小站。\u003c/p\u003e","title":"关于本站"}]